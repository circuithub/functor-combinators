<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-comment">-- |</span><span>
</span><span id="line-2"></span><span class="hs-comment">-- Module      : Control.Applicative.Step</span><span>
</span><span id="line-3"></span><span class="hs-comment">-- Copyright   : (c) Justin Le 2019</span><span>
</span><span id="line-4"></span><span class="hs-comment">-- License     : BSD3</span><span>
</span><span id="line-5"></span><span class="hs-comment">--</span><span>
</span><span id="line-6"></span><span class="hs-comment">-- Maintainer  : justin@jle.im</span><span>
</span><span id="line-7"></span><span class="hs-comment">-- Stability   : experimental</span><span>
</span><span id="line-8"></span><span class="hs-comment">-- Portability : non-portable</span><span>
</span><span id="line-9"></span><span class="hs-comment">--</span><span>
</span><span id="line-10"></span><span class="hs-comment">-- This module provides functor combinators that are the fixed points of</span><span>
</span><span id="line-11"></span><span class="hs-comment">-- applications of ':+:' and 'Data.Functor.These.These1'.  They are useful</span><span>
</span><span id="line-12"></span><span class="hs-comment">-- for their 'Data.HFunctor.Interpret.Interpret' instances, along with</span><span>
</span><span id="line-13"></span><span class="hs-comment">-- their relationship to the 'Data.HBifunctor.Tensor.Monoidal' instances of</span><span>
</span><span id="line-14"></span><span class="hs-comment">-- ':+:' and 'Data.Functor.These.These1'.</span><span>
</span><span id="line-15"></span><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Control.Applicative.Step</span><span> </span><span class="hs-special">(</span><span>
</span><span id="line-16"></span><span>  </span><span class="annot"><span class="hs-comment">-- * Fixed Points</span></span><span>
</span><span id="line-17"></span><span>    </span><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier">Step</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><span id="line-18"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier">Steps</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><span id="line-19"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#Flagged"><span class="hs-identifier">Flagged</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><span id="line-20"></span><span>  </span><span class="annot"><span class="hs-comment">-- ** Steppers</span></span><span>
</span><span id="line-21"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#stepUp"><span class="hs-identifier">stepUp</span></a></span><span>
</span><span id="line-22"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#stepDown"><span class="hs-identifier">stepDown</span></a></span><span>
</span><span id="line-23"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#stepping"><span class="hs-identifier">stepping</span></a></span><span>
</span><span id="line-24"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#stepsUp"><span class="hs-identifier">stepsUp</span></a></span><span>
</span><span id="line-25"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#stepsDown"><span class="hs-identifier">stepsDown</span></a></span><span>
</span><span id="line-26"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#steppings"><span class="hs-identifier">steppings</span></a></span><span>
</span><span id="line-27"></span><span>  </span><span class="annot"><span class="hs-comment">-- * Void</span></span><span>
</span><span id="line-28"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#absurd1"><span class="hs-identifier">absurd1</span></a></span><span>
</span><span id="line-29"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#Void2"><span class="hs-identifier">Void2</span></a></span><span>
</span><span id="line-30"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#absurd2"><span class="hs-identifier">absurd2</span></a></span><span>
</span><span id="line-31"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#Void3"><span class="hs-identifier">Void3</span></a></span><span>
</span><span id="line-32"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#absurd3"><span class="hs-identifier">absurd3</span></a></span><span>
</span><span id="line-33"></span><span>  </span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-34"></span><span>
</span><span id="line-35"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Control.Natural</span></span><span>
</span><span id="line-36"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><a href="Control.Natural.IsoF.html"><span class="hs-identifier">Control.Natural.IsoF</span></a></span><span>
</span><span id="line-37"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.Bifunctor</span></span><span>
</span><span id="line-38"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.Data</span></span><span>
</span><span id="line-39"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.Deriving</span></span><span>
</span><span id="line-40"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.Functor.Alt</span></span><span>
</span><span id="line-41"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.Functor.Bind</span></span><span>
</span><span id="line-42"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.Functor.These</span></span><span>
</span><span id="line-43"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.Map.NonEmpty</span></span><span>          </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">NEMap</span></span><span class="hs-special">)</span><span>
</span><span id="line-44"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.Pointed</span></span><span>
</span><span id="line-45"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.Semigroup</span></span><span>
</span><span id="line-46"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.Semigroup.Foldable</span></span><span>
</span><span id="line-47"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.Semigroup.Traversable</span></span><span>
</span><span id="line-48"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.These</span></span><span>
</span><span id="line-49"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">GHC.Generics</span></span><span>
</span><span id="line-50"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">GHC.Natural</span></span><span>
</span><span id="line-51"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><span class="hs-identifier">Data.Map.NonEmpty</span></span><span>          </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">NEM</span></span><span>
</span><span id="line-52"></span><span>
</span><span id="line-53"></span><span class="hs-comment">-- | An @f a@, along with a 'Natural' index.</span><span>
</span><span id="line-54"></span><span class="hs-comment">--</span><span>
</span><span id="line-55"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-56"></span><span class="hs-comment">-- 'Step' f a ~ ('Natural', f a)</span><span>
</span><span id="line-57"></span><span class="hs-comment">-- Step f   ~ ((,) Natural) ':.:' f       -- functor composition</span><span>
</span><span id="line-58"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-59"></span><span class="hs-comment">--</span><span>
</span><span id="line-60"></span><span class="hs-comment">-- It is the fixed point of infinite applications of ':+:' (functor sums).</span><span>
</span><span id="line-61"></span><span class="hs-comment">--</span><span>
</span><span id="line-62"></span><span class="hs-comment">-- Intuitively, in an infinite @f :+: f :+: f :+: f ...@, you have</span><span>
</span><span id="line-63"></span><span class="hs-comment">-- exactly one @f@ /somewhere/.  A @'Step' f a@ has that @f@, with</span><span>
</span><span id="line-64"></span><span class="hs-comment">-- a 'Natural' giving you &quot;where&quot; the @f@ is in the long chain.</span><span>
</span><span id="line-65"></span><span class="hs-comment">--</span><span>
</span><span id="line-66"></span><span class="hs-comment">-- Can be useful for using with the 'Data.HBifunctor.Tensor.Monoidal'</span><span>
</span><span id="line-67"></span><span class="hs-comment">-- instance of ':+:'.</span><span>
</span><span id="line-68"></span><span class="hs-comment">--</span><span>
</span><span id="line-69"></span><span class="hs-comment">-- 'Data.HFunctor.Interpret.interpret'ing it requires no constraint on the</span><span>
</span><span id="line-70"></span><span class="hs-comment">-- target context.</span><span>
</span><span id="line-71"></span><span class="hs-comment">--</span><span>
</span><span id="line-72"></span><span class="hs-comment">-- Note that this type and its instances equivalent to</span><span>
</span><span id="line-73"></span><span class="hs-comment">-- @'Control.Comonad.Trans.Env.EnvT' ('Data.Semigroup.Sum' 'Natural')@.</span><span>
</span><span id="line-74"></span><span id="local-6989586621679479749"><span id="local-6989586621679479750"></span></span><span class="hs-keyword">data</span><span> </span><span id="Step"><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-var">Step</span></a></span></span><span> </span><span id="local-6989586621679480458"><span class="annot"><a href="#local-6989586621679480458"><span class="hs-identifier hs-type">f</span></a></span></span><span> </span><span id="local-6989586621679480457"><span class="annot"><a href="#local-6989586621679480457"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="Step"><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-var">Step</span></a></span></span><span> </span><span class="hs-special">{</span><span> </span><span id="stepPos"><span class="annot"><span class="annottext">Step f a -&gt; Natural
</span><a href="Control.Applicative.Step.html#stepPos"><span class="hs-identifier hs-var hs-var">stepPos</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Natural</span></span><span class="hs-special">,</span><span> </span><span id="stepVal"><span class="annot"><span class="annottext">Step f a -&gt; f a
</span><a href="Control.Applicative.Step.html#stepVal"><span class="hs-identifier hs-var hs-var">stepVal</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621679480458"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679480457"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-75"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679479740"><span id="local-6989586621679479742"><span id="local-6989586621679479744"><span class="annot"><span class="annottext">Int -&gt; Step f a -&gt; ShowS
[Step f a] -&gt; ShowS
Step f a -&gt; String
(Int -&gt; Step f a -&gt; ShowS)
-&gt; (Step f a -&gt; String) -&gt; ([Step f a] -&gt; ShowS) -&gt; Show (Step f a)
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
forall k (f :: k -&gt; *) (a :: k).
Show (f a) =&gt;
Int -&gt; Step f a -&gt; ShowS
forall k (f :: k -&gt; *) (a :: k). Show (f a) =&gt; [Step f a] -&gt; ShowS
forall k (f :: k -&gt; *) (a :: k). Show (f a) =&gt; Step f a -&gt; String
showList :: [Step f a] -&gt; ShowS
$cshowList :: forall k (f :: k -&gt; *) (a :: k). Show (f a) =&gt; [Step f a] -&gt; ShowS
show :: Step f a -&gt; String
$cshow :: forall k (f :: k -&gt; *) (a :: k). Show (f a) =&gt; Step f a -&gt; String
showsPrec :: Int -&gt; Step f a -&gt; ShowS
$cshowsPrec :: forall k (f :: k -&gt; *) (a :: k).
Show (f a) =&gt;
Int -&gt; Step f a -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679479731"><span id="local-6989586621679479733"><span id="local-6989586621679479735"><span id="local-6989586621679479737"><span class="annot"><span class="annottext">ReadPrec [Step f a]
ReadPrec (Step f a)
Int -&gt; ReadS (Step f a)
ReadS [Step f a]
(Int -&gt; ReadS (Step f a))
-&gt; ReadS [Step f a]
-&gt; ReadPrec (Step f a)
-&gt; ReadPrec [Step f a]
-&gt; Read (Step f a)
forall a.
(Int -&gt; ReadS a)
-&gt; ReadS [a] -&gt; ReadPrec a -&gt; ReadPrec [a] -&gt; Read a
forall k (f :: k -&gt; *) (a :: k). Read (f a) =&gt; ReadPrec [Step f a]
forall k (f :: k -&gt; *) (a :: k). Read (f a) =&gt; ReadPrec (Step f a)
forall k (f :: k -&gt; *) (a :: k).
Read (f a) =&gt;
Int -&gt; ReadS (Step f a)
forall k (f :: k -&gt; *) (a :: k). Read (f a) =&gt; ReadS [Step f a]
readListPrec :: ReadPrec [Step f a]
$creadListPrec :: forall k (f :: k -&gt; *) (a :: k). Read (f a) =&gt; ReadPrec [Step f a]
readPrec :: ReadPrec (Step f a)
$creadPrec :: forall k (f :: k -&gt; *) (a :: k). Read (f a) =&gt; ReadPrec (Step f a)
readList :: ReadS [Step f a]
$creadList :: forall k (f :: k -&gt; *) (a :: k). Read (f a) =&gt; ReadS [Step f a]
readsPrec :: Int -&gt; ReadS (Step f a)
$creadsPrec :: forall k (f :: k -&gt; *) (a :: k).
Read (f a) =&gt;
Int -&gt; ReadS (Step f a)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Read</span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679479726"><span id="local-6989586621679479728"><span class="annot"><span class="annottext">Step f a -&gt; Step f a -&gt; Bool
(Step f a -&gt; Step f a -&gt; Bool)
-&gt; (Step f a -&gt; Step f a -&gt; Bool) -&gt; Eq (Step f a)
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
forall k (f :: k -&gt; *) (a :: k).
Eq (f a) =&gt;
Step f a -&gt; Step f a -&gt; Bool
/= :: Step f a -&gt; Step f a -&gt; Bool
$c/= :: forall k (f :: k -&gt; *) (a :: k).
Eq (f a) =&gt;
Step f a -&gt; Step f a -&gt; Bool
== :: Step f a -&gt; Step f a -&gt; Bool
$c== :: forall k (f :: k -&gt; *) (a :: k).
Eq (f a) =&gt;
Step f a -&gt; Step f a -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679479710"><span id="local-6989586621679479712"><span id="local-6989586621679479714"><span id="local-6989586621679479716"><span id="local-6989586621679479718"><span id="local-6989586621679479720"><span id="local-6989586621679479722"><span class="annot"><span class="annottext">Eq (Step f a)
Eq (Step f a) =&gt;
(Step f a -&gt; Step f a -&gt; Ordering)
-&gt; (Step f a -&gt; Step f a -&gt; Bool)
-&gt; (Step f a -&gt; Step f a -&gt; Bool)
-&gt; (Step f a -&gt; Step f a -&gt; Bool)
-&gt; (Step f a -&gt; Step f a -&gt; Bool)
-&gt; (Step f a -&gt; Step f a -&gt; Step f a)
-&gt; (Step f a -&gt; Step f a -&gt; Step f a)
-&gt; Ord (Step f a)
Step f a -&gt; Step f a -&gt; Bool
Step f a -&gt; Step f a -&gt; Ordering
Step f a -&gt; Step f a -&gt; Step f a
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall k (f :: k -&gt; *) (a :: k). Ord (f a) =&gt; Eq (Step f a)
forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Step f a -&gt; Step f a -&gt; Bool
forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Step f a -&gt; Step f a -&gt; Ordering
forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Step f a -&gt; Step f a -&gt; Step f a
min :: Step f a -&gt; Step f a -&gt; Step f a
$cmin :: forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Step f a -&gt; Step f a -&gt; Step f a
max :: Step f a -&gt; Step f a -&gt; Step f a
$cmax :: forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Step f a -&gt; Step f a -&gt; Step f a
&gt;= :: Step f a -&gt; Step f a -&gt; Bool
$c&gt;= :: forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Step f a -&gt; Step f a -&gt; Bool
&gt; :: Step f a -&gt; Step f a -&gt; Bool
$c&gt; :: forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Step f a -&gt; Step f a -&gt; Bool
&lt;= :: Step f a -&gt; Step f a -&gt; Bool
$c&lt;= :: forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Step f a -&gt; Step f a -&gt; Bool
&lt; :: Step f a -&gt; Step f a -&gt; Bool
$c&lt; :: forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Step f a -&gt; Step f a -&gt; Bool
compare :: Step f a -&gt; Step f a -&gt; Ordering
$ccompare :: forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Step f a -&gt; Step f a -&gt; Ordering
$cp1Ord :: forall k (f :: k -&gt; *) (a :: k). Ord (f a) =&gt; Eq (Step f a)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679479705"><span id="local-6989586621679479707"><span class="annot"><span class="annottext">a -&gt; Step f b -&gt; Step f a
(a -&gt; b) -&gt; Step f a -&gt; Step f b
(forall a b. (a -&gt; b) -&gt; Step f a -&gt; Step f b)
-&gt; (forall a b. a -&gt; Step f b -&gt; Step f a) -&gt; Functor (Step f)
forall a b. a -&gt; Step f b -&gt; Step f a
forall a b. (a -&gt; b) -&gt; Step f a -&gt; Step f b
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; Step f b -&gt; Step f a
forall (f :: * -&gt; *) a b.
Functor f =&gt;
(a -&gt; b) -&gt; Step f a -&gt; Step f b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: a -&gt; Step f b -&gt; Step f a
$c&lt;$ :: forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; Step f b -&gt; Step f a
fmap :: (a -&gt; b) -&gt; Step f a -&gt; Step f b
$cfmap :: forall (f :: * -&gt; *) a b.
Functor f =&gt;
(a -&gt; b) -&gt; Step f a -&gt; Step f b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679479670"><span id="local-6989586621679479672"><span id="local-6989586621679479674"><span id="local-6989586621679479676"><span id="local-6989586621679479678"><span id="local-6989586621679479680"><span id="local-6989586621679479682"><span id="local-6989586621679479684"><span id="local-6989586621679479686"><span id="local-6989586621679479688"><span id="local-6989586621679479690"><span id="local-6989586621679479692"><span id="local-6989586621679479694"><span id="local-6989586621679479696"><span id="local-6989586621679479698"><span id="local-6989586621679479700"><span id="local-6989586621679479702"><span class="annot"><span class="annottext">Step f a -&gt; Bool
(a -&gt; m) -&gt; Step f a -&gt; m
(a -&gt; b -&gt; b) -&gt; b -&gt; Step f a -&gt; b
(forall m. Monoid m =&gt; Step f m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Step f a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Step f a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Step f a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Step f a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Step f a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Step f a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; Step f a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; Step f a -&gt; a)
-&gt; (forall a. Step f a -&gt; [a])
-&gt; (forall a. Step f a -&gt; Bool)
-&gt; (forall a. Step f a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; Step f a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; Step f a -&gt; a)
-&gt; (forall a. Ord a =&gt; Step f a -&gt; a)
-&gt; (forall a. Num a =&gt; Step f a -&gt; a)
-&gt; (forall a. Num a =&gt; Step f a -&gt; a)
-&gt; Foldable (Step f)
forall a. Eq a =&gt; a -&gt; Step f a -&gt; Bool
forall a. Num a =&gt; Step f a -&gt; a
forall a. Ord a =&gt; Step f a -&gt; a
forall m. Monoid m =&gt; Step f m -&gt; m
forall a. Step f a -&gt; Bool
forall a. Step f a -&gt; Int
forall a. Step f a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; Step f a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Step f a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Step f a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Step f a -&gt; b
forall (f :: * -&gt; *) a. (Foldable f, Eq a) =&gt; a -&gt; Step f a -&gt; Bool
forall (f :: * -&gt; *) a. (Foldable f, Num a) =&gt; Step f a -&gt; a
forall (f :: * -&gt; *) a. (Foldable f, Ord a) =&gt; Step f a -&gt; a
forall (f :: * -&gt; *) m. (Foldable f, Monoid m) =&gt; Step f m -&gt; m
forall (f :: * -&gt; *) a. Foldable f =&gt; Step f a -&gt; Bool
forall (f :: * -&gt; *) a. Foldable f =&gt; Step f a -&gt; Int
forall (f :: * -&gt; *) a. Foldable f =&gt; Step f a -&gt; [a]
forall (f :: * -&gt; *) a.
Foldable f =&gt;
(a -&gt; a -&gt; a) -&gt; Step f a -&gt; a
forall (f :: * -&gt; *) m a.
(Foldable f, Monoid m) =&gt;
(a -&gt; m) -&gt; Step f a -&gt; m
forall (f :: * -&gt; *) b a.
Foldable f =&gt;
(b -&gt; a -&gt; b) -&gt; b -&gt; Step f a -&gt; b
forall (f :: * -&gt; *) a b.
Foldable f =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; Step f a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: Step f a -&gt; a
$cproduct :: forall (f :: * -&gt; *) a. (Foldable f, Num a) =&gt; Step f a -&gt; a
sum :: Step f a -&gt; a
$csum :: forall (f :: * -&gt; *) a. (Foldable f, Num a) =&gt; Step f a -&gt; a
minimum :: Step f a -&gt; a
$cminimum :: forall (f :: * -&gt; *) a. (Foldable f, Ord a) =&gt; Step f a -&gt; a
maximum :: Step f a -&gt; a
$cmaximum :: forall (f :: * -&gt; *) a. (Foldable f, Ord a) =&gt; Step f a -&gt; a
elem :: a -&gt; Step f a -&gt; Bool
$celem :: forall (f :: * -&gt; *) a. (Foldable f, Eq a) =&gt; a -&gt; Step f a -&gt; Bool
length :: Step f a -&gt; Int
$clength :: forall (f :: * -&gt; *) a. Foldable f =&gt; Step f a -&gt; Int
null :: Step f a -&gt; Bool
$cnull :: forall (f :: * -&gt; *) a. Foldable f =&gt; Step f a -&gt; Bool
toList :: Step f a -&gt; [a]
$ctoList :: forall (f :: * -&gt; *) a. Foldable f =&gt; Step f a -&gt; [a]
foldl1 :: (a -&gt; a -&gt; a) -&gt; Step f a -&gt; a
$cfoldl1 :: forall (f :: * -&gt; *) a.
Foldable f =&gt;
(a -&gt; a -&gt; a) -&gt; Step f a -&gt; a
foldr1 :: (a -&gt; a -&gt; a) -&gt; Step f a -&gt; a
$cfoldr1 :: forall (f :: * -&gt; *) a.
Foldable f =&gt;
(a -&gt; a -&gt; a) -&gt; Step f a -&gt; a
foldl' :: (b -&gt; a -&gt; b) -&gt; b -&gt; Step f a -&gt; b
$cfoldl' :: forall (f :: * -&gt; *) b a.
Foldable f =&gt;
(b -&gt; a -&gt; b) -&gt; b -&gt; Step f a -&gt; b
foldl :: (b -&gt; a -&gt; b) -&gt; b -&gt; Step f a -&gt; b
$cfoldl :: forall (f :: * -&gt; *) b a.
Foldable f =&gt;
(b -&gt; a -&gt; b) -&gt; b -&gt; Step f a -&gt; b
foldr' :: (a -&gt; b -&gt; b) -&gt; b -&gt; Step f a -&gt; b
$cfoldr' :: forall (f :: * -&gt; *) a b.
Foldable f =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; Step f a -&gt; b
foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; Step f a -&gt; b
$cfoldr :: forall (f :: * -&gt; *) a b.
Foldable f =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; Step f a -&gt; b
foldMap' :: (a -&gt; m) -&gt; Step f a -&gt; m
$cfoldMap' :: forall (f :: * -&gt; *) m a.
(Foldable f, Monoid m) =&gt;
(a -&gt; m) -&gt; Step f a -&gt; m
foldMap :: (a -&gt; m) -&gt; Step f a -&gt; m
$cfoldMap :: forall (f :: * -&gt; *) m a.
(Foldable f, Monoid m) =&gt;
(a -&gt; m) -&gt; Step f a -&gt; m
fold :: Step f m -&gt; m
$cfold :: forall (f :: * -&gt; *) m. (Foldable f, Monoid m) =&gt; Step f m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679479659"><span id="local-6989586621679479661"><span id="local-6989586621679479663"><span id="local-6989586621679479665"><span class="annot"><span class="annottext">Functor (Step f)
Foldable (Step f)
(Functor (Step f), Foldable (Step f)) =&gt;
(forall (f :: * -&gt; *) a b.
 Applicative f =&gt;
 (a -&gt; f b) -&gt; Step f a -&gt; f (Step f b))
-&gt; (forall (f :: * -&gt; *) a.
    Applicative f =&gt;
    Step f (f a) -&gt; f (Step f a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; Step f a -&gt; m (Step f b))
-&gt; (forall (m :: * -&gt; *) a.
    Monad m =&gt;
    Step f (m a) -&gt; m (Step f a))
-&gt; Traversable (Step f)
(a -&gt; f b) -&gt; Step f a -&gt; f (Step f b)
forall (t :: * -&gt; *).
(Functor t, Foldable t) =&gt;
(forall (f :: * -&gt; *) a b.
 Applicative f =&gt;
 (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (f :: * -&gt; *). Traversable f =&gt; Functor (Step f)
forall (f :: * -&gt; *). Traversable f =&gt; Foldable (Step f)
forall (f :: * -&gt; *) (m :: * -&gt; *) a.
(Traversable f, Monad m) =&gt;
Step f (m a) -&gt; m (Step f a)
forall (f :: * -&gt; *) (f :: * -&gt; *) a.
(Traversable f, Applicative f) =&gt;
Step f (f a) -&gt; f (Step f a)
forall (f :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable f, Monad m) =&gt;
(a -&gt; m b) -&gt; Step f a -&gt; m (Step f b)
forall (f :: * -&gt; *) (f :: * -&gt; *) a b.
(Traversable f, Applicative f) =&gt;
(a -&gt; f b) -&gt; Step f a -&gt; f (Step f b)
forall (m :: * -&gt; *) a. Monad m =&gt; Step f (m a) -&gt; m (Step f a)
forall (f :: * -&gt; *) a.
Applicative f =&gt;
Step f (f a) -&gt; f (Step f a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Step f a -&gt; m (Step f b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Step f a -&gt; f (Step f b)
sequence :: Step f (m a) -&gt; m (Step f a)
$csequence :: forall (f :: * -&gt; *) (m :: * -&gt; *) a.
(Traversable f, Monad m) =&gt;
Step f (m a) -&gt; m (Step f a)
mapM :: (a -&gt; m b) -&gt; Step f a -&gt; m (Step f b)
$cmapM :: forall (f :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable f, Monad m) =&gt;
(a -&gt; m b) -&gt; Step f a -&gt; m (Step f b)
sequenceA :: Step f (f a) -&gt; f (Step f a)
$csequenceA :: forall (f :: * -&gt; *) (f :: * -&gt; *) a.
(Traversable f, Applicative f) =&gt;
Step f (f a) -&gt; f (Step f a)
traverse :: (a -&gt; f b) -&gt; Step f a -&gt; f (Step f b)
$ctraverse :: forall (f :: * -&gt; *) (f :: * -&gt; *) a b.
(Traversable f, Applicative f) =&gt;
(a -&gt; f b) -&gt; Step f a -&gt; f (Step f b)
$cp2Traversable :: forall (f :: * -&gt; *). Traversable f =&gt; Foldable (Step f)
$cp1Traversable :: forall (f :: * -&gt; *). Traversable f =&gt; Functor (Step f)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">(forall x. Step f a -&gt; Rep (Step f a) x)
-&gt; (forall x. Rep (Step f a) x -&gt; Step f a) -&gt; Generic (Step f a)
forall x. Rep (Step f a) x -&gt; Step f a
forall x. Step f a -&gt; Rep (Step f a) x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall k (f :: k -&gt; *) (a :: k) x. Rep (Step f a) x -&gt; Step f a
forall k (f :: k -&gt; *) (a :: k) x. Step f a -&gt; Rep (Step f a) x
$cto :: forall k (f :: k -&gt; *) (a :: k) x. Rep (Step f a) x -&gt; Step f a
$cfrom :: forall k (f :: k -&gt; *) (a :: k) x. Step f a -&gt; Rep (Step f a) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">,</span><span> </span><span id="%24cStep"><span id="%24tStep"><span id="local-6989586621679479626"><span id="local-6989586621679479628"><span id="local-6989586621679479630"><span id="local-6989586621679479632"><span id="local-6989586621679479634"><span id="local-6989586621679479636"><span id="local-6989586621679479638"><span id="local-6989586621679479640"><span id="local-6989586621679479642"><span id="local-6989586621679479644"><span id="local-6989586621679479646"><span id="local-6989586621679479648"><span id="local-6989586621679479650"><span id="local-6989586621679479652"><span class="annot"><span class="annottext">Typeable (Step f a)
DataType
Constr
Typeable (Step f a) =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; Step f a -&gt; c (Step f a))
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Step f a))
-&gt; (Step f a -&gt; Constr)
-&gt; (Step f a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Step f a)))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e))
    -&gt; Maybe (c (Step f a)))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; Step f a -&gt; Step f a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Step f a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Step f a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Step f a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Step f a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Step f a -&gt; m (Step f a))
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Step f a -&gt; m (Step f a))
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Step f a -&gt; m (Step f a))
-&gt; Data (Step f a)
Step f a -&gt; DataType
Step f a -&gt; Constr
(forall b. Data b =&gt; b -&gt; b) -&gt; Step f a -&gt; Step f a
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Step f a -&gt; c (Step f a)
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Step f a)
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Step f a -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Step f a -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Step f a -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Step f a -&gt; r
forall k (f :: k -&gt; *) (a :: k).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
Typeable (Step f a)
forall k (f :: k -&gt; *) (a :: k).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
Step f a -&gt; DataType
forall k (f :: k -&gt; *) (a :: k).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
Step f a -&gt; Constr
forall k (f :: k -&gt; *) (a :: k).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Step f a -&gt; Step f a
forall k (f :: k -&gt; *) (a :: k) u.
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Step f a -&gt; u
forall k (f :: k -&gt; *) (a :: k) u.
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; Step f a -&gt; [u]
forall k (f :: k -&gt; *) (a :: k) r r'.
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Step f a -&gt; r
forall k (f :: k -&gt; *) (a :: k) r r'.
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Step f a -&gt; r
forall k (f :: k -&gt; *) (a :: k) (m :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Step f a -&gt; m (Step f a)
forall k (f :: k -&gt; *) (a :: k) (m :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Step f a -&gt; m (Step f a)
forall k (f :: k -&gt; *) (a :: k) (c :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Step f a)
forall k (f :: k -&gt; *) (a :: k) (c :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Step f a -&gt; c (Step f a)
forall k (f :: k -&gt; *) (a :: k) (t :: * -&gt; *) (c :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Step f a))
forall k (f :: k -&gt; *) (a :: k) (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (Step f a))
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Step f a -&gt; m (Step f a)
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Step f a -&gt; m (Step f a)
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Step f a)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Step f a -&gt; c (Step f a)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Step f a))
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (Step f a))
$cStep :: Constr
$tStep :: DataType
gmapMo :: (forall d. Data d =&gt; d -&gt; m d) -&gt; Step f a -&gt; m (Step f a)
$cgmapMo :: forall k (f :: k -&gt; *) (a :: k) (m :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Step f a -&gt; m (Step f a)
gmapMp :: (forall d. Data d =&gt; d -&gt; m d) -&gt; Step f a -&gt; m (Step f a)
$cgmapMp :: forall k (f :: k -&gt; *) (a :: k) (m :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Step f a -&gt; m (Step f a)
gmapM :: (forall d. Data d =&gt; d -&gt; m d) -&gt; Step f a -&gt; m (Step f a)
$cgmapM :: forall k (f :: k -&gt; *) (a :: k) (m :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Step f a -&gt; m (Step f a)
gmapQi :: Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Step f a -&gt; u
$cgmapQi :: forall k (f :: k -&gt; *) (a :: k) u.
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Step f a -&gt; u
gmapQ :: (forall d. Data d =&gt; d -&gt; u) -&gt; Step f a -&gt; [u]
$cgmapQ :: forall k (f :: k -&gt; *) (a :: k) u.
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; Step f a -&gt; [u]
gmapQr :: (r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Step f a -&gt; r
$cgmapQr :: forall k (f :: k -&gt; *) (a :: k) r r'.
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Step f a -&gt; r
gmapQl :: (r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Step f a -&gt; r
$cgmapQl :: forall k (f :: k -&gt; *) (a :: k) r r'.
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Step f a -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Step f a -&gt; Step f a
$cgmapT :: forall k (f :: k -&gt; *) (a :: k).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Step f a -&gt; Step f a
dataCast2 :: (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (Step f a))
$cdataCast2 :: forall k (f :: k -&gt; *) (a :: k) (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (Step f a))
dataCast1 :: (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Step f a))
$cdataCast1 :: forall k (f :: k -&gt; *) (a :: k) (t :: * -&gt; *) (c :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Step f a))
dataTypeOf :: Step f a -&gt; DataType
$cdataTypeOf :: forall k (f :: k -&gt; *) (a :: k).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
Step f a -&gt; DataType
toConstr :: Step f a -&gt; Constr
$ctoConstr :: forall k (f :: k -&gt; *) (a :: k).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
Step f a -&gt; Constr
gunfold :: (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Step f a)
$cgunfold :: forall k (f :: k -&gt; *) (a :: k) (c :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Step f a)
gfoldl :: (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Step f a -&gt; c (Step f a)
$cgfoldl :: forall k (f :: k -&gt; *) (a :: k) (c :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Step f a -&gt; c (Step f a)
$cp1Data :: forall k (f :: k -&gt; *) (a :: k).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
Typeable (Step f a)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-76"></span><span>
</span><span id="line-77"></span><span id="local-6989586621679479619"><span id="local-6989586621679479621"><span id="local-6989586621679480458"><span class="hs-identifier">deriveShow1</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Step</span></span></span></span><span>
</span><span id="line-78"></span><span id="local-6989586621679479609"><span id="local-6989586621679479611"><span id="local-6989586621679479613"><span id="local-6989586621679479615"><span id="local-6989586621679480458"><span class="hs-identifier">deriveRead1</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Step</span></span></span></span></span></span><span>
</span><span id="line-79"></span><span id="local-6989586621679479604"><span id="local-6989586621679480458"><span class="hs-identifier">deriveEq1</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Step</span></span></span><span>
</span><span id="line-80"></span><span id="local-6989586621679479599"><span id="local-6989586621679480458"><span class="hs-identifier">deriveOrd1</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Step</span></span></span><span>
</span><span id="line-81"></span><span>
</span><span id="line-82"></span><span id="local-6989586621679479596"><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679479587"><span id="local-6989586621679479589"><span id="local-6989586621679479591"><span class="annot"><span class="hs-identifier hs-type">Applicative</span></span><span> </span><span class="annot"><a href="#local-6989586621679479596"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Applicative</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-type">Step</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679479596"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-83"></span><span>    </span><span id="local-6989586621679479585"><span class="annot"><span class="annottext">pure :: a -&gt; Step f a
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">pure</span></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Natural -&gt; f a -&gt; Step f a
forall k (f :: k -&gt; *) (a :: k). Natural -&gt; f a -&gt; Step f a
</span><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-var">Step</span></a></span><span> </span><span class="annot"><span class="hs-number">0</span></span><span> </span><span class="annot"><span class="annottext">(f a -&gt; Step f a) -&gt; (a -&gt; f a) -&gt; a -&gt; Step f a
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; f a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span>
</span><span id="line-84"></span><span>    </span><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-type">Step</span></a></span><span> </span><span id="local-6989586621679479583"><span class="annot"><span class="annottext">n :: Natural
</span><a href="#local-6989586621679479583"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679479582"><span class="annot"><span class="annottext">f :: f (a -&gt; b)
</span><a href="#local-6989586621679479582"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679479581"><span class="annot"><span class="annottext">&lt;*&gt; :: Step f (a -&gt; b) -&gt; Step f a -&gt; Step f b
</span><span class="hs-operator hs-var hs-var hs-var hs-var">&lt;*&gt;</span></span></span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-type">Step</span></a></span><span> </span><span id="local-6989586621679479580"><span class="annot"><span class="annottext">m :: Natural
</span><a href="#local-6989586621679479580"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span id="local-6989586621679479579"><span class="annot"><span class="annottext">x :: f a
</span><a href="#local-6989586621679479579"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Natural -&gt; f b -&gt; Step f b
forall k (f :: k -&gt; *) (a :: k). Natural -&gt; f a -&gt; Step f a
</span><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-var">Step</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Natural
</span><a href="#local-6989586621679479583"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Natural -&gt; Natural -&gt; Natural
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">+</span></span><span> </span><span class="annot"><span class="annottext">Natural
</span><a href="#local-6989586621679479580"><span class="hs-identifier hs-var">m</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">f (a -&gt; b)
</span><a href="#local-6989586621679479582"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">f (a -&gt; b) -&gt; f a -&gt; f b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">f a
</span><a href="#local-6989586621679479579"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-85"></span><span>
</span><span id="line-86"></span><span id="local-6989586621679479577"><span class="hs-keyword">instance</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Pointed</span></span><span> </span><span class="annot"><a href="#local-6989586621679479577"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Pointed</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-type">Step</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679479577"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-87"></span><span>    </span><span id="local-6989586621679479574"><span class="annot"><span class="annottext">point :: a -&gt; Step f a
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">point</span></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Natural -&gt; f a -&gt; Step f a
forall k (f :: k -&gt; *) (a :: k). Natural -&gt; f a -&gt; Step f a
</span><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-var">Step</span></a></span><span> </span><span class="annot"><span class="hs-number">0</span></span><span> </span><span class="annot"><span class="annottext">(f a -&gt; Step f a) -&gt; (a -&gt; f a) -&gt; a -&gt; Step f a
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; f a
forall (p :: * -&gt; *) a. Pointed p =&gt; a -&gt; p a
</span><span class="hs-identifier hs-var">point</span></span></span><span>
</span><span id="line-88"></span><span>
</span><span id="line-89"></span><span id="local-6989586621679479572"><span class="hs-keyword">instance</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Foldable1</span></span><span> </span><span class="annot"><a href="#local-6989586621679479572"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Foldable1</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-type">Step</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679479572"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-90"></span><span>    </span><span id="local-6989586621679479566"><span class="annot"><span class="annottext">fold1 :: Step f m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">fold1</span></span></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">f m -&gt; m
forall (t :: * -&gt; *) m. (Foldable1 t, Semigroup m) =&gt; t m -&gt; m
</span><span class="hs-identifier hs-var">fold1</span></span><span> </span><span class="annot"><span class="annottext">(f m -&gt; m) -&gt; (Step f m -&gt; f m) -&gt; Step f m -&gt; m
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Step f m -&gt; f m
forall k (f :: k -&gt; *) (a :: k). Step f a -&gt; f a
</span><a href="Control.Applicative.Step.html#stepVal"><span class="hs-identifier hs-var hs-var">stepVal</span></a></span><span>
</span><span id="line-91"></span><span>    </span><span id="local-6989586621679479564"><span class="annot"><span class="annottext">foldMap1 :: (a -&gt; m) -&gt; Step f a -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">foldMap1</span></span></span><span> </span><span id="local-6989586621679479562"><span class="annot"><span class="annottext">f :: a -&gt; m
</span><a href="#local-6989586621679479562"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; m) -&gt; f a -&gt; m
forall (t :: * -&gt; *) m a.
(Foldable1 t, Semigroup m) =&gt;
(a -&gt; m) -&gt; t a -&gt; m
</span><span class="hs-identifier hs-var">foldMap1</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; m
</span><a href="#local-6989586621679479562"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">(f a -&gt; m) -&gt; (Step f a -&gt; f a) -&gt; Step f a -&gt; m
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Step f a -&gt; f a
forall k (f :: k -&gt; *) (a :: k). Step f a -&gt; f a
</span><a href="Control.Applicative.Step.html#stepVal"><span class="hs-identifier hs-var hs-var">stepVal</span></a></span><span>
</span><span id="line-92"></span><span>    </span><span id="local-6989586621679479561"><span class="annot"><span class="annottext">toNonEmpty :: Step f a -&gt; NonEmpty a
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">toNonEmpty</span></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">f a -&gt; NonEmpty a
forall (t :: * -&gt; *) a. Foldable1 t =&gt; t a -&gt; NonEmpty a
</span><span class="hs-identifier hs-var">toNonEmpty</span></span><span> </span><span class="annot"><span class="annottext">(f a -&gt; NonEmpty a) -&gt; (Step f a -&gt; f a) -&gt; Step f a -&gt; NonEmpty a
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Step f a -&gt; f a
forall k (f :: k -&gt; *) (a :: k). Step f a -&gt; f a
</span><a href="Control.Applicative.Step.html#stepVal"><span class="hs-identifier hs-var hs-var">stepVal</span></a></span></span><span>
</span><span id="line-93"></span><span>
</span><span id="line-94"></span><span id="local-6989586621679479559"><span class="hs-keyword">instance</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Traversable1</span></span><span> </span><span class="annot"><a href="#local-6989586621679479559"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Traversable1</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-type">Step</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679479559"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-95"></span><span>    </span><span id="local-6989586621679479553"><span class="annot"><span class="annottext">traverse1 :: (a -&gt; f b) -&gt; Step f a -&gt; f (Step f b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">traverse1</span></span></span><span> </span><span id="local-6989586621679479551"><span class="annot"><span class="annottext">f :: a -&gt; f b
</span><a href="#local-6989586621679479551"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-type">Step</span></a></span><span> </span><span id="local-6989586621679479550"><span class="annot"><span class="annottext">n :: Natural
</span><a href="#local-6989586621679479550"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679479549"><span class="annot"><span class="annottext">x :: f a
</span><a href="#local-6989586621679479549"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Natural -&gt; f b -&gt; Step f b
forall k (f :: k -&gt; *) (a :: k). Natural -&gt; f a -&gt; Step f a
</span><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-var">Step</span></a></span><span> </span><span class="annot"><span class="annottext">Natural
</span><a href="#local-6989586621679479550"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">(f b -&gt; Step f b) -&gt; f (f b) -&gt; f (Step f b)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">(a -&gt; f b) -&gt; f a -&gt; f (f b)
forall (t :: * -&gt; *) (f :: * -&gt; *) a b.
(Traversable1 t, Apply f) =&gt;
(a -&gt; f b) -&gt; t a -&gt; f (t b)
</span><span class="hs-identifier hs-var">traverse1</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; f b
</span><a href="#local-6989586621679479551"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">f a
</span><a href="#local-6989586621679479549"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-96"></span><span>    </span><span id="local-6989586621679479547"><span class="annot"><span class="annottext">sequence1 :: Step f (f b) -&gt; f (Step f b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">sequence1</span></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-type">Step</span></a></span><span> </span><span id="local-6989586621679479545"><span class="annot"><span class="annottext">n :: Natural
</span><a href="#local-6989586621679479545"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679479544"><span class="annot"><span class="annottext">x :: f (f b)
</span><a href="#local-6989586621679479544"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Natural -&gt; f b -&gt; Step f b
forall k (f :: k -&gt; *) (a :: k). Natural -&gt; f a -&gt; Step f a
</span><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-var">Step</span></a></span><span> </span><span class="annot"><span class="annottext">Natural
</span><a href="#local-6989586621679479545"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">(f b -&gt; Step f b) -&gt; f (f b) -&gt; f (Step f b)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">f (f b) -&gt; f (f b)
forall (t :: * -&gt; *) (f :: * -&gt; *) b.
(Traversable1 t, Apply f) =&gt;
t (f b) -&gt; f (t b)
</span><span class="hs-identifier hs-var">sequence1</span></span><span> </span><span class="annot"><span class="annottext">f (f b)
</span><a href="#local-6989586621679479544"><span class="hs-identifier hs-var">x</span></a></span></span><span>
</span><span id="line-97"></span><span>
</span><span id="line-98"></span><span class="hs-comment">-- | &quot;Uncons and cons&quot; an @f@ branch before a 'Step'.  This is basically</span><span>
</span><span id="line-99"></span><span class="hs-comment">-- a witness that 'stepDown' and 'stepUp' form an isomorphism.</span><span>
</span><span id="line-100"></span><span id="local-6989586621679479543"><span class="annot"><a href="Control.Applicative.Step.html#stepping"><span class="hs-identifier hs-type">stepping</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-type">Step</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679479543"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="Control.Natural.IsoF.html#%3C~%3E"><span class="hs-operator hs-type">&lt;~&gt;</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679479543"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">:+:</span></span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-type">Step</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679479543"><span class="hs-identifier hs-type">f</span></a></span></span><span>
</span><span id="line-101"></span><span id="stepping"><span class="annot"><span class="annottext">stepping :: p ((:+:) f (Step f) a) ((:+:) f (Step f) a)
-&gt; p (Step f a) (Step f a)
</span><a href="Control.Applicative.Step.html#stepping"><span class="hs-identifier hs-var hs-var">stepping</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Step f ~&gt; (f :+: Step f))
-&gt; ((f :+: Step f) ~&gt; Step f) -&gt; Step f &lt;~&gt; (f :+: Step f)
forall k (f :: k -&gt; *) (g :: k -&gt; *).
(f ~&gt; g) -&gt; (g ~&gt; f) -&gt; f &lt;~&gt; g
</span><a href="Control.Natural.IsoF.html#isoF"><span class="hs-identifier hs-var">isoF</span></a></span><span> </span><span class="annot"><span class="annottext">Step f ~&gt; (f :+: Step f)
forall k (f :: k -&gt; *). Step f ~&gt; (f :+: Step f)
</span><a href="Control.Applicative.Step.html#stepDown"><span class="hs-identifier hs-var">stepDown</span></a></span><span> </span><span class="annot"><span class="annottext">(f :+: Step f) ~&gt; Step f
forall k (f :: k -&gt; *). (f :+: Step f) ~&gt; Step f
</span><a href="Control.Applicative.Step.html#stepUp"><span class="hs-identifier hs-var">stepUp</span></a></span><span>
</span><span id="line-102"></span><span>
</span><span id="line-103"></span><span class="hs-comment">-- | Pop off the first item in a 'Step'.  Because a @'Step' f@ is @f :+:</span><span>
</span><span id="line-104"></span><span class="hs-comment">-- f :+: f :+: ...@ forever, this matches on the first branch.</span><span>
</span><span id="line-105"></span><span class="hs-comment">--</span><span>
</span><span id="line-106"></span><span class="hs-comment">-- You can think of it as reassociating</span><span>
</span><span id="line-107"></span><span class="hs-comment">--</span><span>
</span><span id="line-108"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-109"></span><span class="hs-comment">-- f :+: f :+: f :+: f :+: ...</span><span>
</span><span id="line-110"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-111"></span><span class="hs-comment">--</span><span>
</span><span id="line-112"></span><span class="hs-comment">-- into</span><span>
</span><span id="line-113"></span><span class="hs-comment">--</span><span>
</span><span id="line-114"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-115"></span><span class="hs-comment">-- f :+: ( f :+: f :+: f :+: ...)</span><span>
</span><span id="line-116"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-117"></span><span class="hs-comment">--</span><span>
</span><span id="line-118"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-119"></span><span class="hs-comment">-- 'stepDown' ('Step' 2 &quot;hello&quot;)</span><span>
</span><span id="line-120"></span><span class="hs-comment">-- -- 'R1' (Step 1 &quot;hello&quot;)</span><span>
</span><span id="line-121"></span><span class="hs-comment">-- stepDown (Step 0 &quot;hello&quot;)</span><span>
</span><span id="line-122"></span><span class="hs-comment">-- -- 'L1' &quot;hello&quot;</span><span>
</span><span id="line-123"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-124"></span><span class="hs-comment">--</span><span>
</span><span id="line-125"></span><span class="hs-comment">-- Forms an isomorphism with 'stepUp' (see 'stepping').</span><span>
</span><span id="line-126"></span><span id="local-6989586621679480406"><span class="annot"><a href="Control.Applicative.Step.html#stepDown"><span class="hs-identifier hs-type">stepDown</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-type">Step</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679480406"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">~&gt;</span></span><span> </span><span class="annot"><a href="#local-6989586621679480406"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">:+:</span></span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-type">Step</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679480406"><span class="hs-identifier hs-type">f</span></a></span></span><span>
</span><span id="line-127"></span><span id="stepDown"><span class="annot"><span class="annottext">stepDown :: Step f x -&gt; (:+:) f (Step f) x
</span><a href="Control.Applicative.Step.html#stepDown"><span class="hs-identifier hs-var hs-var">stepDown</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-type">Step</span></a></span><span> </span><span id="local-6989586621679479541"><span class="annot"><span class="annottext">n :: Natural
</span><a href="#local-6989586621679479541"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679479540"><span class="annot"><span class="annottext">x :: f x
</span><a href="#local-6989586621679479540"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Natural -&gt; Natural -&gt; Maybe Natural
</span><span class="hs-identifier hs-var">minusNaturalMaybe</span></span><span> </span><span class="annot"><span class="annottext">Natural
</span><a href="#local-6989586621679479541"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="hs-number">1</span></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-128"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">Nothing</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">f x -&gt; (:+:) f (Step f) x
forall k (f :: k -&gt; *) (g :: k -&gt; *) (p :: k). f p -&gt; (:+:) f g p
</span><span class="hs-identifier hs-var">L1</span></span><span> </span><span class="annot"><span class="annottext">f x
</span><a href="#local-6989586621679479540"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-129"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621679479537"><span class="annot"><span class="annottext">m :: Natural
</span><a href="#local-6989586621679479537"><span class="hs-identifier hs-var">m</span></a></span></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Step f x -&gt; (:+:) f (Step f) x
forall k (f :: k -&gt; *) (g :: k -&gt; *) (p :: k). g p -&gt; (:+:) f g p
</span><span class="hs-identifier hs-var">R1</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Natural -&gt; f x -&gt; Step f x
forall k (f :: k -&gt; *) (a :: k). Natural -&gt; f a -&gt; Step f a
</span><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-var">Step</span></a></span><span> </span><span class="annot"><span class="annottext">Natural
</span><a href="#local-6989586621679479537"><span class="hs-identifier hs-var">m</span></a></span><span> </span><span class="annot"><span class="annottext">f x
</span><a href="#local-6989586621679479540"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-130"></span><span>
</span><span id="line-131"></span><span class="hs-comment">-- | Unshift an item into a 'Step'.  Because a @'Step' f@ is @f :+: f :+:</span><span>
</span><span id="line-132"></span><span class="hs-comment">-- f :+: f :+: ...@ forever, this basically conses an additional</span><span>
</span><span id="line-133"></span><span class="hs-comment">-- possibility of @f@ to the beginning of it all.</span><span>
</span><span id="line-134"></span><span class="hs-comment">--</span><span>
</span><span id="line-135"></span><span class="hs-comment">-- You can think of it as reassociating</span><span>
</span><span id="line-136"></span><span class="hs-comment">--</span><span>
</span><span id="line-137"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-138"></span><span class="hs-comment">-- f :+: ( f :+: f :+: f :+: ...)</span><span>
</span><span id="line-139"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-140"></span><span class="hs-comment">--</span><span>
</span><span id="line-141"></span><span class="hs-comment">-- into</span><span>
</span><span id="line-142"></span><span class="hs-comment">--</span><span>
</span><span id="line-143"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-144"></span><span class="hs-comment">-- f :+: f :+: f :+: f :+: ...</span><span>
</span><span id="line-145"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-146"></span><span class="hs-comment">--</span><span>
</span><span id="line-147"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-148"></span><span class="hs-comment">-- 'stepUp' ('L1' &quot;hello&quot;)</span><span>
</span><span id="line-149"></span><span class="hs-comment">-- -- 'Step' 0 &quot;hello&quot;</span><span>
</span><span id="line-150"></span><span class="hs-comment">-- stepUp ('R1' (Step 1 &quot;hello&quot;))</span><span>
</span><span id="line-151"></span><span class="hs-comment">-- -- Step 2 &quot;hello&quot;</span><span>
</span><span id="line-152"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-153"></span><span class="hs-comment">--</span><span>
</span><span id="line-154"></span><span class="hs-comment">-- Forms an isomorphism with 'stepDown' (see 'stepping').</span><span>
</span><span id="line-155"></span><span id="local-6989586621679480404"><span class="annot"><a href="Control.Applicative.Step.html#stepUp"><span class="hs-identifier hs-type">stepUp</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621679480404"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">:+:</span></span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-type">Step</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679480404"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">~&gt;</span></span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-type">Step</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679480404"><span class="hs-identifier hs-type">f</span></a></span></span><span>
</span><span id="line-156"></span><span id="stepUp"><span class="annot"><span class="annottext">stepUp :: (:+:) f (Step f) x -&gt; Step f x
</span><a href="Control.Applicative.Step.html#stepUp"><span class="hs-identifier hs-var hs-var">stepUp</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-157"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">L1</span></span><span> </span><span id="local-6989586621679479535"><span class="annot"><span class="annottext">x :: f x
</span><a href="#local-6989586621679479535"><span class="hs-identifier hs-var">x</span></a></span></span><span>          </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Natural -&gt; f x -&gt; Step f x
forall k (f :: k -&gt; *) (a :: k). Natural -&gt; f a -&gt; Step f a
</span><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-var">Step</span></a></span><span> </span><span class="annot"><span class="hs-number">0</span></span><span>       </span><span class="annot"><span class="annottext">f x
</span><a href="#local-6989586621679479535"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-158"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">R1</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-type">Step</span></a></span><span> </span><span id="local-6989586621679479534"><span class="annot"><span class="annottext">n :: Natural
</span><a href="#local-6989586621679479534"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679479533"><span class="annot"><span class="annottext">y :: f x
</span><a href="#local-6989586621679479533"><span class="hs-identifier hs-var">y</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Natural -&gt; f x -&gt; Step f x
forall k (f :: k -&gt; *) (a :: k). Natural -&gt; f a -&gt; Step f a
</span><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-var">Step</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Natural
</span><a href="#local-6989586621679479534"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Natural -&gt; Natural -&gt; Natural
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">+</span></span><span> </span><span class="annot"><span class="hs-number">1</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">f x
</span><a href="#local-6989586621679479533"><span class="hs-identifier hs-var">y</span></a></span><span>
</span><span id="line-159"></span><span>
</span><span id="line-160"></span><span class="hs-comment">-- | We have a natural transformation between 'V1' and any other</span><span>
</span><span id="line-161"></span><span class="hs-comment">-- functor @f@ with no constraints.</span><span>
</span><span id="line-162"></span><span id="local-6989586621679479531"><span id="local-6989586621679479532"><span class="annot"><a href="Control.Applicative.Step.html#absurd1"><span class="hs-identifier hs-type">absurd1</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">V1</span></span><span> </span><span class="annot"><a href="#local-6989586621679479532"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679479531"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679479532"><span class="hs-identifier hs-type">a</span></a></span></span></span><span>
</span><span id="line-163"></span><span id="absurd1"><span class="annot"><span class="annottext">absurd1 :: V1 a -&gt; f a
</span><a href="Control.Applicative.Step.html#absurd1"><span class="hs-identifier hs-var hs-var">absurd1</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span>
</span><span id="line-164"></span><span>
</span><span id="line-165"></span><span class="hs-comment">-- | A non-empty map of 'Natural' to @f a@.  Basically, contains multiple</span><span>
</span><span id="line-166"></span><span class="hs-comment">-- @f a@s, each at a given 'Natural' index.</span><span>
</span><span id="line-167"></span><span class="hs-comment">--</span><span>
</span><span id="line-168"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-169"></span><span class="hs-comment">-- Steps f a ~ 'M.Map' 'Natural' (f a)</span><span>
</span><span id="line-170"></span><span class="hs-comment">-- Steps f   ~ 'M.Map' 'Natural' ':.:' f       -- functor composition</span><span>
</span><span id="line-171"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-172"></span><span class="hs-comment">--</span><span>
</span><span id="line-173"></span><span class="hs-comment">-- It is the fixed point of applications of 'Data.Functor.These.TheseT'.</span><span>
</span><span id="line-174"></span><span class="hs-comment">--</span><span>
</span><span id="line-175"></span><span class="hs-comment">-- You can think of this as an infinite sparse array of @f a@s.</span><span>
</span><span id="line-176"></span><span class="hs-comment">--</span><span>
</span><span id="line-177"></span><span class="hs-comment">-- Intuitively, in an infinite @f \`TheseT\` f \`TheseT\` f \`TheseT\` f ...@,</span><span>
</span><span id="line-178"></span><span class="hs-comment">-- each of those infinite positions may have an @f@ in them.  However,</span><span>
</span><span id="line-179"></span><span class="hs-comment">-- because of the at-least-one nature of 'Data.Functor.These.TheseT', we know we have at least</span><span>
</span><span id="line-180"></span><span class="hs-comment">-- one f at one position /somewhere/.</span><span>
</span><span id="line-181"></span><span class="hs-comment">--</span><span>
</span><span id="line-182"></span><span class="hs-comment">-- A @'Steps' f a@ has potentially many @f@s, each stored at a different</span><span>
</span><span id="line-183"></span><span class="hs-comment">-- 'Natural' position, with the guaruntee that at least one @f@ exists.</span><span>
</span><span id="line-184"></span><span class="hs-comment">--</span><span>
</span><span id="line-185"></span><span class="hs-comment">-- Can be useful for using with the 'Data.HBifunctor.Tensor.Monoidal' instance</span><span>
</span><span id="line-186"></span><span class="hs-comment">-- of 'Data.Functor.These.TheseT'.</span><span>
</span><span id="line-187"></span><span class="hs-comment">--</span><span>
</span><span id="line-188"></span><span class="hs-comment">-- 'Data.HFunctor.interpret'ing it requires at least an 'Alt'</span><span>
</span><span id="line-189"></span><span class="hs-comment">-- instance in the target context, since we have to handle potentially more</span><span>
</span><span id="line-190"></span><span class="hs-comment">-- than one @f@.</span><span>
</span><span id="line-191"></span><span class="hs-comment">--</span><span>
</span><span id="line-192"></span><span class="hs-comment">-- This type is essentailly the same as @'Control.Applicative.ListF.NEMapF'</span><span>
</span><span id="line-193"></span><span class="hs-comment">-- ('Sum' 'Natural')@ (except with a different 'Semigroup' instance).</span><span>
</span><span id="line-194"></span><span id="local-6989586621679479529"><span id="local-6989586621679479530"></span></span><span class="hs-keyword">newtype</span><span> </span><span id="Steps"><span class="annot"><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-var">Steps</span></a></span></span><span> </span><span id="local-6989586621679480293"><span class="annot"><a href="#local-6989586621679480293"><span class="hs-identifier hs-type">f</span></a></span></span><span> </span><span id="local-6989586621679480292"><span class="annot"><a href="#local-6989586621679480292"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="Steps"><span class="annot"><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-var">Steps</span></a></span></span><span> </span><span class="hs-special">{</span><span> </span><span id="getSteps"><span class="annot"><span class="annottext">Steps f a -&gt; NEMap Natural (f a)
</span><a href="Control.Applicative.Step.html#getSteps"><span class="hs-identifier hs-var hs-var">getSteps</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">NEMap</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Natural</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679480293"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679480292"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-195"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679479521"><span id="local-6989586621679479523"><span id="local-6989586621679479525"><span class="annot"><span class="annottext">Int -&gt; Steps f a -&gt; ShowS
[Steps f a] -&gt; ShowS
Steps f a -&gt; String
(Int -&gt; Steps f a -&gt; ShowS)
-&gt; (Steps f a -&gt; String)
-&gt; ([Steps f a] -&gt; ShowS)
-&gt; Show (Steps f a)
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
forall k (f :: k -&gt; *) (a :: k).
Show (f a) =&gt;
Int -&gt; Steps f a -&gt; ShowS
forall k (f :: k -&gt; *) (a :: k). Show (f a) =&gt; [Steps f a] -&gt; ShowS
forall k (f :: k -&gt; *) (a :: k). Show (f a) =&gt; Steps f a -&gt; String
showList :: [Steps f a] -&gt; ShowS
$cshowList :: forall k (f :: k -&gt; *) (a :: k). Show (f a) =&gt; [Steps f a] -&gt; ShowS
show :: Steps f a -&gt; String
$cshow :: forall k (f :: k -&gt; *) (a :: k). Show (f a) =&gt; Steps f a -&gt; String
showsPrec :: Int -&gt; Steps f a -&gt; ShowS
$cshowsPrec :: forall k (f :: k -&gt; *) (a :: k).
Show (f a) =&gt;
Int -&gt; Steps f a -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679479513"><span id="local-6989586621679479515"><span id="local-6989586621679479517"><span id="local-6989586621679479519"><span class="annot"><span class="annottext">ReadPrec [Steps f a]
ReadPrec (Steps f a)
Int -&gt; ReadS (Steps f a)
ReadS [Steps f a]
(Int -&gt; ReadS (Steps f a))
-&gt; ReadS [Steps f a]
-&gt; ReadPrec (Steps f a)
-&gt; ReadPrec [Steps f a]
-&gt; Read (Steps f a)
forall a.
(Int -&gt; ReadS a)
-&gt; ReadS [a] -&gt; ReadPrec a -&gt; ReadPrec [a] -&gt; Read a
forall k (f :: k -&gt; *) (a :: k). Read (f a) =&gt; ReadPrec [Steps f a]
forall k (f :: k -&gt; *) (a :: k). Read (f a) =&gt; ReadPrec (Steps f a)
forall k (f :: k -&gt; *) (a :: k).
Read (f a) =&gt;
Int -&gt; ReadS (Steps f a)
forall k (f :: k -&gt; *) (a :: k). Read (f a) =&gt; ReadS [Steps f a]
readListPrec :: ReadPrec [Steps f a]
$creadListPrec :: forall k (f :: k -&gt; *) (a :: k). Read (f a) =&gt; ReadPrec [Steps f a]
readPrec :: ReadPrec (Steps f a)
$creadPrec :: forall k (f :: k -&gt; *) (a :: k). Read (f a) =&gt; ReadPrec (Steps f a)
readList :: ReadS [Steps f a]
$creadList :: forall k (f :: k -&gt; *) (a :: k). Read (f a) =&gt; ReadS [Steps f a]
readsPrec :: Int -&gt; ReadS (Steps f a)
$creadsPrec :: forall k (f :: k -&gt; *) (a :: k).
Read (f a) =&gt;
Int -&gt; ReadS (Steps f a)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Read</span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679479509"><span id="local-6989586621679479511"><span class="annot"><span class="annottext">Steps f a -&gt; Steps f a -&gt; Bool
(Steps f a -&gt; Steps f a -&gt; Bool)
-&gt; (Steps f a -&gt; Steps f a -&gt; Bool) -&gt; Eq (Steps f a)
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
forall k (f :: k -&gt; *) (a :: k).
Eq (f a) =&gt;
Steps f a -&gt; Steps f a -&gt; Bool
/= :: Steps f a -&gt; Steps f a -&gt; Bool
$c/= :: forall k (f :: k -&gt; *) (a :: k).
Eq (f a) =&gt;
Steps f a -&gt; Steps f a -&gt; Bool
== :: Steps f a -&gt; Steps f a -&gt; Bool
$c== :: forall k (f :: k -&gt; *) (a :: k).
Eq (f a) =&gt;
Steps f a -&gt; Steps f a -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679479494"><span id="local-6989586621679479496"><span id="local-6989586621679479498"><span id="local-6989586621679479500"><span id="local-6989586621679479502"><span id="local-6989586621679479504"><span id="local-6989586621679479506"><span class="annot"><span class="annottext">Eq (Steps f a)
Eq (Steps f a) =&gt;
(Steps f a -&gt; Steps f a -&gt; Ordering)
-&gt; (Steps f a -&gt; Steps f a -&gt; Bool)
-&gt; (Steps f a -&gt; Steps f a -&gt; Bool)
-&gt; (Steps f a -&gt; Steps f a -&gt; Bool)
-&gt; (Steps f a -&gt; Steps f a -&gt; Bool)
-&gt; (Steps f a -&gt; Steps f a -&gt; Steps f a)
-&gt; (Steps f a -&gt; Steps f a -&gt; Steps f a)
-&gt; Ord (Steps f a)
Steps f a -&gt; Steps f a -&gt; Bool
Steps f a -&gt; Steps f a -&gt; Ordering
Steps f a -&gt; Steps f a -&gt; Steps f a
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall k (f :: k -&gt; *) (a :: k). Ord (f a) =&gt; Eq (Steps f a)
forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Steps f a -&gt; Steps f a -&gt; Bool
forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Steps f a -&gt; Steps f a -&gt; Ordering
forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Steps f a -&gt; Steps f a -&gt; Steps f a
min :: Steps f a -&gt; Steps f a -&gt; Steps f a
$cmin :: forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Steps f a -&gt; Steps f a -&gt; Steps f a
max :: Steps f a -&gt; Steps f a -&gt; Steps f a
$cmax :: forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Steps f a -&gt; Steps f a -&gt; Steps f a
&gt;= :: Steps f a -&gt; Steps f a -&gt; Bool
$c&gt;= :: forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Steps f a -&gt; Steps f a -&gt; Bool
&gt; :: Steps f a -&gt; Steps f a -&gt; Bool
$c&gt; :: forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Steps f a -&gt; Steps f a -&gt; Bool
&lt;= :: Steps f a -&gt; Steps f a -&gt; Bool
$c&lt;= :: forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Steps f a -&gt; Steps f a -&gt; Bool
&lt; :: Steps f a -&gt; Steps f a -&gt; Bool
$c&lt; :: forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Steps f a -&gt; Steps f a -&gt; Bool
compare :: Steps f a -&gt; Steps f a -&gt; Ordering
$ccompare :: forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Steps f a -&gt; Steps f a -&gt; Ordering
$cp1Ord :: forall k (f :: k -&gt; *) (a :: k). Ord (f a) =&gt; Eq (Steps f a)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679479490"><span id="local-6989586621679479492"><span class="annot"><span class="annottext">a -&gt; Steps f b -&gt; Steps f a
(a -&gt; b) -&gt; Steps f a -&gt; Steps f b
(forall a b. (a -&gt; b) -&gt; Steps f a -&gt; Steps f b)
-&gt; (forall a b. a -&gt; Steps f b -&gt; Steps f a) -&gt; Functor (Steps f)
forall a b. a -&gt; Steps f b -&gt; Steps f a
forall a b. (a -&gt; b) -&gt; Steps f a -&gt; Steps f b
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; Steps f b -&gt; Steps f a
forall (f :: * -&gt; *) a b.
Functor f =&gt;
(a -&gt; b) -&gt; Steps f a -&gt; Steps f b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: a -&gt; Steps f b -&gt; Steps f a
$c&lt;$ :: forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; Steps f b -&gt; Steps f a
fmap :: (a -&gt; b) -&gt; Steps f a -&gt; Steps f b
$cfmap :: forall (f :: * -&gt; *) a b.
Functor f =&gt;
(a -&gt; b) -&gt; Steps f a -&gt; Steps f b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679479456"><span id="local-6989586621679479458"><span id="local-6989586621679479460"><span id="local-6989586621679479462"><span id="local-6989586621679479464"><span id="local-6989586621679479466"><span id="local-6989586621679479468"><span id="local-6989586621679479470"><span id="local-6989586621679479472"><span id="local-6989586621679479474"><span id="local-6989586621679479476"><span id="local-6989586621679479478"><span id="local-6989586621679479480"><span id="local-6989586621679479482"><span id="local-6989586621679479484"><span id="local-6989586621679479486"><span id="local-6989586621679479488"><span class="annot"><span class="annottext">Steps f a -&gt; Bool
(a -&gt; m) -&gt; Steps f a -&gt; m
(a -&gt; b -&gt; b) -&gt; b -&gt; Steps f a -&gt; b
(forall m. Monoid m =&gt; Steps f m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Steps f a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Steps f a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Steps f a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Steps f a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Steps f a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Steps f a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; Steps f a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; Steps f a -&gt; a)
-&gt; (forall a. Steps f a -&gt; [a])
-&gt; (forall a. Steps f a -&gt; Bool)
-&gt; (forall a. Steps f a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; Steps f a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; Steps f a -&gt; a)
-&gt; (forall a. Ord a =&gt; Steps f a -&gt; a)
-&gt; (forall a. Num a =&gt; Steps f a -&gt; a)
-&gt; (forall a. Num a =&gt; Steps f a -&gt; a)
-&gt; Foldable (Steps f)
forall a. Eq a =&gt; a -&gt; Steps f a -&gt; Bool
forall a. Num a =&gt; Steps f a -&gt; a
forall a. Ord a =&gt; Steps f a -&gt; a
forall m. Monoid m =&gt; Steps f m -&gt; m
forall a. Steps f a -&gt; Bool
forall a. Steps f a -&gt; Int
forall a. Steps f a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; Steps f a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Steps f a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Steps f a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Steps f a -&gt; b
forall (f :: * -&gt; *) a.
(Foldable f, Eq a) =&gt;
a -&gt; Steps f a -&gt; Bool
forall (f :: * -&gt; *) a. (Foldable f, Num a) =&gt; Steps f a -&gt; a
forall (f :: * -&gt; *) a. (Foldable f, Ord a) =&gt; Steps f a -&gt; a
forall (f :: * -&gt; *) m. (Foldable f, Monoid m) =&gt; Steps f m -&gt; m
forall (f :: * -&gt; *) a. Foldable f =&gt; Steps f a -&gt; Bool
forall (f :: * -&gt; *) a. Foldable f =&gt; Steps f a -&gt; Int
forall (f :: * -&gt; *) a. Foldable f =&gt; Steps f a -&gt; [a]
forall (f :: * -&gt; *) a.
Foldable f =&gt;
(a -&gt; a -&gt; a) -&gt; Steps f a -&gt; a
forall (f :: * -&gt; *) m a.
(Foldable f, Monoid m) =&gt;
(a -&gt; m) -&gt; Steps f a -&gt; m
forall (f :: * -&gt; *) b a.
Foldable f =&gt;
(b -&gt; a -&gt; b) -&gt; b -&gt; Steps f a -&gt; b
forall (f :: * -&gt; *) a b.
Foldable f =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; Steps f a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: Steps f a -&gt; a
$cproduct :: forall (f :: * -&gt; *) a. (Foldable f, Num a) =&gt; Steps f a -&gt; a
sum :: Steps f a -&gt; a
$csum :: forall (f :: * -&gt; *) a. (Foldable f, Num a) =&gt; Steps f a -&gt; a
minimum :: Steps f a -&gt; a
$cminimum :: forall (f :: * -&gt; *) a. (Foldable f, Ord a) =&gt; Steps f a -&gt; a
maximum :: Steps f a -&gt; a
$cmaximum :: forall (f :: * -&gt; *) a. (Foldable f, Ord a) =&gt; Steps f a -&gt; a
elem :: a -&gt; Steps f a -&gt; Bool
$celem :: forall (f :: * -&gt; *) a.
(Foldable f, Eq a) =&gt;
a -&gt; Steps f a -&gt; Bool
length :: Steps f a -&gt; Int
$clength :: forall (f :: * -&gt; *) a. Foldable f =&gt; Steps f a -&gt; Int
null :: Steps f a -&gt; Bool
$cnull :: forall (f :: * -&gt; *) a. Foldable f =&gt; Steps f a -&gt; Bool
toList :: Steps f a -&gt; [a]
$ctoList :: forall (f :: * -&gt; *) a. Foldable f =&gt; Steps f a -&gt; [a]
foldl1 :: (a -&gt; a -&gt; a) -&gt; Steps f a -&gt; a
$cfoldl1 :: forall (f :: * -&gt; *) a.
Foldable f =&gt;
(a -&gt; a -&gt; a) -&gt; Steps f a -&gt; a
foldr1 :: (a -&gt; a -&gt; a) -&gt; Steps f a -&gt; a
$cfoldr1 :: forall (f :: * -&gt; *) a.
Foldable f =&gt;
(a -&gt; a -&gt; a) -&gt; Steps f a -&gt; a
foldl' :: (b -&gt; a -&gt; b) -&gt; b -&gt; Steps f a -&gt; b
$cfoldl' :: forall (f :: * -&gt; *) b a.
Foldable f =&gt;
(b -&gt; a -&gt; b) -&gt; b -&gt; Steps f a -&gt; b
foldl :: (b -&gt; a -&gt; b) -&gt; b -&gt; Steps f a -&gt; b
$cfoldl :: forall (f :: * -&gt; *) b a.
Foldable f =&gt;
(b -&gt; a -&gt; b) -&gt; b -&gt; Steps f a -&gt; b
foldr' :: (a -&gt; b -&gt; b) -&gt; b -&gt; Steps f a -&gt; b
$cfoldr' :: forall (f :: * -&gt; *) a b.
Foldable f =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; Steps f a -&gt; b
foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; Steps f a -&gt; b
$cfoldr :: forall (f :: * -&gt; *) a b.
Foldable f =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; Steps f a -&gt; b
foldMap' :: (a -&gt; m) -&gt; Steps f a -&gt; m
$cfoldMap' :: forall (f :: * -&gt; *) m a.
(Foldable f, Monoid m) =&gt;
(a -&gt; m) -&gt; Steps f a -&gt; m
foldMap :: (a -&gt; m) -&gt; Steps f a -&gt; m
$cfoldMap :: forall (f :: * -&gt; *) m a.
(Foldable f, Monoid m) =&gt;
(a -&gt; m) -&gt; Steps f a -&gt; m
fold :: Steps f m -&gt; m
$cfold :: forall (f :: * -&gt; *) m. (Foldable f, Monoid m) =&gt; Steps f m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679479446"><span id="local-6989586621679479448"><span id="local-6989586621679479450"><span id="local-6989586621679479452"><span class="annot"><span class="annottext">Functor (Steps f)
Foldable (Steps f)
(Functor (Steps f), Foldable (Steps f)) =&gt;
(forall (f :: * -&gt; *) a b.
 Applicative f =&gt;
 (a -&gt; f b) -&gt; Steps f a -&gt; f (Steps f b))
-&gt; (forall (f :: * -&gt; *) a.
    Applicative f =&gt;
    Steps f (f a) -&gt; f (Steps f a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; Steps f a -&gt; m (Steps f b))
-&gt; (forall (m :: * -&gt; *) a.
    Monad m =&gt;
    Steps f (m a) -&gt; m (Steps f a))
-&gt; Traversable (Steps f)
(a -&gt; f b) -&gt; Steps f a -&gt; f (Steps f b)
forall (t :: * -&gt; *).
(Functor t, Foldable t) =&gt;
(forall (f :: * -&gt; *) a b.
 Applicative f =&gt;
 (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (f :: * -&gt; *). Traversable f =&gt; Functor (Steps f)
forall (f :: * -&gt; *). Traversable f =&gt; Foldable (Steps f)
forall (f :: * -&gt; *) (m :: * -&gt; *) a.
(Traversable f, Monad m) =&gt;
Steps f (m a) -&gt; m (Steps f a)
forall (f :: * -&gt; *) (f :: * -&gt; *) a.
(Traversable f, Applicative f) =&gt;
Steps f (f a) -&gt; f (Steps f a)
forall (f :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable f, Monad m) =&gt;
(a -&gt; m b) -&gt; Steps f a -&gt; m (Steps f b)
forall (f :: * -&gt; *) (f :: * -&gt; *) a b.
(Traversable f, Applicative f) =&gt;
(a -&gt; f b) -&gt; Steps f a -&gt; f (Steps f b)
forall (m :: * -&gt; *) a. Monad m =&gt; Steps f (m a) -&gt; m (Steps f a)
forall (f :: * -&gt; *) a.
Applicative f =&gt;
Steps f (f a) -&gt; f (Steps f a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Steps f a -&gt; m (Steps f b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Steps f a -&gt; f (Steps f b)
sequence :: Steps f (m a) -&gt; m (Steps f a)
$csequence :: forall (f :: * -&gt; *) (m :: * -&gt; *) a.
(Traversable f, Monad m) =&gt;
Steps f (m a) -&gt; m (Steps f a)
mapM :: (a -&gt; m b) -&gt; Steps f a -&gt; m (Steps f b)
$cmapM :: forall (f :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable f, Monad m) =&gt;
(a -&gt; m b) -&gt; Steps f a -&gt; m (Steps f b)
sequenceA :: Steps f (f a) -&gt; f (Steps f a)
$csequenceA :: forall (f :: * -&gt; *) (f :: * -&gt; *) a.
(Traversable f, Applicative f) =&gt;
Steps f (f a) -&gt; f (Steps f a)
traverse :: (a -&gt; f b) -&gt; Steps f a -&gt; f (Steps f b)
$ctraverse :: forall (f :: * -&gt; *) (f :: * -&gt; *) a b.
(Traversable f, Applicative f) =&gt;
(a -&gt; f b) -&gt; Steps f a -&gt; f (Steps f b)
$cp2Traversable :: forall (f :: * -&gt; *). Traversable f =&gt; Foldable (Steps f)
$cp1Traversable :: forall (f :: * -&gt; *). Traversable f =&gt; Functor (Steps f)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">(forall x. Steps f a -&gt; Rep (Steps f a) x)
-&gt; (forall x. Rep (Steps f a) x -&gt; Steps f a)
-&gt; Generic (Steps f a)
forall x. Rep (Steps f a) x -&gt; Steps f a
forall x. Steps f a -&gt; Rep (Steps f a) x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall k (f :: k -&gt; *) (a :: k) x. Rep (Steps f a) x -&gt; Steps f a
forall k (f :: k -&gt; *) (a :: k) x. Steps f a -&gt; Rep (Steps f a) x
$cto :: forall k (f :: k -&gt; *) (a :: k) x. Rep (Steps f a) x -&gt; Steps f a
$cfrom :: forall k (f :: k -&gt; *) (a :: k) x. Steps f a -&gt; Rep (Steps f a) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">,</span><span> </span><span id="%24cSteps"><span id="%24tSteps"><span id="local-6989586621679479415"><span id="local-6989586621679479417"><span id="local-6989586621679479419"><span id="local-6989586621679479421"><span id="local-6989586621679479423"><span id="local-6989586621679479425"><span id="local-6989586621679479427"><span id="local-6989586621679479429"><span id="local-6989586621679479431"><span id="local-6989586621679479433"><span id="local-6989586621679479435"><span id="local-6989586621679479437"><span id="local-6989586621679479439"><span id="local-6989586621679479441"><span class="annot"><span class="annottext">Typeable (Steps f a)
DataType
Constr
Typeable (Steps f a) =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; Steps f a -&gt; c (Steps f a))
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Steps f a))
-&gt; (Steps f a -&gt; Constr)
-&gt; (Steps f a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Steps f a)))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e))
    -&gt; Maybe (c (Steps f a)))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; Steps f a -&gt; Steps f a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Steps f a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Steps f a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Steps f a -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Steps f a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Steps f a -&gt; m (Steps f a))
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Steps f a -&gt; m (Steps f a))
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Steps f a -&gt; m (Steps f a))
-&gt; Data (Steps f a)
Steps f a -&gt; DataType
Steps f a -&gt; Constr
(forall b. Data b =&gt; b -&gt; b) -&gt; Steps f a -&gt; Steps f a
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Steps f a -&gt; c (Steps f a)
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Steps f a)
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Steps f a -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Steps f a -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Steps f a -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Steps f a -&gt; r
forall k (f :: k -&gt; *) (a :: k).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
Typeable (Steps f a)
forall k (f :: k -&gt; *) (a :: k).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
Steps f a -&gt; DataType
forall k (f :: k -&gt; *) (a :: k).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
Steps f a -&gt; Constr
forall k (f :: k -&gt; *) (a :: k).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Steps f a -&gt; Steps f a
forall k (f :: k -&gt; *) (a :: k) u.
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Steps f a -&gt; u
forall k (f :: k -&gt; *) (a :: k) u.
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; Steps f a -&gt; [u]
forall k (f :: k -&gt; *) (a :: k) r r'.
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Steps f a -&gt; r
forall k (f :: k -&gt; *) (a :: k) r r'.
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Steps f a -&gt; r
forall k (f :: k -&gt; *) (a :: k) (m :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Steps f a -&gt; m (Steps f a)
forall k (f :: k -&gt; *) (a :: k) (m :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Steps f a -&gt; m (Steps f a)
forall k (f :: k -&gt; *) (a :: k) (c :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Steps f a)
forall k (f :: k -&gt; *) (a :: k) (c :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Steps f a -&gt; c (Steps f a)
forall k (f :: k -&gt; *) (a :: k) (t :: * -&gt; *) (c :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Steps f a))
forall k (f :: k -&gt; *) (a :: k) (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Steps f a))
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Steps f a -&gt; m (Steps f a)
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Steps f a -&gt; m (Steps f a)
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Steps f a)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Steps f a -&gt; c (Steps f a)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Steps f a))
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Steps f a))
$cSteps :: Constr
$tSteps :: DataType
gmapMo :: (forall d. Data d =&gt; d -&gt; m d) -&gt; Steps f a -&gt; m (Steps f a)
$cgmapMo :: forall k (f :: k -&gt; *) (a :: k) (m :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Steps f a -&gt; m (Steps f a)
gmapMp :: (forall d. Data d =&gt; d -&gt; m d) -&gt; Steps f a -&gt; m (Steps f a)
$cgmapMp :: forall k (f :: k -&gt; *) (a :: k) (m :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Steps f a -&gt; m (Steps f a)
gmapM :: (forall d. Data d =&gt; d -&gt; m d) -&gt; Steps f a -&gt; m (Steps f a)
$cgmapM :: forall k (f :: k -&gt; *) (a :: k) (m :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Steps f a -&gt; m (Steps f a)
gmapQi :: Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Steps f a -&gt; u
$cgmapQi :: forall k (f :: k -&gt; *) (a :: k) u.
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Steps f a -&gt; u
gmapQ :: (forall d. Data d =&gt; d -&gt; u) -&gt; Steps f a -&gt; [u]
$cgmapQ :: forall k (f :: k -&gt; *) (a :: k) u.
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; Steps f a -&gt; [u]
gmapQr :: (r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Steps f a -&gt; r
$cgmapQr :: forall k (f :: k -&gt; *) (a :: k) r r'.
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Steps f a -&gt; r
gmapQl :: (r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Steps f a -&gt; r
$cgmapQl :: forall k (f :: k -&gt; *) (a :: k) r r'.
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Steps f a -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Steps f a -&gt; Steps f a
$cgmapT :: forall k (f :: k -&gt; *) (a :: k).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Steps f a -&gt; Steps f a
dataCast2 :: (forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Steps f a))
$cdataCast2 :: forall k (f :: k -&gt; *) (a :: k) (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Steps f a))
dataCast1 :: (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Steps f a))
$cdataCast1 :: forall k (f :: k -&gt; *) (a :: k) (t :: * -&gt; *) (c :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Steps f a))
dataTypeOf :: Steps f a -&gt; DataType
$cdataTypeOf :: forall k (f :: k -&gt; *) (a :: k).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
Steps f a -&gt; DataType
toConstr :: Steps f a -&gt; Constr
$ctoConstr :: forall k (f :: k -&gt; *) (a :: k).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
Steps f a -&gt; Constr
gunfold :: (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Steps f a)
$cgunfold :: forall k (f :: k -&gt; *) (a :: k) (c :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Steps f a)
gfoldl :: (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Steps f a -&gt; c (Steps f a)
$cgfoldl :: forall k (f :: k -&gt; *) (a :: k) (c :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Steps f a -&gt; c (Steps f a)
$cp1Data :: forall k (f :: k -&gt; *) (a :: k).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
Typeable (Steps f a)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-196"></span><span>
</span><span id="line-197"></span><span id="local-6989586621679479409"><span id="local-6989586621679479411"><span id="local-6989586621679480293"><span class="hs-identifier">deriveShow1</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Steps</span></span></span></span><span>
</span><span id="line-198"></span><span id="local-6989586621679479401"><span id="local-6989586621679479403"><span id="local-6989586621679479405"><span id="local-6989586621679479407"><span id="local-6989586621679480293"><span class="hs-identifier">deriveRead1</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Steps</span></span></span></span></span></span><span>
</span><span id="line-199"></span><span id="local-6989586621679479399"><span id="local-6989586621679480293"><span class="hs-identifier">deriveEq1</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Steps</span></span></span><span>
</span><span id="line-200"></span><span id="local-6989586621679479396"><span id="local-6989586621679480293"><span class="hs-identifier">deriveOrd1</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Steps</span></span></span><span>
</span><span id="line-201"></span><span>
</span><span id="line-202"></span><span id="local-6989586621679479395"><span class="hs-keyword">instance</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Foldable1</span></span><span> </span><span class="annot"><a href="#local-6989586621679479395"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Foldable1</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-type">Steps</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679479395"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-203"></span><span>    </span><span id="local-6989586621679479390"><span class="annot"><span class="annottext">fold1 :: Steps f m -&gt; m
</span><a href="#local-6989586621679479390"><span class="hs-identifier hs-var hs-var hs-var hs-var">fold1</span></a></span></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(f m -&gt; m) -&gt; NEMap Natural (f m) -&gt; m
forall (t :: * -&gt; *) m a.
(Foldable1 t, Semigroup m) =&gt;
(a -&gt; m) -&gt; t a -&gt; m
</span><span class="hs-identifier hs-var">foldMap1</span></span><span> </span><span class="annot"><span class="annottext">f m -&gt; m
forall (t :: * -&gt; *) m. (Foldable1 t, Semigroup m) =&gt; t m -&gt; m
</span><span class="hs-identifier hs-var">fold1</span></span><span> </span><span class="annot"><span class="annottext">(NEMap Natural (f m) -&gt; m)
-&gt; (Steps f m -&gt; NEMap Natural (f m)) -&gt; Steps f m -&gt; m
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Steps f m -&gt; NEMap Natural (f m)
forall k (f :: k -&gt; *) (a :: k). Steps f a -&gt; NEMap Natural (f a)
</span><a href="Control.Applicative.Step.html#getSteps"><span class="hs-identifier hs-var hs-var">getSteps</span></a></span><span>
</span><span id="line-204"></span><span>    </span><span id="local-6989586621679479389"><span class="annot"><span class="annottext">foldMap1 :: (a -&gt; m) -&gt; Steps f a -&gt; m
</span><a href="#local-6989586621679479389"><span class="hs-identifier hs-var hs-var hs-var hs-var">foldMap1</span></a></span></span><span> </span><span id="local-6989586621679479388"><span class="annot"><span class="annottext">f :: a -&gt; m
</span><a href="#local-6989586621679479388"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(f a -&gt; m) -&gt; NEMap Natural (f a) -&gt; m
forall (t :: * -&gt; *) m a.
(Foldable1 t, Semigroup m) =&gt;
(a -&gt; m) -&gt; t a -&gt; m
</span><span class="hs-identifier hs-var">foldMap1</span></span><span> </span><span class="annot"><span class="annottext">((f a -&gt; m) -&gt; NEMap Natural (f a) -&gt; m)
-&gt; ((a -&gt; m) -&gt; f a -&gt; m) -&gt; (a -&gt; m) -&gt; NEMap Natural (f a) -&gt; m
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">(a -&gt; m) -&gt; f a -&gt; m
forall (t :: * -&gt; *) m a.
(Foldable1 t, Semigroup m) =&gt;
(a -&gt; m) -&gt; t a -&gt; m
</span><span class="hs-identifier hs-var">foldMap1</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">a -&gt; m
</span><a href="#local-6989586621679479388"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">(NEMap Natural (f a) -&gt; m)
-&gt; (Steps f a -&gt; NEMap Natural (f a)) -&gt; Steps f a -&gt; m
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Steps f a -&gt; NEMap Natural (f a)
forall k (f :: k -&gt; *) (a :: k). Steps f a -&gt; NEMap Natural (f a)
</span><a href="Control.Applicative.Step.html#getSteps"><span class="hs-identifier hs-var hs-var">getSteps</span></a></span><span>
</span><span id="line-205"></span><span>    </span><span id="local-6989586621679479387"><span class="annot"><span class="annottext">toNonEmpty :: Steps f a -&gt; NonEmpty a
</span><a href="#local-6989586621679479387"><span class="hs-identifier hs-var hs-var hs-var hs-var">toNonEmpty</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(f a -&gt; NonEmpty a) -&gt; NEMap Natural (f a) -&gt; NonEmpty a
forall (t :: * -&gt; *) m a.
(Foldable1 t, Semigroup m) =&gt;
(a -&gt; m) -&gt; t a -&gt; m
</span><span class="hs-identifier hs-var">foldMap1</span></span><span> </span><span class="annot"><span class="annottext">f a -&gt; NonEmpty a
forall (t :: * -&gt; *) a. Foldable1 t =&gt; t a -&gt; NonEmpty a
</span><span class="hs-identifier hs-var">toNonEmpty</span></span><span> </span><span class="annot"><span class="annottext">(NEMap Natural (f a) -&gt; NonEmpty a)
-&gt; (Steps f a -&gt; NEMap Natural (f a)) -&gt; Steps f a -&gt; NonEmpty a
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Steps f a -&gt; NEMap Natural (f a)
forall k (f :: k -&gt; *) (a :: k). Steps f a -&gt; NEMap Natural (f a)
</span><a href="Control.Applicative.Step.html#getSteps"><span class="hs-identifier hs-var hs-var">getSteps</span></a></span></span><span>
</span><span id="line-206"></span><span>
</span><span id="line-207"></span><span id="local-6989586621679479386"><span class="hs-keyword">instance</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Traversable1</span></span><span> </span><span class="annot"><a href="#local-6989586621679479386"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Traversable1</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-type">Steps</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679479386"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-208"></span><span>    </span><span id="local-6989586621679479381"><span class="annot"><span class="annottext">traverse1 :: (a -&gt; f b) -&gt; Steps f a -&gt; f (Steps f b)
</span><a href="#local-6989586621679479381"><span class="hs-identifier hs-var hs-var hs-var hs-var">traverse1</span></a></span></span><span> </span><span id="local-6989586621679479380"><span class="annot"><span class="annottext">f :: a -&gt; f b
</span><a href="#local-6989586621679479380"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(NEMap Natural (f b) -&gt; Steps f b)
-&gt; f (NEMap Natural (f b)) -&gt; f (Steps f b)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="annot"><span class="annottext">NEMap Natural (f b) -&gt; Steps f b
forall k (f :: k -&gt; *) (a :: k). NEMap Natural (f a) -&gt; Steps f a
</span><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-var">Steps</span></a></span><span> </span><span class="annot"><span class="annottext">(f (NEMap Natural (f b)) -&gt; f (Steps f b))
-&gt; (Steps f a -&gt; f (NEMap Natural (f b)))
-&gt; Steps f a
-&gt; f (Steps f b)
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(f a -&gt; f (f b)) -&gt; NEMap Natural (f a) -&gt; f (NEMap Natural (f b))
forall (t :: * -&gt; *) (f :: * -&gt; *) a b.
(Traversable1 t, Apply f) =&gt;
(a -&gt; f b) -&gt; t a -&gt; f (t b)
</span><span class="hs-identifier hs-var">traverse1</span></span><span> </span><span class="annot"><span class="annottext">((f a -&gt; f (f b))
 -&gt; NEMap Natural (f a) -&gt; f (NEMap Natural (f b)))
-&gt; ((a -&gt; f b) -&gt; f a -&gt; f (f b))
-&gt; (a -&gt; f b)
-&gt; NEMap Natural (f a)
-&gt; f (NEMap Natural (f b))
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">(a -&gt; f b) -&gt; f a -&gt; f (f b)
forall (t :: * -&gt; *) (f :: * -&gt; *) a b.
(Traversable1 t, Apply f) =&gt;
(a -&gt; f b) -&gt; t a -&gt; f (t b)
</span><span class="hs-identifier hs-var">traverse1</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">a -&gt; f b
</span><a href="#local-6989586621679479380"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">(NEMap Natural (f a) -&gt; f (NEMap Natural (f b)))
-&gt; (Steps f a -&gt; NEMap Natural (f a))
-&gt; Steps f a
-&gt; f (NEMap Natural (f b))
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Steps f a -&gt; NEMap Natural (f a)
forall k (f :: k -&gt; *) (a :: k). Steps f a -&gt; NEMap Natural (f a)
</span><a href="Control.Applicative.Step.html#getSteps"><span class="hs-identifier hs-var hs-var">getSteps</span></a></span><span>
</span><span id="line-209"></span><span>    </span><span id="local-6989586621679479379"><span class="annot"><span class="annottext">sequence1 :: Steps f (f b) -&gt; f (Steps f b)
</span><a href="#local-6989586621679479379"><span class="hs-identifier hs-var hs-var hs-var hs-var">sequence1</span></a></span></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(NEMap Natural (f b) -&gt; Steps f b)
-&gt; f (NEMap Natural (f b)) -&gt; f (Steps f b)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="annot"><span class="annottext">NEMap Natural (f b) -&gt; Steps f b
forall k (f :: k -&gt; *) (a :: k). NEMap Natural (f a) -&gt; Steps f a
</span><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-var">Steps</span></a></span><span> </span><span class="annot"><span class="annottext">(f (NEMap Natural (f b)) -&gt; f (Steps f b))
-&gt; (Steps f (f b) -&gt; f (NEMap Natural (f b)))
-&gt; Steps f (f b)
-&gt; f (Steps f b)
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">(f (f b) -&gt; f (f b))
-&gt; NEMap Natural (f (f b)) -&gt; f (NEMap Natural (f b))
forall (t :: * -&gt; *) (f :: * -&gt; *) a b.
(Traversable1 t, Apply f) =&gt;
(a -&gt; f b) -&gt; t a -&gt; f (t b)
</span><span class="hs-identifier hs-var">traverse1</span></span><span> </span><span class="annot"><span class="annottext">f (f b) -&gt; f (f b)
forall (t :: * -&gt; *) (f :: * -&gt; *) b.
(Traversable1 t, Apply f) =&gt;
t (f b) -&gt; f (t b)
</span><span class="hs-identifier hs-var">sequence1</span></span><span> </span><span class="annot"><span class="annottext">(NEMap Natural (f (f b)) -&gt; f (NEMap Natural (f b)))
-&gt; (Steps f (f b) -&gt; NEMap Natural (f (f b)))
-&gt; Steps f (f b)
-&gt; f (NEMap Natural (f b))
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Steps f (f b) -&gt; NEMap Natural (f (f b))
forall k (f :: k -&gt; *) (a :: k). Steps f a -&gt; NEMap Natural (f a)
</span><a href="Control.Applicative.Step.html#getSteps"><span class="hs-identifier hs-var hs-var">getSteps</span></a></span></span><span>
</span><span id="line-210"></span><span>
</span><span id="line-211"></span><span class="hs-comment">-- | Appends the items back-to-back, shifting all of the items in the</span><span>
</span><span id="line-212"></span><span class="hs-comment">-- second map.  Matches the behavior as the fixed-point of 'These1'.</span><span>
</span><span id="line-213"></span><span id="local-6989586621679479377"><span id="local-6989586621679479378"><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679479372"><span id="local-6989586621679479374"><span class="annot"><span class="hs-identifier hs-type">Semigroup</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-type">Steps</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679479378"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679479377"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-214"></span><span>    </span><span class="annot"><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-type">Steps</span></a></span><span> </span><span id="local-6989586621679479370"><span class="annot"><span class="annottext">xs :: NEMap Natural (f a)
</span><a href="#local-6989586621679479370"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span id="local-6989586621679479369"><span class="annot"><span class="annottext">&lt;&gt; :: Steps f a -&gt; Steps f a -&gt; Steps f a
</span><span class="hs-operator hs-var hs-var hs-var hs-var">&lt;&gt;</span></span></span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-type">Steps</span></a></span><span> </span><span id="local-6989586621679479368"><span class="annot"><span class="annottext">ys :: NEMap Natural (f a)
</span><a href="#local-6989586621679479368"><span class="hs-identifier hs-var">ys</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">NEMap Natural (f a) -&gt; Steps f a
forall k (f :: k -&gt; *) (a :: k). NEMap Natural (f a) -&gt; Steps f a
</span><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-var">Steps</span></a></span><span> </span><span class="annot"><span class="annottext">(NEMap Natural (f a) -&gt; Steps f a)
-&gt; NEMap Natural (f a) -&gt; Steps f a
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>
</span><span id="line-215"></span><span>      </span><span class="hs-keyword">let</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679479367"><span class="annot"><span class="annottext">k :: Natural
</span><a href="#local-6989586621679479367"><span class="hs-identifier hs-var">k</span></a></span></span><span class="hs-special">,</span><span> </span><span class="hs-identifier">_</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">NEMap Natural (f a) -&gt; (Natural, f a)
forall k a. NEMap k a -&gt; (k, a)
</span><span class="hs-identifier hs-var">NEM.findMax</span></span><span> </span><span class="annot"><span class="annottext">NEMap Natural (f a)
</span><a href="#local-6989586621679479370"><span class="hs-identifier hs-var">xs</span></a></span><span>
</span><span id="line-216"></span><span>      </span><span class="hs-keyword">in</span><span>  </span><span class="annot"><span class="annottext">NEMap Natural (f a)
</span><a href="#local-6989586621679479370"><span class="hs-identifier hs-var">xs</span></a></span><span> </span><span class="annot"><span class="annottext">NEMap Natural (f a) -&gt; NEMap Natural (f a) -&gt; NEMap Natural (f a)
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">(Natural -&gt; Natural) -&gt; NEMap Natural (f a) -&gt; NEMap Natural (f a)
forall k1 k2 a. (k1 -&gt; k2) -&gt; NEMap k1 a -&gt; NEMap k2 a
</span><span class="hs-identifier hs-var">NEM.mapKeysMonotonic</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Natural -&gt; Natural -&gt; Natural
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">+</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Natural
</span><a href="#local-6989586621679479367"><span class="hs-identifier hs-var">k</span></a></span><span> </span><span class="annot"><span class="annottext">Natural -&gt; Natural -&gt; Natural
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">+</span></span><span> </span><span class="annot"><span class="hs-number">1</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">NEMap Natural (f a)
</span><a href="#local-6989586621679479368"><span class="hs-identifier hs-var">ys</span></a></span></span></span><span>
</span><span id="line-217"></span><span>
</span><span id="line-218"></span><span class="hs-comment">-- | Left-biased untion</span><span>
</span><span id="line-219"></span><span id="local-6989586621679479364"><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679479358"><span id="local-6989586621679479360"><span class="annot"><span class="hs-identifier hs-type">Functor</span></span><span> </span><span class="annot"><a href="#local-6989586621679479364"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Alt</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-type">Steps</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679479364"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-220"></span><span>    </span><span class="annot"><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-type">Steps</span></a></span><span> </span><span id="local-6989586621679479356"><span class="annot"><span class="annottext">xs :: NEMap Natural (f a)
</span><a href="#local-6989586621679479356"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span id="local-6989586621679479355"><span class="annot"><span class="annottext">&lt;!&gt; :: Steps f a -&gt; Steps f a -&gt; Steps f a
</span><span class="hs-operator hs-var hs-var hs-var hs-var">&lt;!&gt;</span></span></span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-type">Steps</span></a></span><span> </span><span id="local-6989586621679479353"><span class="annot"><span class="annottext">ys :: NEMap Natural (f a)
</span><a href="#local-6989586621679479353"><span class="hs-identifier hs-var">ys</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">NEMap Natural (f a) -&gt; Steps f a
forall k (f :: k -&gt; *) (a :: k). NEMap Natural (f a) -&gt; Steps f a
</span><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-var">Steps</span></a></span><span> </span><span class="annot"><span class="annottext">(NEMap Natural (f a) -&gt; Steps f a)
-&gt; NEMap Natural (f a) -&gt; Steps f a
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">NEMap Natural (f a) -&gt; NEMap Natural (f a) -&gt; NEMap Natural (f a)
forall k a. Ord k =&gt; NEMap k a -&gt; NEMap k a -&gt; NEMap k a
</span><span class="hs-identifier hs-var">NEM.union</span></span><span> </span><span class="annot"><span class="annottext">NEMap Natural (f a)
</span><a href="#local-6989586621679479356"><span class="hs-identifier hs-var">xs</span></a></span><span> </span><span class="annot"><span class="annottext">NEMap Natural (f a)
</span><a href="#local-6989586621679479353"><span class="hs-identifier hs-var">ys</span></a></span></span><span>
</span><span id="line-221"></span><span>
</span><span id="line-222"></span><span id="local-6989586621679479351"><span class="hs-keyword">instance</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Pointed</span></span><span> </span><span class="annot"><a href="#local-6989586621679479351"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Pointed</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-type">Steps</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679479351"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-223"></span><span>    </span><span id="local-6989586621679479349"><span class="annot"><span class="annottext">point :: a -&gt; Steps f a
</span><a href="#local-6989586621679479349"><span class="hs-identifier hs-var hs-var hs-var hs-var">point</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">NEMap Natural (f a) -&gt; Steps f a
forall k (f :: k -&gt; *) (a :: k). NEMap Natural (f a) -&gt; Steps f a
</span><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-var">Steps</span></a></span><span> </span><span class="annot"><span class="annottext">(NEMap Natural (f a) -&gt; Steps f a)
-&gt; (a -&gt; NEMap Natural (f a)) -&gt; a -&gt; Steps f a
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Natural -&gt; f a -&gt; NEMap Natural (f a)
forall k a. k -&gt; a -&gt; NEMap k a
</span><span class="hs-identifier hs-var">NEM.singleton</span></span><span> </span><span class="annot"><span class="hs-number">0</span></span><span> </span><span class="annot"><span class="annottext">(f a -&gt; NEMap Natural (f a))
-&gt; (a -&gt; f a) -&gt; a -&gt; NEMap Natural (f a)
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; f a
forall (p :: * -&gt; *) a. Pointed p =&gt; a -&gt; p a
</span><span class="hs-identifier hs-var">point</span></span></span><span>
</span><span id="line-224"></span><span>
</span><span id="line-225"></span><span class="hs-comment">-- | &quot;Uncons and cons&quot; an @f@ branch before a 'Steps'.  This is basically</span><span>
</span><span id="line-226"></span><span class="hs-comment">-- a witness that 'stepsDown' and 'stepsUp' form an isomorphism.</span><span>
</span><span id="line-227"></span><span id="local-6989586621679479347"><span class="annot"><a href="Control.Applicative.Step.html#steppings"><span class="hs-identifier hs-type">steppings</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-type">Steps</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679479347"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="Control.Natural.IsoF.html#%3C~%3E"><span class="hs-operator hs-type">&lt;~&gt;</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">These1</span></span><span> </span><span class="annot"><a href="#local-6989586621679479347"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-type">Steps</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679479347"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-228"></span><span id="steppings"><span class="annot"><span class="annottext">steppings :: p (These1 f (Steps f) a) (These1 f (Steps f) a)
-&gt; p (Steps f a) (Steps f a)
</span><a href="Control.Applicative.Step.html#steppings"><span class="hs-identifier hs-var hs-var">steppings</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Steps f ~&gt; These1 f (Steps f))
-&gt; (These1 f (Steps f) ~&gt; Steps f)
-&gt; Steps f &lt;~&gt; These1 f (Steps f)
forall k (f :: k -&gt; *) (g :: k -&gt; *).
(f ~&gt; g) -&gt; (g ~&gt; f) -&gt; f &lt;~&gt; g
</span><a href="Control.Natural.IsoF.html#isoF"><span class="hs-identifier hs-var">isoF</span></a></span><span> </span><span class="annot"><span class="annottext">Steps f ~&gt; These1 f (Steps f)
forall (f :: * -&gt; *). Steps f ~&gt; These1 f (Steps f)
</span><a href="Control.Applicative.Step.html#stepsDown"><span class="hs-identifier hs-var">stepsDown</span></a></span><span> </span><span class="annot"><span class="annottext">These1 f (Steps f) ~&gt; Steps f
forall (f :: * -&gt; *). These1 f (Steps f) ~&gt; Steps f
</span><a href="Control.Applicative.Step.html#stepsUp"><span class="hs-identifier hs-var">stepsUp</span></a></span><span>
</span><span id="line-229"></span><span>
</span><span id="line-230"></span><span class="hs-comment">-- | Pop off the first item in a 'Steps'.  Because a @'Steps' f@ is @f</span><span>
</span><span id="line-231"></span><span class="hs-comment">-- `These1` f `These1` f `These1` ...@ forever, this matches on the first branch.</span><span>
</span><span id="line-232"></span><span class="hs-comment">--</span><span>
</span><span id="line-233"></span><span class="hs-comment">-- You can think of it as reassociating</span><span>
</span><span id="line-234"></span><span class="hs-comment">--</span><span>
</span><span id="line-235"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-236"></span><span class="hs-comment">-- f `These1` f `These1` f `These1` f `These1` ...</span><span>
</span><span id="line-237"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-238"></span><span class="hs-comment">--</span><span>
</span><span id="line-239"></span><span class="hs-comment">-- into</span><span>
</span><span id="line-240"></span><span class="hs-comment">--</span><span>
</span><span id="line-241"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-242"></span><span class="hs-comment">-- f `These1` ( f `These1` f `These1` f `These1` ...)</span><span>
</span><span id="line-243"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-244"></span><span class="hs-comment">--</span><span>
</span><span id="line-245"></span><span class="hs-comment">-- It returns:</span><span>
</span><span id="line-246"></span><span class="hs-comment">--</span><span>
</span><span id="line-247"></span><span class="hs-comment">-- *  'This1' if the first item is the /only/ item in the 'Steps'</span><span>
</span><span id="line-248"></span><span class="hs-comment">-- *  'That1' if the first item in the 'Steps' is empty, but there are more</span><span>
</span><span id="line-249"></span><span class="hs-comment">--    items left.  The extra items are all shfited down.</span><span>
</span><span id="line-250"></span><span class="hs-comment">-- *  'These1' if the first item in the 'Steps' exists, and there are also</span><span>
</span><span id="line-251"></span><span class="hs-comment">--    more items left.  The extra items are all shifted down.</span><span>
</span><span id="line-252"></span><span class="hs-comment">--</span><span>
</span><span id="line-253"></span><span class="hs-comment">-- Forms an isomorphism with 'stepsUp' (see 'steppings').</span><span>
</span><span id="line-254"></span><span id="local-6989586621679480250"><span class="annot"><a href="Control.Applicative.Step.html#stepsDown"><span class="hs-identifier hs-type">stepsDown</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-type">Steps</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679480250"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">~&gt;</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">These1</span></span><span> </span><span class="annot"><a href="#local-6989586621679480250"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-type">Steps</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679480250"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-255"></span><span id="stepsDown"><span class="annot"><span class="annottext">stepsDown :: Steps f x -&gt; These1 f (Steps f) x
</span><a href="Control.Applicative.Step.html#stepsDown"><span class="hs-identifier hs-var hs-var">stepsDown</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(f x -&gt; These1 f (Steps f) x)
-&gt; (Steps f x -&gt; These1 f (Steps f) x)
-&gt; (f x -&gt; Steps f x -&gt; These1 f (Steps f) x)
-&gt; These (f x) (Steps f x)
-&gt; These1 f (Steps f) x
forall a c b.
(a -&gt; c) -&gt; (b -&gt; c) -&gt; (a -&gt; b -&gt; c) -&gt; These a b -&gt; c
</span><span class="hs-identifier hs-var">these</span></span><span> </span><span class="annot"><span class="annottext">f x -&gt; These1 f (Steps f) x
forall (f :: * -&gt; *) (g :: * -&gt; *) a. f a -&gt; These1 f g a
</span><span class="hs-identifier hs-var">This1</span></span><span> </span><span class="annot"><span class="annottext">Steps f x -&gt; These1 f (Steps f) x
forall (f :: * -&gt; *) (g :: * -&gt; *) a. g a -&gt; These1 f g a
</span><span class="hs-identifier hs-var">That1</span></span><span> </span><span class="annot"><span class="annottext">f x -&gt; Steps f x -&gt; These1 f (Steps f) x
forall (f :: * -&gt; *) (g :: * -&gt; *) a. f a -&gt; g a -&gt; These1 f g a
</span><span class="hs-identifier hs-var">These1</span></span><span>
</span><span id="line-256"></span><span>          </span><span class="annot"><span class="annottext">(These (f x) (Steps f x) -&gt; These1 f (Steps f) x)
-&gt; (Steps f x -&gt; These (f x) (Steps f x))
-&gt; Steps f x
-&gt; These1 f (Steps f) x
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">(First (f x) -&gt; f x)
-&gt; (NEMap Natural (f x) -&gt; Steps f x)
-&gt; These (First (f x)) (NEMap Natural (f x))
-&gt; These (f x) (Steps f x)
forall (p :: * -&gt; * -&gt; *) a b c d.
Bifunctor p =&gt;
(a -&gt; b) -&gt; (c -&gt; d) -&gt; p a c -&gt; p b d
</span><span class="hs-identifier hs-var">bimap</span></span><span> </span><span class="annot"><span class="annottext">First (f x) -&gt; f x
forall a. First a -&gt; a
</span><span class="hs-identifier hs-var hs-var">getFirst</span></span><span> </span><span class="annot"><span class="annottext">NEMap Natural (f x) -&gt; Steps f x
forall k (f :: k -&gt; *) (a :: k). NEMap Natural (f a) -&gt; Steps f a
</span><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-var">Steps</span></a></span><span>
</span><span id="line-257"></span><span>          </span><span class="annot"><span class="annottext">(These (First (f x)) (NEMap Natural (f x))
 -&gt; These (f x) (Steps f x))
-&gt; (Steps f x -&gt; These (First (f x)) (NEMap Natural (f x)))
-&gt; Steps f x
-&gt; These (f x) (Steps f x)
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">(Natural -&gt; f x -&gt; These (First (f x)) (NEMap Natural (f x)))
-&gt; NEMap Natural (f x) -&gt; These (First (f x)) (NEMap Natural (f x))
forall m k a. Semigroup m =&gt; (k -&gt; a -&gt; m) -&gt; NEMap k a -&gt; m
</span><span class="hs-identifier hs-var">NEM.foldMapWithKey</span></span><span> </span><span class="annot"><span class="annottext">Natural -&gt; f x -&gt; These (First (f x)) (NEMap Natural (f x))
forall k (f :: k -&gt; *) (a :: k).
Natural -&gt; f a -&gt; These (First (f a)) (NEMap Natural (f a))
</span><a href="Control.Applicative.Step.html#decr"><span class="hs-identifier hs-var">decr</span></a></span><span>
</span><span id="line-258"></span><span>          </span><span class="annot"><span class="annottext">(NEMap Natural (f x) -&gt; These (First (f x)) (NEMap Natural (f x)))
-&gt; (Steps f x -&gt; NEMap Natural (f x))
-&gt; Steps f x
-&gt; These (First (f x)) (NEMap Natural (f x))
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Steps f x -&gt; NEMap Natural (f x)
forall k (f :: k -&gt; *) (a :: k). Steps f a -&gt; NEMap Natural (f a)
</span><a href="Control.Applicative.Step.html#getSteps"><span class="hs-identifier hs-var hs-var">getSteps</span></a></span><span>
</span><span id="line-259"></span><span>
</span><span id="line-260"></span><span id="local-6989586621679480226"><span id="local-6989586621679480227"><span class="annot"><a href="Control.Applicative.Step.html#decr"><span class="hs-identifier hs-type">decr</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Natural</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679480227"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679480226"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">These</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">First</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679480227"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679480226"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">NEMap</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Natural</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679480227"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679480226"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span></span></span><span>
</span><span id="line-261"></span><span id="decr"><span class="annot"><span class="annottext">decr :: Natural -&gt; f a -&gt; These (First (f a)) (NEMap Natural (f a))
</span><a href="Control.Applicative.Step.html#decr"><span class="hs-identifier hs-var hs-var">decr</span></a></span></span><span> </span><span id="local-6989586621679479338"><span class="annot"><span class="annottext">i :: Natural
</span><a href="#local-6989586621679479338"><span class="hs-identifier hs-var">i</span></a></span></span><span> </span><span id="local-6989586621679479337"><span class="annot"><span class="annottext">x :: f a
</span><a href="#local-6989586621679479337"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Natural -&gt; Natural -&gt; Maybe Natural
</span><span class="hs-identifier hs-var">minusNaturalMaybe</span></span><span> </span><span class="annot"><span class="annottext">Natural
</span><a href="#local-6989586621679479338"><span class="hs-identifier hs-var">i</span></a></span><span> </span><span class="annot"><span class="hs-number">1</span></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-262"></span><span>      </span><span class="annot"><span class="hs-identifier hs-type">Nothing</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">First (f a) -&gt; These (First (f a)) (NEMap Natural (f a))
forall a b. a -&gt; These a b
</span><span class="hs-identifier hs-var">This</span></span><span> </span><span class="annot"><span class="annottext">(First (f a) -&gt; These (First (f a)) (NEMap Natural (f a)))
-&gt; First (f a) -&gt; These (First (f a)) (NEMap Natural (f a))
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">f a -&gt; First (f a)
forall a. a -&gt; First a
</span><span class="hs-identifier hs-var">First</span></span><span> </span><span class="annot"><span class="annottext">f a
</span><a href="#local-6989586621679479337"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-263"></span><span>      </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621679479334"><span class="annot"><span class="annottext">i' :: Natural
</span><a href="#local-6989586621679479334"><span class="hs-identifier hs-var">i'</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">NEMap Natural (f a) -&gt; These (First (f a)) (NEMap Natural (f a))
forall a b. b -&gt; These a b
</span><span class="hs-identifier hs-var">That</span></span><span> </span><span class="annot"><span class="annottext">(NEMap Natural (f a) -&gt; These (First (f a)) (NEMap Natural (f a)))
-&gt; NEMap Natural (f a) -&gt; These (First (f a)) (NEMap Natural (f a))
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Natural -&gt; f a -&gt; NEMap Natural (f a)
forall k a. k -&gt; a -&gt; NEMap k a
</span><span class="hs-identifier hs-var">NEM.singleton</span></span><span> </span><span class="annot"><span class="annottext">Natural
</span><a href="#local-6989586621679479334"><span class="hs-identifier hs-var">i'</span></a></span><span> </span><span class="annot"><span class="annottext">f a
</span><a href="#local-6989586621679479337"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-264"></span><span>
</span><span id="line-265"></span><span class="hs-comment">-- | Unshift an item into a 'Steps'.  Because a @'Steps' f@ is @f `These1`</span><span>
</span><span id="line-266"></span><span class="hs-comment">-- f `These1` f `These1` f `These1` ...@ forever, this basically conses an</span><span>
</span><span id="line-267"></span><span class="hs-comment">-- additional possibility of @f@ to the beginning of it all.</span><span>
</span><span id="line-268"></span><span class="hs-comment">--</span><span>
</span><span id="line-269"></span><span class="hs-comment">-- You can think of it as reassociating</span><span>
</span><span id="line-270"></span><span class="hs-comment">--</span><span>
</span><span id="line-271"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-272"></span><span class="hs-comment">-- f `These1` ( f `These1` f `These1` f `These1` ...)</span><span>
</span><span id="line-273"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-274"></span><span class="hs-comment">--</span><span>
</span><span id="line-275"></span><span class="hs-comment">-- into</span><span>
</span><span id="line-276"></span><span class="hs-comment">--</span><span>
</span><span id="line-277"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-278"></span><span class="hs-comment">-- f `These1` f `These1` f `These1` f `These1` ...</span><span>
</span><span id="line-279"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-280"></span><span class="hs-comment">--</span><span>
</span><span id="line-281"></span><span class="hs-comment">-- If you give:</span><span>
</span><span id="line-282"></span><span class="hs-comment">--</span><span>
</span><span id="line-283"></span><span class="hs-comment">-- *  'This1', then it returns a singleton 'Steps' with one item at</span><span>
</span><span id="line-284"></span><span class="hs-comment">--    index 0</span><span>
</span><span id="line-285"></span><span class="hs-comment">-- *  'That1', then it shifts every item in the given 'Steps' up one</span><span>
</span><span id="line-286"></span><span class="hs-comment">--    index.</span><span>
</span><span id="line-287"></span><span class="hs-comment">-- *  'These1', then it shifts every item in the given 'Steps' up one</span><span>
</span><span id="line-288"></span><span class="hs-comment">--    index, and adds the given item (the @f@) at index zero.</span><span>
</span><span id="line-289"></span><span class="hs-comment">--</span><span>
</span><span id="line-290"></span><span class="hs-comment">-- Forms an isomorphism with 'stepDown' (see 'stepping').</span><span>
</span><span id="line-291"></span><span id="local-6989586621679480249"><span class="annot"><a href="Control.Applicative.Step.html#stepsUp"><span class="hs-identifier hs-type">stepsUp</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">These1</span></span><span> </span><span class="annot"><a href="#local-6989586621679480249"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-type">Steps</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679480249"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="hs-operator hs-type">~&gt;</span></span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-type">Steps</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679480249"><span class="hs-identifier hs-type">f</span></a></span></span><span>
</span><span id="line-292"></span><span id="stepsUp"><span class="annot"><span class="annottext">stepsUp :: These1 f (Steps f) x -&gt; Steps f x
</span><a href="Control.Applicative.Step.html#stepsUp"><span class="hs-identifier hs-var hs-var">stepsUp</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-293"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">This1</span></span><span>  </span><span id="local-6989586621679479332"><span class="annot"><span class="annottext">x :: f x
</span><a href="#local-6989586621679479332"><span class="hs-identifier hs-var">x</span></a></span></span><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">NEMap Natural (f x) -&gt; Steps f x
forall k (f :: k -&gt; *) (a :: k). NEMap Natural (f a) -&gt; Steps f a
</span><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-var">Steps</span></a></span><span> </span><span class="annot"><span class="annottext">(NEMap Natural (f x) -&gt; Steps f x)
-&gt; NEMap Natural (f x) -&gt; Steps f x
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Natural -&gt; f x -&gt; NEMap Natural (f x)
forall k a. k -&gt; a -&gt; NEMap k a
</span><span class="hs-identifier hs-var">NEM.singleton</span></span><span> </span><span class="annot"><span class="hs-number">0</span></span><span> </span><span class="annot"><span class="annottext">f x
</span><a href="#local-6989586621679479332"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-294"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">That1</span></span><span>    </span><span id="local-6989586621679479331"><span class="annot"><span class="annottext">xs :: Steps f x
</span><a href="#local-6989586621679479331"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">NEMap Natural (f x) -&gt; Steps f x
forall k (f :: k -&gt; *) (a :: k). NEMap Natural (f a) -&gt; Steps f a
</span><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-var">Steps</span></a></span><span> </span><span class="annot"><span class="annottext">(NEMap Natural (f x) -&gt; Steps f x)
-&gt; (Steps f x -&gt; NEMap Natural (f x)) -&gt; Steps f x -&gt; Steps f x
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">(Natural -&gt; Natural) -&gt; NEMap Natural (f x) -&gt; NEMap Natural (f x)
forall k1 k2 a. (k1 -&gt; k2) -&gt; NEMap k1 a -&gt; NEMap k2 a
</span><span class="hs-identifier hs-var">NEM.mapKeysMonotonic</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Natural -&gt; Natural -&gt; Natural
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">+</span></span><span> </span><span class="annot"><span class="hs-number">1</span></span><span class="hs-special">)</span><span>
</span><span id="line-295"></span><span>                         </span><span class="annot"><span class="annottext">(NEMap Natural (f x) -&gt; NEMap Natural (f x))
-&gt; (Steps f x -&gt; NEMap Natural (f x))
-&gt; Steps f x
-&gt; NEMap Natural (f x)
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Steps f x -&gt; NEMap Natural (f x)
forall k (f :: k -&gt; *) (a :: k). Steps f a -&gt; NEMap Natural (f a)
</span><a href="Control.Applicative.Step.html#getSteps"><span class="hs-identifier hs-var hs-var">getSteps</span></a></span><span>
</span><span id="line-296"></span><span>                         </span><span class="annot"><span class="annottext">(Steps f x -&gt; Steps f x) -&gt; Steps f x -&gt; Steps f x
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Steps f x
</span><a href="#local-6989586621679479331"><span class="hs-identifier hs-var">xs</span></a></span><span>
</span><span id="line-297"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">These1</span></span><span> </span><span id="local-6989586621679479330"><span class="annot"><span class="annottext">x :: f x
</span><a href="#local-6989586621679479330"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679479329"><span class="annot"><span class="annottext">xs :: Steps f x
</span><a href="#local-6989586621679479329"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">NEMap Natural (f x) -&gt; Steps f x
forall k (f :: k -&gt; *) (a :: k). NEMap Natural (f a) -&gt; Steps f a
</span><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-var">Steps</span></a></span><span> </span><span class="annot"><span class="annottext">(NEMap Natural (f x) -&gt; Steps f x)
-&gt; (Steps f x -&gt; NEMap Natural (f x)) -&gt; Steps f x -&gt; Steps f x
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Natural -&gt; f x -&gt; Map Natural (f x) -&gt; NEMap Natural (f x)
forall k a. k -&gt; a -&gt; Map k a -&gt; NEMap k a
</span><span class="hs-identifier hs-var">NEM.insertMapMin</span></span><span> </span><span class="annot"><span class="hs-number">0</span></span><span> </span><span class="annot"><span class="annottext">f x
</span><a href="#local-6989586621679479330"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-298"></span><span>                         </span><span class="annot"><span class="annottext">(Map Natural (f x) -&gt; NEMap Natural (f x))
-&gt; (Steps f x -&gt; Map Natural (f x))
-&gt; Steps f x
-&gt; NEMap Natural (f x)
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">NEMap Natural (f x) -&gt; Map Natural (f x)
forall k a. NEMap k a -&gt; Map k a
</span><span class="hs-identifier hs-var">NEM.toMap</span></span><span>
</span><span id="line-299"></span><span>                         </span><span class="annot"><span class="annottext">(NEMap Natural (f x) -&gt; Map Natural (f x))
-&gt; (Steps f x -&gt; NEMap Natural (f x))
-&gt; Steps f x
-&gt; Map Natural (f x)
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">(Natural -&gt; Natural) -&gt; NEMap Natural (f x) -&gt; NEMap Natural (f x)
forall k1 k2 a. (k1 -&gt; k2) -&gt; NEMap k1 a -&gt; NEMap k2 a
</span><span class="hs-identifier hs-var">NEM.mapKeysMonotonic</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Natural -&gt; Natural -&gt; Natural
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">+</span></span><span> </span><span class="annot"><span class="hs-number">1</span></span><span class="hs-special">)</span><span>
</span><span id="line-300"></span><span>                         </span><span class="annot"><span class="annottext">(NEMap Natural (f x) -&gt; NEMap Natural (f x))
-&gt; (Steps f x -&gt; NEMap Natural (f x))
-&gt; Steps f x
-&gt; NEMap Natural (f x)
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Steps f x -&gt; NEMap Natural (f x)
forall k (f :: k -&gt; *) (a :: k). Steps f a -&gt; NEMap Natural (f a)
</span><a href="Control.Applicative.Step.html#getSteps"><span class="hs-identifier hs-var hs-var">getSteps</span></a></span><span>
</span><span id="line-301"></span><span>                         </span><span class="annot"><span class="annottext">(Steps f x -&gt; Steps f x) -&gt; Steps f x -&gt; Steps f x
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Steps f x
</span><a href="#local-6989586621679479329"><span class="hs-identifier hs-var">xs</span></a></span><span>
</span><span id="line-302"></span><span>
</span><span id="line-303"></span><span>
</span><span id="line-304"></span><span class="hs-comment">-- | An @f a@, along with a 'Bool' flag</span><span>
</span><span id="line-305"></span><span class="hs-comment">--</span><span>
</span><span id="line-306"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-307"></span><span class="hs-comment">-- 'Flagged' f a ~ ('Bool', f a)</span><span>
</span><span id="line-308"></span><span class="hs-comment">-- Flagged f   ~ ((,) Bool) ':.:' f       -- functor composition</span><span>
</span><span id="line-309"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-310"></span><span class="hs-comment">--</span><span>
</span><span id="line-311"></span><span class="hs-comment">-- Creation with 'Data.HFunctor.inject' or 'pure' uses 'False' as the</span><span>
</span><span id="line-312"></span><span class="hs-comment">-- boolean.</span><span>
</span><span id="line-313"></span><span class="hs-comment">--</span><span>
</span><span id="line-314"></span><span class="hs-comment">-- You can think of it as an @f a@ that is &quot;flagged&quot; with a boolean value,</span><span>
</span><span id="line-315"></span><span class="hs-comment">-- and that value can indicuate whether or not it is &quot;pure&quot; (made with</span><span>
</span><span id="line-316"></span><span class="hs-comment">-- 'Data.HFunctor.inject' or 'pure') as 'False', or &quot;impure&quot;</span><span>
</span><span id="line-317"></span><span class="hs-comment">-- (made from some other source) as 'True'.  However, 'False' may be always</span><span>
</span><span id="line-318"></span><span class="hs-comment">-- created directly, of course, using the constructor.</span><span>
</span><span id="line-319"></span><span class="hs-comment">--</span><span>
</span><span id="line-320"></span><span class="hs-comment">-- You can think of it like a 'Step' that is either 0 or 1, as well.</span><span>
</span><span id="line-321"></span><span class="hs-comment">--</span><span>
</span><span id="line-322"></span><span class="hs-comment">-- 'Data.HFunctor.Interpret.interpret'ing it requires no constraint on the</span><span>
</span><span id="line-323"></span><span class="hs-comment">-- target context.</span><span>
</span><span id="line-324"></span><span class="hs-comment">--</span><span>
</span><span id="line-325"></span><span class="hs-comment">-- This type is equivalent (along with its instances) to:</span><span>
</span><span id="line-326"></span><span class="hs-comment">--</span><span>
</span><span id="line-327"></span><span class="hs-comment">-- *   @'Data.HFunctor.HLift' 'Control.Monad.Trans.Identity.IdentityT'@</span><span>
</span><span id="line-328"></span><span class="hs-comment">-- *   @'Control.COmonad.Trans.Env.EnvT' 'Data.Semigroup.Any'@</span><span>
</span><span id="line-329"></span><span id="local-6989586621679479325"><span id="local-6989586621679479326"></span></span><span class="hs-keyword">data</span><span> </span><span id="Flagged"><span class="annot"><a href="Control.Applicative.Step.html#Flagged"><span class="hs-identifier hs-var">Flagged</span></a></span></span><span> </span><span id="local-6989586621679480107"><span class="annot"><a href="#local-6989586621679480107"><span class="hs-identifier hs-type">f</span></a></span></span><span> </span><span id="local-6989586621679480106"><span class="annot"><a href="#local-6989586621679480106"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="Flagged"><span class="annot"><a href="Control.Applicative.Step.html#Flagged"><span class="hs-identifier hs-var">Flagged</span></a></span></span><span> </span><span class="hs-special">{</span><span> </span><span id="flaggedFlag"><span class="annot"><span class="annottext">Flagged f a -&gt; Bool
</span><a href="Control.Applicative.Step.html#flaggedFlag"><span class="hs-identifier hs-var hs-var">flaggedFlag</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span class="hs-special">,</span><span> </span><span id="flaggedVal"><span class="annot"><span class="annottext">Flagged f a -&gt; f a
</span><a href="Control.Applicative.Step.html#flaggedVal"><span class="hs-identifier hs-var hs-var">flaggedVal</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621679480107"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679480106"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-330"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679479316"><span id="local-6989586621679479318"><span id="local-6989586621679479320"><span class="annot"><span class="annottext">Int -&gt; Flagged f a -&gt; ShowS
[Flagged f a] -&gt; ShowS
Flagged f a -&gt; String
(Int -&gt; Flagged f a -&gt; ShowS)
-&gt; (Flagged f a -&gt; String)
-&gt; ([Flagged f a] -&gt; ShowS)
-&gt; Show (Flagged f a)
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
forall k (f :: k -&gt; *) (a :: k).
Show (f a) =&gt;
Int -&gt; Flagged f a -&gt; ShowS
forall k (f :: k -&gt; *) (a :: k).
Show (f a) =&gt;
[Flagged f a] -&gt; ShowS
forall k (f :: k -&gt; *) (a :: k).
Show (f a) =&gt;
Flagged f a -&gt; String
showList :: [Flagged f a] -&gt; ShowS
$cshowList :: forall k (f :: k -&gt; *) (a :: k).
Show (f a) =&gt;
[Flagged f a] -&gt; ShowS
show :: Flagged f a -&gt; String
$cshow :: forall k (f :: k -&gt; *) (a :: k).
Show (f a) =&gt;
Flagged f a -&gt; String
showsPrec :: Int -&gt; Flagged f a -&gt; ShowS
$cshowsPrec :: forall k (f :: k -&gt; *) (a :: k).
Show (f a) =&gt;
Int -&gt; Flagged f a -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679479308"><span id="local-6989586621679479310"><span id="local-6989586621679479312"><span id="local-6989586621679479314"><span class="annot"><span class="annottext">ReadPrec [Flagged f a]
ReadPrec (Flagged f a)
Int -&gt; ReadS (Flagged f a)
ReadS [Flagged f a]
(Int -&gt; ReadS (Flagged f a))
-&gt; ReadS [Flagged f a]
-&gt; ReadPrec (Flagged f a)
-&gt; ReadPrec [Flagged f a]
-&gt; Read (Flagged f a)
forall a.
(Int -&gt; ReadS a)
-&gt; ReadS [a] -&gt; ReadPrec a -&gt; ReadPrec [a] -&gt; Read a
forall k (f :: k -&gt; *) (a :: k).
Read (f a) =&gt;
ReadPrec [Flagged f a]
forall k (f :: k -&gt; *) (a :: k).
Read (f a) =&gt;
ReadPrec (Flagged f a)
forall k (f :: k -&gt; *) (a :: k).
Read (f a) =&gt;
Int -&gt; ReadS (Flagged f a)
forall k (f :: k -&gt; *) (a :: k). Read (f a) =&gt; ReadS [Flagged f a]
readListPrec :: ReadPrec [Flagged f a]
$creadListPrec :: forall k (f :: k -&gt; *) (a :: k).
Read (f a) =&gt;
ReadPrec [Flagged f a]
readPrec :: ReadPrec (Flagged f a)
$creadPrec :: forall k (f :: k -&gt; *) (a :: k).
Read (f a) =&gt;
ReadPrec (Flagged f a)
readList :: ReadS [Flagged f a]
$creadList :: forall k (f :: k -&gt; *) (a :: k). Read (f a) =&gt; ReadS [Flagged f a]
readsPrec :: Int -&gt; ReadS (Flagged f a)
$creadsPrec :: forall k (f :: k -&gt; *) (a :: k).
Read (f a) =&gt;
Int -&gt; ReadS (Flagged f a)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Read</span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679479304"><span id="local-6989586621679479306"><span class="annot"><span class="annottext">Flagged f a -&gt; Flagged f a -&gt; Bool
(Flagged f a -&gt; Flagged f a -&gt; Bool)
-&gt; (Flagged f a -&gt; Flagged f a -&gt; Bool) -&gt; Eq (Flagged f a)
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
forall k (f :: k -&gt; *) (a :: k).
Eq (f a) =&gt;
Flagged f a -&gt; Flagged f a -&gt; Bool
/= :: Flagged f a -&gt; Flagged f a -&gt; Bool
$c/= :: forall k (f :: k -&gt; *) (a :: k).
Eq (f a) =&gt;
Flagged f a -&gt; Flagged f a -&gt; Bool
== :: Flagged f a -&gt; Flagged f a -&gt; Bool
$c== :: forall k (f :: k -&gt; *) (a :: k).
Eq (f a) =&gt;
Flagged f a -&gt; Flagged f a -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679479289"><span id="local-6989586621679479291"><span id="local-6989586621679479293"><span id="local-6989586621679479295"><span id="local-6989586621679479297"><span id="local-6989586621679479299"><span id="local-6989586621679479301"><span class="annot"><span class="annottext">Eq (Flagged f a)
Eq (Flagged f a) =&gt;
(Flagged f a -&gt; Flagged f a -&gt; Ordering)
-&gt; (Flagged f a -&gt; Flagged f a -&gt; Bool)
-&gt; (Flagged f a -&gt; Flagged f a -&gt; Bool)
-&gt; (Flagged f a -&gt; Flagged f a -&gt; Bool)
-&gt; (Flagged f a -&gt; Flagged f a -&gt; Bool)
-&gt; (Flagged f a -&gt; Flagged f a -&gt; Flagged f a)
-&gt; (Flagged f a -&gt; Flagged f a -&gt; Flagged f a)
-&gt; Ord (Flagged f a)
Flagged f a -&gt; Flagged f a -&gt; Bool
Flagged f a -&gt; Flagged f a -&gt; Ordering
Flagged f a -&gt; Flagged f a -&gt; Flagged f a
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall k (f :: k -&gt; *) (a :: k). Ord (f a) =&gt; Eq (Flagged f a)
forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Flagged f a -&gt; Flagged f a -&gt; Bool
forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Flagged f a -&gt; Flagged f a -&gt; Ordering
forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Flagged f a -&gt; Flagged f a -&gt; Flagged f a
min :: Flagged f a -&gt; Flagged f a -&gt; Flagged f a
$cmin :: forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Flagged f a -&gt; Flagged f a -&gt; Flagged f a
max :: Flagged f a -&gt; Flagged f a -&gt; Flagged f a
$cmax :: forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Flagged f a -&gt; Flagged f a -&gt; Flagged f a
&gt;= :: Flagged f a -&gt; Flagged f a -&gt; Bool
$c&gt;= :: forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Flagged f a -&gt; Flagged f a -&gt; Bool
&gt; :: Flagged f a -&gt; Flagged f a -&gt; Bool
$c&gt; :: forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Flagged f a -&gt; Flagged f a -&gt; Bool
&lt;= :: Flagged f a -&gt; Flagged f a -&gt; Bool
$c&lt;= :: forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Flagged f a -&gt; Flagged f a -&gt; Bool
&lt; :: Flagged f a -&gt; Flagged f a -&gt; Bool
$c&lt; :: forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Flagged f a -&gt; Flagged f a -&gt; Bool
compare :: Flagged f a -&gt; Flagged f a -&gt; Ordering
$ccompare :: forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Flagged f a -&gt; Flagged f a -&gt; Ordering
$cp1Ord :: forall k (f :: k -&gt; *) (a :: k). Ord (f a) =&gt; Eq (Flagged f a)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679479285"><span id="local-6989586621679479287"><span class="annot"><span class="annottext">a -&gt; Flagged f b -&gt; Flagged f a
(a -&gt; b) -&gt; Flagged f a -&gt; Flagged f b
(forall a b. (a -&gt; b) -&gt; Flagged f a -&gt; Flagged f b)
-&gt; (forall a b. a -&gt; Flagged f b -&gt; Flagged f a)
-&gt; Functor (Flagged f)
forall a b. a -&gt; Flagged f b -&gt; Flagged f a
forall a b. (a -&gt; b) -&gt; Flagged f a -&gt; Flagged f b
forall (f :: * -&gt; *) a b.
Functor f =&gt;
a -&gt; Flagged f b -&gt; Flagged f a
forall (f :: * -&gt; *) a b.
Functor f =&gt;
(a -&gt; b) -&gt; Flagged f a -&gt; Flagged f b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: a -&gt; Flagged f b -&gt; Flagged f a
$c&lt;$ :: forall (f :: * -&gt; *) a b.
Functor f =&gt;
a -&gt; Flagged f b -&gt; Flagged f a
fmap :: (a -&gt; b) -&gt; Flagged f a -&gt; Flagged f b
$cfmap :: forall (f :: * -&gt; *) a b.
Functor f =&gt;
(a -&gt; b) -&gt; Flagged f a -&gt; Flagged f b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679479251"><span id="local-6989586621679479253"><span id="local-6989586621679479255"><span id="local-6989586621679479257"><span id="local-6989586621679479259"><span id="local-6989586621679479261"><span id="local-6989586621679479263"><span id="local-6989586621679479265"><span id="local-6989586621679479267"><span id="local-6989586621679479269"><span id="local-6989586621679479271"><span id="local-6989586621679479273"><span id="local-6989586621679479275"><span id="local-6989586621679479277"><span id="local-6989586621679479279"><span id="local-6989586621679479281"><span id="local-6989586621679479283"><span class="annot"><span class="annottext">Flagged f a -&gt; Bool
(a -&gt; m) -&gt; Flagged f a -&gt; m
(a -&gt; b -&gt; b) -&gt; b -&gt; Flagged f a -&gt; b
(forall m. Monoid m =&gt; Flagged f m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Flagged f a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Flagged f a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Flagged f a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Flagged f a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Flagged f a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Flagged f a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; Flagged f a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; Flagged f a -&gt; a)
-&gt; (forall a. Flagged f a -&gt; [a])
-&gt; (forall a. Flagged f a -&gt; Bool)
-&gt; (forall a. Flagged f a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; Flagged f a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; Flagged f a -&gt; a)
-&gt; (forall a. Ord a =&gt; Flagged f a -&gt; a)
-&gt; (forall a. Num a =&gt; Flagged f a -&gt; a)
-&gt; (forall a. Num a =&gt; Flagged f a -&gt; a)
-&gt; Foldable (Flagged f)
forall a. Eq a =&gt; a -&gt; Flagged f a -&gt; Bool
forall a. Num a =&gt; Flagged f a -&gt; a
forall a. Ord a =&gt; Flagged f a -&gt; a
forall m. Monoid m =&gt; Flagged f m -&gt; m
forall a. Flagged f a -&gt; Bool
forall a. Flagged f a -&gt; Int
forall a. Flagged f a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; Flagged f a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Flagged f a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Flagged f a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Flagged f a -&gt; b
forall (f :: * -&gt; *) a.
(Foldable f, Eq a) =&gt;
a -&gt; Flagged f a -&gt; Bool
forall (f :: * -&gt; *) a. (Foldable f, Num a) =&gt; Flagged f a -&gt; a
forall (f :: * -&gt; *) a. (Foldable f, Ord a) =&gt; Flagged f a -&gt; a
forall (f :: * -&gt; *) m. (Foldable f, Monoid m) =&gt; Flagged f m -&gt; m
forall (f :: * -&gt; *) a. Foldable f =&gt; Flagged f a -&gt; Bool
forall (f :: * -&gt; *) a. Foldable f =&gt; Flagged f a -&gt; Int
forall (f :: * -&gt; *) a. Foldable f =&gt; Flagged f a -&gt; [a]
forall (f :: * -&gt; *) a.
Foldable f =&gt;
(a -&gt; a -&gt; a) -&gt; Flagged f a -&gt; a
forall (f :: * -&gt; *) m a.
(Foldable f, Monoid m) =&gt;
(a -&gt; m) -&gt; Flagged f a -&gt; m
forall (f :: * -&gt; *) b a.
Foldable f =&gt;
(b -&gt; a -&gt; b) -&gt; b -&gt; Flagged f a -&gt; b
forall (f :: * -&gt; *) a b.
Foldable f =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; Flagged f a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: Flagged f a -&gt; a
$cproduct :: forall (f :: * -&gt; *) a. (Foldable f, Num a) =&gt; Flagged f a -&gt; a
sum :: Flagged f a -&gt; a
$csum :: forall (f :: * -&gt; *) a. (Foldable f, Num a) =&gt; Flagged f a -&gt; a
minimum :: Flagged f a -&gt; a
$cminimum :: forall (f :: * -&gt; *) a. (Foldable f, Ord a) =&gt; Flagged f a -&gt; a
maximum :: Flagged f a -&gt; a
$cmaximum :: forall (f :: * -&gt; *) a. (Foldable f, Ord a) =&gt; Flagged f a -&gt; a
elem :: a -&gt; Flagged f a -&gt; Bool
$celem :: forall (f :: * -&gt; *) a.
(Foldable f, Eq a) =&gt;
a -&gt; Flagged f a -&gt; Bool
length :: Flagged f a -&gt; Int
$clength :: forall (f :: * -&gt; *) a. Foldable f =&gt; Flagged f a -&gt; Int
null :: Flagged f a -&gt; Bool
$cnull :: forall (f :: * -&gt; *) a. Foldable f =&gt; Flagged f a -&gt; Bool
toList :: Flagged f a -&gt; [a]
$ctoList :: forall (f :: * -&gt; *) a. Foldable f =&gt; Flagged f a -&gt; [a]
foldl1 :: (a -&gt; a -&gt; a) -&gt; Flagged f a -&gt; a
$cfoldl1 :: forall (f :: * -&gt; *) a.
Foldable f =&gt;
(a -&gt; a -&gt; a) -&gt; Flagged f a -&gt; a
foldr1 :: (a -&gt; a -&gt; a) -&gt; Flagged f a -&gt; a
$cfoldr1 :: forall (f :: * -&gt; *) a.
Foldable f =&gt;
(a -&gt; a -&gt; a) -&gt; Flagged f a -&gt; a
foldl' :: (b -&gt; a -&gt; b) -&gt; b -&gt; Flagged f a -&gt; b
$cfoldl' :: forall (f :: * -&gt; *) b a.
Foldable f =&gt;
(b -&gt; a -&gt; b) -&gt; b -&gt; Flagged f a -&gt; b
foldl :: (b -&gt; a -&gt; b) -&gt; b -&gt; Flagged f a -&gt; b
$cfoldl :: forall (f :: * -&gt; *) b a.
Foldable f =&gt;
(b -&gt; a -&gt; b) -&gt; b -&gt; Flagged f a -&gt; b
foldr' :: (a -&gt; b -&gt; b) -&gt; b -&gt; Flagged f a -&gt; b
$cfoldr' :: forall (f :: * -&gt; *) a b.
Foldable f =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; Flagged f a -&gt; b
foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; Flagged f a -&gt; b
$cfoldr :: forall (f :: * -&gt; *) a b.
Foldable f =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; Flagged f a -&gt; b
foldMap' :: (a -&gt; m) -&gt; Flagged f a -&gt; m
$cfoldMap' :: forall (f :: * -&gt; *) m a.
(Foldable f, Monoid m) =&gt;
(a -&gt; m) -&gt; Flagged f a -&gt; m
foldMap :: (a -&gt; m) -&gt; Flagged f a -&gt; m
$cfoldMap :: forall (f :: * -&gt; *) m a.
(Foldable f, Monoid m) =&gt;
(a -&gt; m) -&gt; Flagged f a -&gt; m
fold :: Flagged f m -&gt; m
$cfold :: forall (f :: * -&gt; *) m. (Foldable f, Monoid m) =&gt; Flagged f m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679479241"><span id="local-6989586621679479243"><span id="local-6989586621679479245"><span id="local-6989586621679479247"><span class="annot"><span class="annottext">Functor (Flagged f)
Foldable (Flagged f)
(Functor (Flagged f), Foldable (Flagged f)) =&gt;
(forall (f :: * -&gt; *) a b.
 Applicative f =&gt;
 (a -&gt; f b) -&gt; Flagged f a -&gt; f (Flagged f b))
-&gt; (forall (f :: * -&gt; *) a.
    Applicative f =&gt;
    Flagged f (f a) -&gt; f (Flagged f a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; Flagged f a -&gt; m (Flagged f b))
-&gt; (forall (m :: * -&gt; *) a.
    Monad m =&gt;
    Flagged f (m a) -&gt; m (Flagged f a))
-&gt; Traversable (Flagged f)
(a -&gt; f b) -&gt; Flagged f a -&gt; f (Flagged f b)
forall (t :: * -&gt; *).
(Functor t, Foldable t) =&gt;
(forall (f :: * -&gt; *) a b.
 Applicative f =&gt;
 (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (f :: * -&gt; *). Traversable f =&gt; Functor (Flagged f)
forall (f :: * -&gt; *). Traversable f =&gt; Foldable (Flagged f)
forall (f :: * -&gt; *) (m :: * -&gt; *) a.
(Traversable f, Monad m) =&gt;
Flagged f (m a) -&gt; m (Flagged f a)
forall (f :: * -&gt; *) (f :: * -&gt; *) a.
(Traversable f, Applicative f) =&gt;
Flagged f (f a) -&gt; f (Flagged f a)
forall (f :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable f, Monad m) =&gt;
(a -&gt; m b) -&gt; Flagged f a -&gt; m (Flagged f b)
forall (f :: * -&gt; *) (f :: * -&gt; *) a b.
(Traversable f, Applicative f) =&gt;
(a -&gt; f b) -&gt; Flagged f a -&gt; f (Flagged f b)
forall (m :: * -&gt; *) a.
Monad m =&gt;
Flagged f (m a) -&gt; m (Flagged f a)
forall (f :: * -&gt; *) a.
Applicative f =&gt;
Flagged f (f a) -&gt; f (Flagged f a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Flagged f a -&gt; m (Flagged f b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Flagged f a -&gt; f (Flagged f b)
sequence :: Flagged f (m a) -&gt; m (Flagged f a)
$csequence :: forall (f :: * -&gt; *) (m :: * -&gt; *) a.
(Traversable f, Monad m) =&gt;
Flagged f (m a) -&gt; m (Flagged f a)
mapM :: (a -&gt; m b) -&gt; Flagged f a -&gt; m (Flagged f b)
$cmapM :: forall (f :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable f, Monad m) =&gt;
(a -&gt; m b) -&gt; Flagged f a -&gt; m (Flagged f b)
sequenceA :: Flagged f (f a) -&gt; f (Flagged f a)
$csequenceA :: forall (f :: * -&gt; *) (f :: * -&gt; *) a.
(Traversable f, Applicative f) =&gt;
Flagged f (f a) -&gt; f (Flagged f a)
traverse :: (a -&gt; f b) -&gt; Flagged f a -&gt; f (Flagged f b)
$ctraverse :: forall (f :: * -&gt; *) (f :: * -&gt; *) a b.
(Traversable f, Applicative f) =&gt;
(a -&gt; f b) -&gt; Flagged f a -&gt; f (Flagged f b)
$cp2Traversable :: forall (f :: * -&gt; *). Traversable f =&gt; Foldable (Flagged f)
$cp1Traversable :: forall (f :: * -&gt; *). Traversable f =&gt; Functor (Flagged f)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">(forall x. Flagged f a -&gt; Rep (Flagged f a) x)
-&gt; (forall x. Rep (Flagged f a) x -&gt; Flagged f a)
-&gt; Generic (Flagged f a)
forall x. Rep (Flagged f a) x -&gt; Flagged f a
forall x. Flagged f a -&gt; Rep (Flagged f a) x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall k (f :: k -&gt; *) (a :: k) x.
Rep (Flagged f a) x -&gt; Flagged f a
forall k (f :: k -&gt; *) (a :: k) x.
Flagged f a -&gt; Rep (Flagged f a) x
$cto :: forall k (f :: k -&gt; *) (a :: k) x.
Rep (Flagged f a) x -&gt; Flagged f a
$cfrom :: forall k (f :: k -&gt; *) (a :: k) x.
Flagged f a -&gt; Rep (Flagged f a) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">,</span><span> </span><span id="%24cFlagged"><span id="%24tFlagged"><span id="local-6989586621679479210"><span id="local-6989586621679479212"><span id="local-6989586621679479214"><span id="local-6989586621679479216"><span id="local-6989586621679479218"><span id="local-6989586621679479220"><span id="local-6989586621679479222"><span id="local-6989586621679479224"><span id="local-6989586621679479226"><span id="local-6989586621679479228"><span id="local-6989586621679479230"><span id="local-6989586621679479232"><span id="local-6989586621679479234"><span id="local-6989586621679479236"><span class="annot"><span class="annottext">Typeable (Flagged f a)
DataType
Constr
Typeable (Flagged f a) =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; Flagged f a -&gt; c (Flagged f a))
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Flagged f a))
-&gt; (Flagged f a -&gt; Constr)
-&gt; (Flagged f a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Flagged f a)))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e))
    -&gt; Maybe (c (Flagged f a)))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; Flagged f a -&gt; Flagged f a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Flagged f a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Flagged f a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Flagged f a -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Flagged f a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Flagged f a -&gt; m (Flagged f a))
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Flagged f a -&gt; m (Flagged f a))
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Flagged f a -&gt; m (Flagged f a))
-&gt; Data (Flagged f a)
Flagged f a -&gt; DataType
Flagged f a -&gt; Constr
(forall b. Data b =&gt; b -&gt; b) -&gt; Flagged f a -&gt; Flagged f a
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Flagged f a -&gt; c (Flagged f a)
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Flagged f a)
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Flagged f a -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Flagged f a -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Flagged f a -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Flagged f a -&gt; r
forall k (f :: k -&gt; *) (a :: k).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
Typeable (Flagged f a)
forall k (f :: k -&gt; *) (a :: k).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
Flagged f a -&gt; DataType
forall k (f :: k -&gt; *) (a :: k).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
Flagged f a -&gt; Constr
forall k (f :: k -&gt; *) (a :: k).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Flagged f a -&gt; Flagged f a
forall k (f :: k -&gt; *) (a :: k) u.
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Flagged f a -&gt; u
forall k (f :: k -&gt; *) (a :: k) u.
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; Flagged f a -&gt; [u]
forall k (f :: k -&gt; *) (a :: k) r r'.
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Flagged f a -&gt; r
forall k (f :: k -&gt; *) (a :: k) r r'.
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Flagged f a -&gt; r
forall k (f :: k -&gt; *) (a :: k) (m :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Flagged f a -&gt; m (Flagged f a)
forall k (f :: k -&gt; *) (a :: k) (m :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Flagged f a -&gt; m (Flagged f a)
forall k (f :: k -&gt; *) (a :: k) (c :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Flagged f a)
forall k (f :: k -&gt; *) (a :: k) (c :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Flagged f a -&gt; c (Flagged f a)
forall k (f :: k -&gt; *) (a :: k) (t :: * -&gt; *) (c :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Flagged f a))
forall k (f :: k -&gt; *) (a :: k) (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Flagged f a))
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Flagged f a -&gt; m (Flagged f a)
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Flagged f a -&gt; m (Flagged f a)
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Flagged f a)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Flagged f a -&gt; c (Flagged f a)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Flagged f a))
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Flagged f a))
$cFlagged :: Constr
$tFlagged :: DataType
gmapMo :: (forall d. Data d =&gt; d -&gt; m d) -&gt; Flagged f a -&gt; m (Flagged f a)
$cgmapMo :: forall k (f :: k -&gt; *) (a :: k) (m :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Flagged f a -&gt; m (Flagged f a)
gmapMp :: (forall d. Data d =&gt; d -&gt; m d) -&gt; Flagged f a -&gt; m (Flagged f a)
$cgmapMp :: forall k (f :: k -&gt; *) (a :: k) (m :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Flagged f a -&gt; m (Flagged f a)
gmapM :: (forall d. Data d =&gt; d -&gt; m d) -&gt; Flagged f a -&gt; m (Flagged f a)
$cgmapM :: forall k (f :: k -&gt; *) (a :: k) (m :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Flagged f a -&gt; m (Flagged f a)
gmapQi :: Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Flagged f a -&gt; u
$cgmapQi :: forall k (f :: k -&gt; *) (a :: k) u.
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Flagged f a -&gt; u
gmapQ :: (forall d. Data d =&gt; d -&gt; u) -&gt; Flagged f a -&gt; [u]
$cgmapQ :: forall k (f :: k -&gt; *) (a :: k) u.
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; Flagged f a -&gt; [u]
gmapQr :: (r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Flagged f a -&gt; r
$cgmapQr :: forall k (f :: k -&gt; *) (a :: k) r r'.
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Flagged f a -&gt; r
gmapQl :: (r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Flagged f a -&gt; r
$cgmapQl :: forall k (f :: k -&gt; *) (a :: k) r r'.
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Flagged f a -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Flagged f a -&gt; Flagged f a
$cgmapT :: forall k (f :: k -&gt; *) (a :: k).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Flagged f a -&gt; Flagged f a
dataCast2 :: (forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Flagged f a))
$cdataCast2 :: forall k (f :: k -&gt; *) (a :: k) (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Flagged f a))
dataCast1 :: (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Flagged f a))
$cdataCast1 :: forall k (f :: k -&gt; *) (a :: k) (t :: * -&gt; *) (c :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Flagged f a))
dataTypeOf :: Flagged f a -&gt; DataType
$cdataTypeOf :: forall k (f :: k -&gt; *) (a :: k).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
Flagged f a -&gt; DataType
toConstr :: Flagged f a -&gt; Constr
$ctoConstr :: forall k (f :: k -&gt; *) (a :: k).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
Flagged f a -&gt; Constr
gunfold :: (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Flagged f a)
$cgunfold :: forall k (f :: k -&gt; *) (a :: k) (c :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Flagged f a)
gfoldl :: (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Flagged f a -&gt; c (Flagged f a)
$cgfoldl :: forall k (f :: k -&gt; *) (a :: k) (c :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Flagged f a -&gt; c (Flagged f a)
$cp1Data :: forall k (f :: k -&gt; *) (a :: k).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
Typeable (Flagged f a)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-331"></span><span>
</span><span id="line-332"></span><span id="local-6989586621679479204"><span id="local-6989586621679479206"><span id="local-6989586621679480107"><span class="hs-identifier">deriveShow1</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Flagged</span></span></span></span><span>
</span><span id="line-333"></span><span id="local-6989586621679479196"><span id="local-6989586621679479198"><span id="local-6989586621679479200"><span id="local-6989586621679479202"><span id="local-6989586621679480107"><span class="hs-identifier">deriveRead1</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Flagged</span></span></span></span></span></span><span>
</span><span id="line-334"></span><span id="local-6989586621679479194"><span id="local-6989586621679480107"><span class="hs-identifier">deriveEq1</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Flagged</span></span></span><span>
</span><span id="line-335"></span><span id="local-6989586621679479191"><span id="local-6989586621679480107"><span class="hs-identifier">deriveOrd1</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Flagged</span></span></span><span>
</span><span id="line-336"></span><span>
</span><span id="line-337"></span><span class="hs-comment">-- | Uses 'False' for 'pure', and '||' for '&lt;*&gt;'.</span><span>
</span><span id="line-338"></span><span id="local-6989586621679479190"><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679479181"><span id="local-6989586621679479183"><span id="local-6989586621679479185"><span class="annot"><span class="hs-identifier hs-type">Applicative</span></span><span> </span><span class="annot"><a href="#local-6989586621679479190"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Applicative</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Flagged"><span class="hs-identifier hs-type">Flagged</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679479190"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-339"></span><span>    </span><span id="local-6989586621679479180"><span class="annot"><span class="annottext">pure :: a -&gt; Flagged f a
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">pure</span></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; f a -&gt; Flagged f a
forall k (f :: k -&gt; *) (a :: k). Bool -&gt; f a -&gt; Flagged f a
</span><a href="Control.Applicative.Step.html#Flagged"><span class="hs-identifier hs-var">Flagged</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span> </span><span class="annot"><span class="annottext">(f a -&gt; Flagged f a) -&gt; (a -&gt; f a) -&gt; a -&gt; Flagged f a
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; f a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span>
</span><span id="line-340"></span><span>    </span><span class="annot"><a href="Control.Applicative.Step.html#Flagged"><span class="hs-identifier hs-type">Flagged</span></a></span><span> </span><span id="local-6989586621679479179"><span class="annot"><span class="annottext">n :: Bool
</span><a href="#local-6989586621679479179"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679479178"><span class="annot"><span class="annottext">f :: f (a -&gt; b)
</span><a href="#local-6989586621679479178"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679479177"><span class="annot"><span class="annottext">&lt;*&gt; :: Flagged f (a -&gt; b) -&gt; Flagged f a -&gt; Flagged f b
</span><span class="hs-operator hs-var hs-var hs-var hs-var">&lt;*&gt;</span></span></span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#Flagged"><span class="hs-identifier hs-type">Flagged</span></a></span><span> </span><span id="local-6989586621679479176"><span class="annot"><span class="annottext">m :: Bool
</span><a href="#local-6989586621679479176"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span id="local-6989586621679479175"><span class="annot"><span class="annottext">x :: f a
</span><a href="#local-6989586621679479175"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; f b -&gt; Flagged f b
forall k (f :: k -&gt; *) (a :: k). Bool -&gt; f a -&gt; Flagged f a
</span><a href="Control.Applicative.Step.html#Flagged"><span class="hs-identifier hs-var">Flagged</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679479179"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">||</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679479176"><span class="hs-identifier hs-var">m</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">f (a -&gt; b)
</span><a href="#local-6989586621679479178"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">f (a -&gt; b) -&gt; f a -&gt; f b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">f a
</span><a href="#local-6989586621679479175"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-341"></span><span>
</span><span id="line-342"></span><span class="hs-comment">-- | Uses 'False' for 'point'.</span><span>
</span><span id="line-343"></span><span id="local-6989586621679479173"><span class="hs-keyword">instance</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Pointed</span></span><span> </span><span class="annot"><a href="#local-6989586621679479173"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Pointed</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Flagged"><span class="hs-identifier hs-type">Flagged</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679479173"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-344"></span><span>    </span><span id="local-6989586621679479171"><span class="annot"><span class="annottext">point :: a -&gt; Flagged f a
</span><a href="#local-6989586621679479171"><span class="hs-identifier hs-var hs-var hs-var hs-var">point</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; f a -&gt; Flagged f a
forall k (f :: k -&gt; *) (a :: k). Bool -&gt; f a -&gt; Flagged f a
</span><a href="Control.Applicative.Step.html#Flagged"><span class="hs-identifier hs-var">Flagged</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span> </span><span class="annot"><span class="annottext">(f a -&gt; Flagged f a) -&gt; (a -&gt; f a) -&gt; a -&gt; Flagged f a
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; f a
forall (p :: * -&gt; *) a. Pointed p =&gt; a -&gt; p a
</span><span class="hs-identifier hs-var">point</span></span></span><span>
</span><span id="line-345"></span><span>
</span><span id="line-346"></span><span id="local-6989586621679479170"><span class="hs-keyword">instance</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Foldable1</span></span><span> </span><span class="annot"><a href="#local-6989586621679479170"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Foldable1</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Flagged"><span class="hs-identifier hs-type">Flagged</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679479170"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-347"></span><span>    </span><span id="local-6989586621679479165"><span class="annot"><span class="annottext">fold1 :: Flagged f m -&gt; m
</span><a href="#local-6989586621679479165"><span class="hs-identifier hs-var hs-var hs-var hs-var">fold1</span></a></span></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">f m -&gt; m
forall (t :: * -&gt; *) m. (Foldable1 t, Semigroup m) =&gt; t m -&gt; m
</span><span class="hs-identifier hs-var">fold1</span></span><span> </span><span class="annot"><span class="annottext">(f m -&gt; m) -&gt; (Flagged f m -&gt; f m) -&gt; Flagged f m -&gt; m
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Flagged f m -&gt; f m
forall k (f :: k -&gt; *) (a :: k). Flagged f a -&gt; f a
</span><a href="Control.Applicative.Step.html#flaggedVal"><span class="hs-identifier hs-var hs-var">flaggedVal</span></a></span><span>
</span><span id="line-348"></span><span>    </span><span id="local-6989586621679479164"><span class="annot"><span class="annottext">foldMap1 :: (a -&gt; m) -&gt; Flagged f a -&gt; m
</span><a href="#local-6989586621679479164"><span class="hs-identifier hs-var hs-var hs-var hs-var">foldMap1</span></a></span></span><span> </span><span id="local-6989586621679479163"><span class="annot"><span class="annottext">f :: a -&gt; m
</span><a href="#local-6989586621679479163"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; m) -&gt; f a -&gt; m
forall (t :: * -&gt; *) m a.
(Foldable1 t, Semigroup m) =&gt;
(a -&gt; m) -&gt; t a -&gt; m
</span><span class="hs-identifier hs-var">foldMap1</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; m
</span><a href="#local-6989586621679479163"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">(f a -&gt; m) -&gt; (Flagged f a -&gt; f a) -&gt; Flagged f a -&gt; m
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Flagged f a -&gt; f a
forall k (f :: k -&gt; *) (a :: k). Flagged f a -&gt; f a
</span><a href="Control.Applicative.Step.html#flaggedVal"><span class="hs-identifier hs-var hs-var">flaggedVal</span></a></span><span>
</span><span id="line-349"></span><span>    </span><span id="local-6989586621679479162"><span class="annot"><span class="annottext">toNonEmpty :: Flagged f a -&gt; NonEmpty a
</span><a href="#local-6989586621679479162"><span class="hs-identifier hs-var hs-var hs-var hs-var">toNonEmpty</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">f a -&gt; NonEmpty a
forall (t :: * -&gt; *) a. Foldable1 t =&gt; t a -&gt; NonEmpty a
</span><span class="hs-identifier hs-var">toNonEmpty</span></span><span> </span><span class="annot"><span class="annottext">(f a -&gt; NonEmpty a)
-&gt; (Flagged f a -&gt; f a) -&gt; Flagged f a -&gt; NonEmpty a
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Flagged f a -&gt; f a
forall k (f :: k -&gt; *) (a :: k). Flagged f a -&gt; f a
</span><a href="Control.Applicative.Step.html#flaggedVal"><span class="hs-identifier hs-var hs-var">flaggedVal</span></a></span></span><span>
</span><span id="line-350"></span><span>
</span><span id="line-351"></span><span id="local-6989586621679479161"><span class="hs-keyword">instance</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Traversable1</span></span><span> </span><span class="annot"><a href="#local-6989586621679479161"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Traversable1</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Flagged"><span class="hs-identifier hs-type">Flagged</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679479161"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-352"></span><span>    </span><span id="local-6989586621679479156"><span class="annot"><span class="annottext">traverse1 :: (a -&gt; f b) -&gt; Flagged f a -&gt; f (Flagged f b)
</span><a href="#local-6989586621679479156"><span class="hs-identifier hs-var hs-var hs-var hs-var">traverse1</span></a></span></span><span> </span><span id="local-6989586621679479155"><span class="annot"><span class="annottext">f :: a -&gt; f b
</span><a href="#local-6989586621679479155"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Flagged"><span class="hs-identifier hs-type">Flagged</span></a></span><span> </span><span id="local-6989586621679479154"><span class="annot"><span class="annottext">n :: Bool
</span><a href="#local-6989586621679479154"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679479153"><span class="annot"><span class="annottext">x :: f a
</span><a href="#local-6989586621679479153"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; f b -&gt; Flagged f b
forall k (f :: k -&gt; *) (a :: k). Bool -&gt; f a -&gt; Flagged f a
</span><a href="Control.Applicative.Step.html#Flagged"><span class="hs-identifier hs-var">Flagged</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679479154"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">(f b -&gt; Flagged f b) -&gt; f (f b) -&gt; f (Flagged f b)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">(a -&gt; f b) -&gt; f a -&gt; f (f b)
forall (t :: * -&gt; *) (f :: * -&gt; *) a b.
(Traversable1 t, Apply f) =&gt;
(a -&gt; f b) -&gt; t a -&gt; f (t b)
</span><span class="hs-identifier hs-var">traverse1</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; f b
</span><a href="#local-6989586621679479155"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">f a
</span><a href="#local-6989586621679479153"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-353"></span><span>    </span><span id="local-6989586621679479152"><span class="annot"><span class="annottext">sequence1 :: Flagged f (f b) -&gt; f (Flagged f b)
</span><a href="#local-6989586621679479152"><span class="hs-identifier hs-var hs-var hs-var hs-var">sequence1</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Flagged"><span class="hs-identifier hs-type">Flagged</span></a></span><span> </span><span id="local-6989586621679479151"><span class="annot"><span class="annottext">n :: Bool
</span><a href="#local-6989586621679479151"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679479150"><span class="annot"><span class="annottext">x :: f (f b)
</span><a href="#local-6989586621679479150"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; f b -&gt; Flagged f b
forall k (f :: k -&gt; *) (a :: k). Bool -&gt; f a -&gt; Flagged f a
</span><a href="Control.Applicative.Step.html#Flagged"><span class="hs-identifier hs-var">Flagged</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679479151"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">(f b -&gt; Flagged f b) -&gt; f (f b) -&gt; f (Flagged f b)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">f (f b) -&gt; f (f b)
forall (t :: * -&gt; *) (f :: * -&gt; *) b.
(Traversable1 t, Apply f) =&gt;
t (f b) -&gt; f (t b)
</span><span class="hs-identifier hs-var">sequence1</span></span><span> </span><span class="annot"><span class="annottext">f (f b)
</span><a href="#local-6989586621679479150"><span class="hs-identifier hs-var">x</span></a></span></span><span>
</span><span id="line-354"></span><span>
</span><span id="line-355"></span><span>
</span><span id="line-356"></span><span>
</span><span id="line-357"></span><span>
</span><span id="line-358"></span><span>
</span><span id="line-359"></span><span class="hs-comment">-- | @'Void2' a b@ is uninhabited for all @a@ and @b@.</span><span>
</span><span id="line-360"></span><span id="local-6989586621679479148"><span id="local-6989586621679479149"></span></span><span class="hs-keyword">data</span><span> </span><span id="Void2"><span class="annot"><a href="Control.Applicative.Step.html#Void2"><span class="hs-identifier hs-var">Void2</span></a></span></span><span> </span><span id="local-6989586621679479147"><span class="annot"><a href="#local-6989586621679479147"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span id="local-6989586621679479146"><span class="annot"><a href="#local-6989586621679479146"><span class="hs-identifier hs-type">b</span></a></span></span><span>
</span><span id="line-361"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679479140"><span id="local-6989586621679479142"><span id="local-6989586621679479144"><span class="annot"><span class="annottext">Int -&gt; Void2 a b -&gt; ShowS
[Void2 a b] -&gt; ShowS
Void2 a b -&gt; String
(Int -&gt; Void2 a b -&gt; ShowS)
-&gt; (Void2 a b -&gt; String)
-&gt; ([Void2 a b] -&gt; ShowS)
-&gt; Show (Void2 a b)
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
forall k (a :: k) k (b :: k). Int -&gt; Void2 a b -&gt; ShowS
forall k (a :: k) k (b :: k). [Void2 a b] -&gt; ShowS
forall k (a :: k) k (b :: k). Void2 a b -&gt; String
showList :: [Void2 a b] -&gt; ShowS
$cshowList :: forall k (a :: k) k (b :: k). [Void2 a b] -&gt; ShowS
show :: Void2 a b -&gt; String
$cshow :: forall k (a :: k) k (b :: k). Void2 a b -&gt; String
showsPrec :: Int -&gt; Void2 a b -&gt; ShowS
$cshowsPrec :: forall k (a :: k) k (b :: k). Int -&gt; Void2 a b -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679479132"><span id="local-6989586621679479134"><span id="local-6989586621679479136"><span id="local-6989586621679479138"><span class="annot"><span class="annottext">ReadPrec [Void2 a b]
ReadPrec (Void2 a b)
Int -&gt; ReadS (Void2 a b)
ReadS [Void2 a b]
(Int -&gt; ReadS (Void2 a b))
-&gt; ReadS [Void2 a b]
-&gt; ReadPrec (Void2 a b)
-&gt; ReadPrec [Void2 a b]
-&gt; Read (Void2 a b)
forall a.
(Int -&gt; ReadS a)
-&gt; ReadS [a] -&gt; ReadPrec a -&gt; ReadPrec [a] -&gt; Read a
forall k (a :: k) k (b :: k). ReadPrec [Void2 a b]
forall k (a :: k) k (b :: k). ReadPrec (Void2 a b)
forall k (a :: k) k (b :: k). Int -&gt; ReadS (Void2 a b)
forall k (a :: k) k (b :: k). ReadS [Void2 a b]
readListPrec :: ReadPrec [Void2 a b]
$creadListPrec :: forall k (a :: k) k (b :: k). ReadPrec [Void2 a b]
readPrec :: ReadPrec (Void2 a b)
$creadPrec :: forall k (a :: k) k (b :: k). ReadPrec (Void2 a b)
readList :: ReadS [Void2 a b]
$creadList :: forall k (a :: k) k (b :: k). ReadS [Void2 a b]
readsPrec :: Int -&gt; ReadS (Void2 a b)
$creadsPrec :: forall k (a :: k) k (b :: k). Int -&gt; ReadS (Void2 a b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Read</span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679479128"><span id="local-6989586621679479130"><span class="annot"><span class="annottext">Void2 a b -&gt; Void2 a b -&gt; Bool
(Void2 a b -&gt; Void2 a b -&gt; Bool)
-&gt; (Void2 a b -&gt; Void2 a b -&gt; Bool) -&gt; Eq (Void2 a b)
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
forall k (a :: k) k (b :: k). Void2 a b -&gt; Void2 a b -&gt; Bool
/= :: Void2 a b -&gt; Void2 a b -&gt; Bool
$c/= :: forall k (a :: k) k (b :: k). Void2 a b -&gt; Void2 a b -&gt; Bool
== :: Void2 a b -&gt; Void2 a b -&gt; Bool
$c== :: forall k (a :: k) k (b :: k). Void2 a b -&gt; Void2 a b -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679479113"><span id="local-6989586621679479115"><span id="local-6989586621679479117"><span id="local-6989586621679479119"><span id="local-6989586621679479121"><span id="local-6989586621679479123"><span id="local-6989586621679479125"><span class="annot"><span class="annottext">Eq (Void2 a b)
Eq (Void2 a b) =&gt;
(Void2 a b -&gt; Void2 a b -&gt; Ordering)
-&gt; (Void2 a b -&gt; Void2 a b -&gt; Bool)
-&gt; (Void2 a b -&gt; Void2 a b -&gt; Bool)
-&gt; (Void2 a b -&gt; Void2 a b -&gt; Bool)
-&gt; (Void2 a b -&gt; Void2 a b -&gt; Bool)
-&gt; (Void2 a b -&gt; Void2 a b -&gt; Void2 a b)
-&gt; (Void2 a b -&gt; Void2 a b -&gt; Void2 a b)
-&gt; Ord (Void2 a b)
Void2 a b -&gt; Void2 a b -&gt; Bool
Void2 a b -&gt; Void2 a b -&gt; Ordering
Void2 a b -&gt; Void2 a b -&gt; Void2 a b
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall k (a :: k) k (b :: k). Eq (Void2 a b)
forall k (a :: k) k (b :: k). Void2 a b -&gt; Void2 a b -&gt; Bool
forall k (a :: k) k (b :: k). Void2 a b -&gt; Void2 a b -&gt; Ordering
forall k (a :: k) k (b :: k). Void2 a b -&gt; Void2 a b -&gt; Void2 a b
min :: Void2 a b -&gt; Void2 a b -&gt; Void2 a b
$cmin :: forall k (a :: k) k (b :: k). Void2 a b -&gt; Void2 a b -&gt; Void2 a b
max :: Void2 a b -&gt; Void2 a b -&gt; Void2 a b
$cmax :: forall k (a :: k) k (b :: k). Void2 a b -&gt; Void2 a b -&gt; Void2 a b
&gt;= :: Void2 a b -&gt; Void2 a b -&gt; Bool
$c&gt;= :: forall k (a :: k) k (b :: k). Void2 a b -&gt; Void2 a b -&gt; Bool
&gt; :: Void2 a b -&gt; Void2 a b -&gt; Bool
$c&gt; :: forall k (a :: k) k (b :: k). Void2 a b -&gt; Void2 a b -&gt; Bool
&lt;= :: Void2 a b -&gt; Void2 a b -&gt; Bool
$c&lt;= :: forall k (a :: k) k (b :: k). Void2 a b -&gt; Void2 a b -&gt; Bool
&lt; :: Void2 a b -&gt; Void2 a b -&gt; Bool
$c&lt; :: forall k (a :: k) k (b :: k). Void2 a b -&gt; Void2 a b -&gt; Bool
compare :: Void2 a b -&gt; Void2 a b -&gt; Ordering
$ccompare :: forall k (a :: k) k (b :: k). Void2 a b -&gt; Void2 a b -&gt; Ordering
$cp1Ord :: forall k (a :: k) k (b :: k). Eq (Void2 a b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679479109"><span id="local-6989586621679479111"><span class="annot"><span class="annottext">(a -&gt; b) -&gt; Void2 a a -&gt; Void2 a b
(forall a b. (a -&gt; b) -&gt; Void2 a a -&gt; Void2 a b)
-&gt; (forall a b. a -&gt; Void2 a b -&gt; Void2 a a) -&gt; Functor (Void2 a)
forall k (a :: k) a b. a -&gt; Void2 a b -&gt; Void2 a a
forall k (a :: k) a b. (a -&gt; b) -&gt; Void2 a a -&gt; Void2 a b
forall a b. a -&gt; Void2 a b -&gt; Void2 a a
forall a b. (a -&gt; b) -&gt; Void2 a a -&gt; Void2 a b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: a -&gt; Void2 a b -&gt; Void2 a a
$c&lt;$ :: forall k (a :: k) a b. a -&gt; Void2 a b -&gt; Void2 a a
fmap :: (a -&gt; b) -&gt; Void2 a a -&gt; Void2 a b
$cfmap :: forall k (a :: k) a b. (a -&gt; b) -&gt; Void2 a a -&gt; Void2 a b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679479075"><span id="local-6989586621679479077"><span id="local-6989586621679479079"><span id="local-6989586621679479081"><span id="local-6989586621679479083"><span id="local-6989586621679479085"><span id="local-6989586621679479087"><span id="local-6989586621679479089"><span id="local-6989586621679479091"><span id="local-6989586621679479093"><span id="local-6989586621679479095"><span id="local-6989586621679479097"><span id="local-6989586621679479099"><span id="local-6989586621679479101"><span id="local-6989586621679479103"><span id="local-6989586621679479105"><span id="local-6989586621679479107"><span class="annot"><span class="annottext">(a -&gt; m) -&gt; Void2 a a -&gt; m
(forall m. Monoid m =&gt; Void2 a m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Void2 a a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Void2 a a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Void2 a a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Void2 a a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Void2 a a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Void2 a a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; Void2 a a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; Void2 a a -&gt; a)
-&gt; (forall a. Void2 a a -&gt; [a])
-&gt; (forall a. Void2 a a -&gt; Bool)
-&gt; (forall a. Void2 a a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; Void2 a a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; Void2 a a -&gt; a)
-&gt; (forall a. Ord a =&gt; Void2 a a -&gt; a)
-&gt; (forall a. Num a =&gt; Void2 a a -&gt; a)
-&gt; (forall a. Num a =&gt; Void2 a a -&gt; a)
-&gt; Foldable (Void2 a)
forall a. Eq a =&gt; a -&gt; Void2 a a -&gt; Bool
forall a. Num a =&gt; Void2 a a -&gt; a
forall a. Ord a =&gt; Void2 a a -&gt; a
forall m. Monoid m =&gt; Void2 a m -&gt; m
forall a. Void2 a a -&gt; Bool
forall a. Void2 a a -&gt; Int
forall a. Void2 a a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; Void2 a a -&gt; a
forall k (a :: k) a. Eq a =&gt; a -&gt; Void2 a a -&gt; Bool
forall k (a :: k) a. Num a =&gt; Void2 a a -&gt; a
forall k (a :: k) a. Ord a =&gt; Void2 a a -&gt; a
forall k (a :: k) m. Monoid m =&gt; Void2 a m -&gt; m
forall k (a :: k) a. Void2 a a -&gt; Bool
forall k (a :: k) a. Void2 a a -&gt; Int
forall k (a :: k) a. Void2 a a -&gt; [a]
forall k (a :: k) a. (a -&gt; a -&gt; a) -&gt; Void2 a a -&gt; a
forall k (a :: k) m a. Monoid m =&gt; (a -&gt; m) -&gt; Void2 a a -&gt; m
forall k (a :: k) b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Void2 a a -&gt; b
forall k (a :: k) a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Void2 a a -&gt; b
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Void2 a a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Void2 a a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Void2 a a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: Void2 a a -&gt; a
$cproduct :: forall k (a :: k) a. Num a =&gt; Void2 a a -&gt; a
sum :: Void2 a a -&gt; a
$csum :: forall k (a :: k) a. Num a =&gt; Void2 a a -&gt; a
minimum :: Void2 a a -&gt; a
$cminimum :: forall k (a :: k) a. Ord a =&gt; Void2 a a -&gt; a
maximum :: Void2 a a -&gt; a
$cmaximum :: forall k (a :: k) a. Ord a =&gt; Void2 a a -&gt; a
elem :: a -&gt; Void2 a a -&gt; Bool
$celem :: forall k (a :: k) a. Eq a =&gt; a -&gt; Void2 a a -&gt; Bool
length :: Void2 a a -&gt; Int
$clength :: forall k (a :: k) a. Void2 a a -&gt; Int
null :: Void2 a a -&gt; Bool
$cnull :: forall k (a :: k) a. Void2 a a -&gt; Bool
toList :: Void2 a a -&gt; [a]
$ctoList :: forall k (a :: k) a. Void2 a a -&gt; [a]
foldl1 :: (a -&gt; a -&gt; a) -&gt; Void2 a a -&gt; a
$cfoldl1 :: forall k (a :: k) a. (a -&gt; a -&gt; a) -&gt; Void2 a a -&gt; a
foldr1 :: (a -&gt; a -&gt; a) -&gt; Void2 a a -&gt; a
$cfoldr1 :: forall k (a :: k) a. (a -&gt; a -&gt; a) -&gt; Void2 a a -&gt; a
foldl' :: (b -&gt; a -&gt; b) -&gt; b -&gt; Void2 a a -&gt; b
$cfoldl' :: forall k (a :: k) b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Void2 a a -&gt; b
foldl :: (b -&gt; a -&gt; b) -&gt; b -&gt; Void2 a a -&gt; b
$cfoldl :: forall k (a :: k) b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Void2 a a -&gt; b
foldr' :: (a -&gt; b -&gt; b) -&gt; b -&gt; Void2 a a -&gt; b
$cfoldr' :: forall k (a :: k) a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Void2 a a -&gt; b
foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; Void2 a a -&gt; b
$cfoldr :: forall k (a :: k) a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Void2 a a -&gt; b
foldMap' :: (a -&gt; m) -&gt; Void2 a a -&gt; m
$cfoldMap' :: forall k (a :: k) m a. Monoid m =&gt; (a -&gt; m) -&gt; Void2 a a -&gt; m
foldMap :: (a -&gt; m) -&gt; Void2 a a -&gt; m
$cfoldMap :: forall k (a :: k) m a. Monoid m =&gt; (a -&gt; m) -&gt; Void2 a a -&gt; m
fold :: Void2 a m -&gt; m
$cfold :: forall k (a :: k) m. Monoid m =&gt; Void2 a m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679479065"><span id="local-6989586621679479067"><span id="local-6989586621679479069"><span id="local-6989586621679479071"><span class="annot"><span class="annottext">Functor (Void2 a)
Foldable (Void2 a)
(Functor (Void2 a), Foldable (Void2 a)) =&gt;
(forall (f :: * -&gt; *) a b.
 Applicative f =&gt;
 (a -&gt; f b) -&gt; Void2 a a -&gt; f (Void2 a b))
-&gt; (forall (f :: * -&gt; *) a.
    Applicative f =&gt;
    Void2 a (f a) -&gt; f (Void2 a a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; Void2 a a -&gt; m (Void2 a b))
-&gt; (forall (m :: * -&gt; *) a.
    Monad m =&gt;
    Void2 a (m a) -&gt; m (Void2 a a))
-&gt; Traversable (Void2 a)
(a -&gt; f b) -&gt; Void2 a a -&gt; f (Void2 a b)
forall k (a :: k). Functor (Void2 a)
forall k (a :: k). Foldable (Void2 a)
forall k (a :: k) (m :: * -&gt; *) a.
Monad m =&gt;
Void2 a (m a) -&gt; m (Void2 a a)
forall k (a :: k) (f :: * -&gt; *) a.
Applicative f =&gt;
Void2 a (f a) -&gt; f (Void2 a a)
forall k (a :: k) (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Void2 a a -&gt; m (Void2 a b)
forall k (a :: k) (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Void2 a a -&gt; f (Void2 a b)
forall (t :: * -&gt; *).
(Functor t, Foldable t) =&gt;
(forall (f :: * -&gt; *) a b.
 Applicative f =&gt;
 (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a. Monad m =&gt; Void2 a (m a) -&gt; m (Void2 a a)
forall (f :: * -&gt; *) a.
Applicative f =&gt;
Void2 a (f a) -&gt; f (Void2 a a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Void2 a a -&gt; m (Void2 a b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Void2 a a -&gt; f (Void2 a b)
sequence :: Void2 a (m a) -&gt; m (Void2 a a)
$csequence :: forall k (a :: k) (m :: * -&gt; *) a.
Monad m =&gt;
Void2 a (m a) -&gt; m (Void2 a a)
mapM :: (a -&gt; m b) -&gt; Void2 a a -&gt; m (Void2 a b)
$cmapM :: forall k (a :: k) (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Void2 a a -&gt; m (Void2 a b)
sequenceA :: Void2 a (f a) -&gt; f (Void2 a a)
$csequenceA :: forall k (a :: k) (f :: * -&gt; *) a.
Applicative f =&gt;
Void2 a (f a) -&gt; f (Void2 a a)
traverse :: (a -&gt; f b) -&gt; Void2 a a -&gt; f (Void2 a b)
$ctraverse :: forall k (a :: k) (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Void2 a a -&gt; f (Void2 a b)
$cp2Traversable :: forall k (a :: k). Foldable (Void2 a)
$cp1Traversable :: forall k (a :: k). Functor (Void2 a)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">(forall x. Void2 a b -&gt; Rep (Void2 a b) x)
-&gt; (forall x. Rep (Void2 a b) x -&gt; Void2 a b)
-&gt; Generic (Void2 a b)
forall x. Rep (Void2 a b) x -&gt; Void2 a b
forall x. Void2 a b -&gt; Rep (Void2 a b) x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall k (a :: k) k (b :: k) x. Rep (Void2 a b) x -&gt; Void2 a b
forall k (a :: k) k (b :: k) x. Void2 a b -&gt; Rep (Void2 a b) x
$cto :: forall k (a :: k) k (b :: k) x. Rep (Void2 a b) x -&gt; Void2 a b
$cfrom :: forall k (a :: k) k (b :: k) x. Void2 a b -&gt; Rep (Void2 a b) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">,</span><span> </span><span id="%24tVoid2"><span id="local-6989586621679479034"><span id="local-6989586621679479036"><span id="local-6989586621679479038"><span id="local-6989586621679479040"><span id="local-6989586621679479042"><span id="local-6989586621679479044"><span id="local-6989586621679479046"><span id="local-6989586621679479048"><span id="local-6989586621679479050"><span id="local-6989586621679479052"><span id="local-6989586621679479054"><span id="local-6989586621679479056"><span id="local-6989586621679479058"><span id="local-6989586621679479060"><span class="annot"><span class="annottext">Typeable (Void2 a b)
DataType
Typeable (Void2 a b) =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; Void2 a b -&gt; c (Void2 a b))
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Void2 a b))
-&gt; (Void2 a b -&gt; Constr)
-&gt; (Void2 a b -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Void2 a b)))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e))
    -&gt; Maybe (c (Void2 a b)))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; Void2 a b -&gt; Void2 a b)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Void2 a b -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Void2 a b -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Void2 a b -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Void2 a b -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Void2 a b -&gt; m (Void2 a b))
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Void2 a b -&gt; m (Void2 a b))
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Void2 a b -&gt; m (Void2 a b))
-&gt; Data (Void2 a b)
Void2 a b -&gt; DataType
Void2 a b -&gt; Constr
(forall b. Data b =&gt; b -&gt; b) -&gt; Void2 a b -&gt; Void2 a b
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Void2 a b -&gt; c (Void2 a b)
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Void2 a b)
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Void2 a b -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Void2 a b -&gt; [u]
forall k (a :: k) k (b :: k).
(Typeable a, Typeable b, Typeable k, Typeable k) =&gt;
Typeable (Void2 a b)
forall k (a :: k) k (b :: k).
(Typeable a, Typeable b, Typeable k, Typeable k) =&gt;
Void2 a b -&gt; DataType
forall k (a :: k) k (b :: k).
(Typeable a, Typeable b, Typeable k, Typeable k) =&gt;
Void2 a b -&gt; Constr
forall k (a :: k) k (b :: k).
(Typeable a, Typeable b, Typeable k, Typeable k) =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Void2 a b -&gt; Void2 a b
forall k (a :: k) k (b :: k) u.
(Typeable a, Typeable b, Typeable k, Typeable k) =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Void2 a b -&gt; u
forall k (a :: k) k (b :: k) u.
(Typeable a, Typeable b, Typeable k, Typeable k) =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; Void2 a b -&gt; [u]
forall k (a :: k) k (b :: k) r r'.
(Typeable a, Typeable b, Typeable k, Typeable k) =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Void2 a b -&gt; r
forall k (a :: k) k (b :: k) r r'.
(Typeable a, Typeable b, Typeable k, Typeable k) =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Void2 a b -&gt; r
forall k (a :: k) k (b :: k) (m :: * -&gt; *).
(Typeable a, Typeable b, Typeable k, Typeable k, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Void2 a b -&gt; m (Void2 a b)
forall k (a :: k) k (b :: k) (m :: * -&gt; *).
(Typeable a, Typeable b, Typeable k, Typeable k, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Void2 a b -&gt; m (Void2 a b)
forall k (a :: k) k (b :: k) (c :: * -&gt; *).
(Typeable a, Typeable b, Typeable k, Typeable k) =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Void2 a b)
forall k (a :: k) k (b :: k) (c :: * -&gt; *).
(Typeable a, Typeable b, Typeable k, Typeable k) =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Void2 a b -&gt; c (Void2 a b)
forall k (a :: k) k (b :: k) (t :: * -&gt; *) (c :: * -&gt; *).
(Typeable a, Typeable b, Typeable k, Typeable k, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Void2 a b))
forall k (a :: k) k (b :: k) (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Typeable a, Typeable b, Typeable k, Typeable k, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Void2 a b))
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Void2 a b -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Void2 a b -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Void2 a b -&gt; m (Void2 a b)
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Void2 a b -&gt; m (Void2 a b)
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Void2 a b)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Void2 a b -&gt; c (Void2 a b)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Void2 a b))
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Void2 a b))
$tVoid2 :: DataType
gmapMo :: (forall d. Data d =&gt; d -&gt; m d) -&gt; Void2 a b -&gt; m (Void2 a b)
$cgmapMo :: forall k (a :: k) k (b :: k) (m :: * -&gt; *).
(Typeable a, Typeable b, Typeable k, Typeable k, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Void2 a b -&gt; m (Void2 a b)
gmapMp :: (forall d. Data d =&gt; d -&gt; m d) -&gt; Void2 a b -&gt; m (Void2 a b)
$cgmapMp :: forall k (a :: k) k (b :: k) (m :: * -&gt; *).
(Typeable a, Typeable b, Typeable k, Typeable k, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Void2 a b -&gt; m (Void2 a b)
gmapM :: (forall d. Data d =&gt; d -&gt; m d) -&gt; Void2 a b -&gt; m (Void2 a b)
$cgmapM :: forall k (a :: k) k (b :: k) (m :: * -&gt; *).
(Typeable a, Typeable b, Typeable k, Typeable k, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Void2 a b -&gt; m (Void2 a b)
gmapQi :: Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Void2 a b -&gt; u
$cgmapQi :: forall k (a :: k) k (b :: k) u.
(Typeable a, Typeable b, Typeable k, Typeable k) =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Void2 a b -&gt; u
gmapQ :: (forall d. Data d =&gt; d -&gt; u) -&gt; Void2 a b -&gt; [u]
$cgmapQ :: forall k (a :: k) k (b :: k) u.
(Typeable a, Typeable b, Typeable k, Typeable k) =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; Void2 a b -&gt; [u]
gmapQr :: (r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Void2 a b -&gt; r
$cgmapQr :: forall k (a :: k) k (b :: k) r r'.
(Typeable a, Typeable b, Typeable k, Typeable k) =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Void2 a b -&gt; r
gmapQl :: (r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Void2 a b -&gt; r
$cgmapQl :: forall k (a :: k) k (b :: k) r r'.
(Typeable a, Typeable b, Typeable k, Typeable k) =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Void2 a b -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Void2 a b -&gt; Void2 a b
$cgmapT :: forall k (a :: k) k (b :: k).
(Typeable a, Typeable b, Typeable k, Typeable k) =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Void2 a b -&gt; Void2 a b
dataCast2 :: (forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Void2 a b))
$cdataCast2 :: forall k (a :: k) k (b :: k) (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Typeable a, Typeable b, Typeable k, Typeable k, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Void2 a b))
dataCast1 :: (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Void2 a b))
$cdataCast1 :: forall k (a :: k) k (b :: k) (t :: * -&gt; *) (c :: * -&gt; *).
(Typeable a, Typeable b, Typeable k, Typeable k, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Void2 a b))
dataTypeOf :: Void2 a b -&gt; DataType
$cdataTypeOf :: forall k (a :: k) k (b :: k).
(Typeable a, Typeable b, Typeable k, Typeable k) =&gt;
Void2 a b -&gt; DataType
toConstr :: Void2 a b -&gt; Constr
$ctoConstr :: forall k (a :: k) k (b :: k).
(Typeable a, Typeable b, Typeable k, Typeable k) =&gt;
Void2 a b -&gt; Constr
gunfold :: (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Void2 a b)
$cgunfold :: forall k (a :: k) k (b :: k) (c :: * -&gt; *).
(Typeable a, Typeable b, Typeable k, Typeable k) =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Void2 a b)
gfoldl :: (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Void2 a b -&gt; c (Void2 a b)
$cgfoldl :: forall k (a :: k) k (b :: k) (c :: * -&gt; *).
(Typeable a, Typeable b, Typeable k, Typeable k) =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Void2 a b -&gt; c (Void2 a b)
$cp1Data :: forall k (a :: k) k (b :: k).
(Typeable a, Typeable b, Typeable k, Typeable k) =&gt;
Typeable (Void2 a b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-362"></span><span>
</span><span id="line-363"></span><span id="local-6989586621679479029"><span id="local-6989586621679479031"><span id="local-6989586621679479147"><span class="hs-identifier">deriveShow1</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Void2</span></span></span></span><span>
</span><span id="line-364"></span><span id="local-6989586621679479021"><span id="local-6989586621679479023"><span id="local-6989586621679479025"><span id="local-6989586621679479027"><span id="local-6989586621679479147"><span class="hs-identifier">deriveRead1</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Void2</span></span></span></span></span></span><span>
</span><span id="line-365"></span><span id="local-6989586621679479019"><span id="local-6989586621679479147"><span class="hs-identifier">deriveEq1</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Void2</span></span></span><span>
</span><span id="line-366"></span><span id="local-6989586621679479016"><span id="local-6989586621679479147"><span class="hs-identifier">deriveOrd1</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Void2</span></span></span><span>
</span><span id="line-367"></span><span>
</span><span id="line-368"></span><span id="local-6989586621679479014"><span id="local-6989586621679479015"><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679479009"><span id="local-6989586621679479011"><span class="annot"><span class="hs-identifier hs-type">Semigroup</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Void2"><span class="hs-identifier hs-type">Void2</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679479015"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679479014"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-369"></span><span>    </span><span id="local-6989586621679479008"><span class="annot"><span class="annottext">x :: Void2 a b
</span><a href="#local-6989586621679479008"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679479007"><span class="annot"><span class="annottext">&lt;&gt; :: Void2 a b -&gt; Void2 a b -&gt; Void2 a b
</span><span class="hs-operator hs-var hs-var hs-var hs-var">&lt;&gt;</span></span></span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Void2 a b
</span><a href="#local-6989586621679479008"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span></span></span><span>
</span><span id="line-370"></span><span>
</span><span id="line-371"></span><span id="local-6989586621679479006"><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679479000"><span id="local-6989586621679479002"><span class="annot"><span class="hs-identifier hs-type">Alt</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Void2"><span class="hs-identifier hs-type">Void2</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679479006"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-372"></span><span>    </span><span id="local-6989586621679478999"><span class="annot"><span class="annottext">x :: Void2 a a
</span><a href="#local-6989586621679478999"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679478998"><span class="annot"><span class="annottext">&lt;!&gt; :: Void2 a a -&gt; Void2 a a -&gt; Void2 a a
</span><a href="#local-6989586621679478998"><span class="hs-operator hs-var hs-var hs-var hs-var">&lt;!&gt;</span></a></span></span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Void2 a a -&gt; Void2 a a
forall k k (f :: k) (a :: k) (t :: k -&gt; k -&gt; *). Void2 f a -&gt; t f a
</span><a href="Control.Applicative.Step.html#absurd2"><span class="hs-identifier hs-var">absurd2</span></a></span><span> </span><span class="annot"><span class="annottext">Void2 a a
</span><a href="#local-6989586621679478999"><span class="hs-identifier hs-var">x</span></a></span></span><span>
</span><span id="line-373"></span><span>
</span><span id="line-374"></span><span id="local-6989586621679478997"><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679478993"><span class="annot"><span class="hs-identifier hs-type">Bind</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Void2"><span class="hs-identifier hs-type">Void2</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679478997"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-375"></span><span>    </span><span id="local-6989586621679478991"><span class="annot"><span class="annottext">x :: Void2 a a
</span><a href="#local-6989586621679478991"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679478990"><span class="annot"><span class="annottext">&gt;&gt;- :: Void2 a a -&gt; (a -&gt; Void2 a b) -&gt; Void2 a b
</span><span class="hs-operator hs-var hs-var hs-var hs-var">&gt;&gt;-</span></span></span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Void2 a a
</span><a href="#local-6989586621679478991"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span></span><span>
</span><span id="line-376"></span><span>
</span><span id="line-377"></span><span id="local-6989586621679478988"><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679478980"><span id="local-6989586621679478982"><span id="local-6989586621679478984"><span class="annot"><span class="hs-identifier hs-type">Apply</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Void2"><span class="hs-identifier hs-type">Void2</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679478988"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-378"></span><span>    </span><span id="local-6989586621679478978"><span class="annot"><span class="annottext">x :: Void2 a (a -&gt; b)
</span><a href="#local-6989586621679478978"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679478977"><span class="annot"><span class="annottext">&lt;.&gt; :: Void2 a (a -&gt; b) -&gt; Void2 a a -&gt; Void2 a b
</span><span class="hs-operator hs-var hs-var hs-var hs-var">&lt;.&gt;</span></span></span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Void2 a (a -&gt; b)
</span><a href="#local-6989586621679478978"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span></span><span>
</span><span id="line-379"></span><span>
</span><span id="line-380"></span><span class="hs-comment">-- | If you treat a @'Void2' f a@ as a functor combinator, then 'absurd2'</span><span>
</span><span id="line-381"></span><span class="hs-comment">-- lets you convert from a @'Void2' f a@ into a @t f a@ for any functor</span><span>
</span><span id="line-382"></span><span class="hs-comment">-- combinator @t@.</span><span>
</span><span id="line-383"></span><span id="local-6989586621679479973"><span id="local-6989586621679479974"><span id="local-6989586621679479975"><span class="annot"><a href="Control.Applicative.Step.html#absurd2"><span class="hs-identifier hs-type">absurd2</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#Void2"><span class="hs-identifier hs-type">Void2</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679479975"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679479974"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679479973"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679479975"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679479974"><span class="hs-identifier hs-type">a</span></a></span></span></span></span><span>
</span><span id="line-384"></span><span id="absurd2"><span class="annot"><span class="annottext">absurd2 :: Void2 f a -&gt; t f a
</span><a href="Control.Applicative.Step.html#absurd2"><span class="hs-identifier hs-var hs-var">absurd2</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span>
</span><span id="line-385"></span><span>
</span><span id="line-386"></span><span class="hs-comment">-- | @'Void3' a b@ is uninhabited for all @a@ and @b@.</span><span>
</span><span id="line-387"></span><span id="local-6989586621679478974"><span id="local-6989586621679478975"></span></span><span class="hs-keyword">data</span><span> </span><span id="Void3"><span class="annot"><a href="Control.Applicative.Step.html#Void3"><span class="hs-identifier hs-var">Void3</span></a></span></span><span> </span><span id="local-6989586621679478973"><span class="annot"><a href="#local-6989586621679478973"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span id="local-6989586621679478972"><span class="annot"><a href="#local-6989586621679478972"><span class="hs-identifier hs-type">b</span></a></span></span><span> </span><span id="local-6989586621679478971"><span class="annot"><a href="#local-6989586621679478971"><span class="hs-identifier hs-type">c</span></a></span></span><span>
</span><span id="line-388"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679478965"><span id="local-6989586621679478967"><span id="local-6989586621679478969"><span class="annot"><span class="annottext">Int -&gt; Void3 a b c -&gt; ShowS
[Void3 a b c] -&gt; ShowS
Void3 a b c -&gt; String
(Int -&gt; Void3 a b c -&gt; ShowS)
-&gt; (Void3 a b c -&gt; String)
-&gt; ([Void3 a b c] -&gt; ShowS)
-&gt; Show (Void3 a b c)
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
forall k (a :: k) k (b :: k) k (c :: k).
Int -&gt; Void3 a b c -&gt; ShowS
forall k (a :: k) k (b :: k) k (c :: k). [Void3 a b c] -&gt; ShowS
forall k (a :: k) k (b :: k) k (c :: k). Void3 a b c -&gt; String
showList :: [Void3 a b c] -&gt; ShowS
$cshowList :: forall k (a :: k) k (b :: k) k (c :: k). [Void3 a b c] -&gt; ShowS
show :: Void3 a b c -&gt; String
$cshow :: forall k (a :: k) k (b :: k) k (c :: k). Void3 a b c -&gt; String
showsPrec :: Int -&gt; Void3 a b c -&gt; ShowS
$cshowsPrec :: forall k (a :: k) k (b :: k) k (c :: k).
Int -&gt; Void3 a b c -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679478957"><span id="local-6989586621679478959"><span id="local-6989586621679478961"><span id="local-6989586621679478963"><span class="annot"><span class="annottext">ReadPrec [Void3 a b c]
ReadPrec (Void3 a b c)
Int -&gt; ReadS (Void3 a b c)
ReadS [Void3 a b c]
(Int -&gt; ReadS (Void3 a b c))
-&gt; ReadS [Void3 a b c]
-&gt; ReadPrec (Void3 a b c)
-&gt; ReadPrec [Void3 a b c]
-&gt; Read (Void3 a b c)
forall a.
(Int -&gt; ReadS a)
-&gt; ReadS [a] -&gt; ReadPrec a -&gt; ReadPrec [a] -&gt; Read a
forall k (a :: k) k (b :: k) k (c :: k). ReadPrec [Void3 a b c]
forall k (a :: k) k (b :: k) k (c :: k). ReadPrec (Void3 a b c)
forall k (a :: k) k (b :: k) k (c :: k). Int -&gt; ReadS (Void3 a b c)
forall k (a :: k) k (b :: k) k (c :: k). ReadS [Void3 a b c]
readListPrec :: ReadPrec [Void3 a b c]
$creadListPrec :: forall k (a :: k) k (b :: k) k (c :: k). ReadPrec [Void3 a b c]
readPrec :: ReadPrec (Void3 a b c)
$creadPrec :: forall k (a :: k) k (b :: k) k (c :: k). ReadPrec (Void3 a b c)
readList :: ReadS [Void3 a b c]
$creadList :: forall k (a :: k) k (b :: k) k (c :: k). ReadS [Void3 a b c]
readsPrec :: Int -&gt; ReadS (Void3 a b c)
$creadsPrec :: forall k (a :: k) k (b :: k) k (c :: k). Int -&gt; ReadS (Void3 a b c)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Read</span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679478953"><span id="local-6989586621679478955"><span class="annot"><span class="annottext">Void3 a b c -&gt; Void3 a b c -&gt; Bool
(Void3 a b c -&gt; Void3 a b c -&gt; Bool)
-&gt; (Void3 a b c -&gt; Void3 a b c -&gt; Bool) -&gt; Eq (Void3 a b c)
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
forall k (a :: k) k (b :: k) k (c :: k).
Void3 a b c -&gt; Void3 a b c -&gt; Bool
/= :: Void3 a b c -&gt; Void3 a b c -&gt; Bool
$c/= :: forall k (a :: k) k (b :: k) k (c :: k).
Void3 a b c -&gt; Void3 a b c -&gt; Bool
== :: Void3 a b c -&gt; Void3 a b c -&gt; Bool
$c== :: forall k (a :: k) k (b :: k) k (c :: k).
Void3 a b c -&gt; Void3 a b c -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679478938"><span id="local-6989586621679478940"><span id="local-6989586621679478942"><span id="local-6989586621679478944"><span id="local-6989586621679478946"><span id="local-6989586621679478948"><span id="local-6989586621679478950"><span class="annot"><span class="annottext">Eq (Void3 a b c)
Eq (Void3 a b c) =&gt;
(Void3 a b c -&gt; Void3 a b c -&gt; Ordering)
-&gt; (Void3 a b c -&gt; Void3 a b c -&gt; Bool)
-&gt; (Void3 a b c -&gt; Void3 a b c -&gt; Bool)
-&gt; (Void3 a b c -&gt; Void3 a b c -&gt; Bool)
-&gt; (Void3 a b c -&gt; Void3 a b c -&gt; Bool)
-&gt; (Void3 a b c -&gt; Void3 a b c -&gt; Void3 a b c)
-&gt; (Void3 a b c -&gt; Void3 a b c -&gt; Void3 a b c)
-&gt; Ord (Void3 a b c)
Void3 a b c -&gt; Void3 a b c -&gt; Bool
Void3 a b c -&gt; Void3 a b c -&gt; Ordering
Void3 a b c -&gt; Void3 a b c -&gt; Void3 a b c
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall k (a :: k) k (b :: k) k (c :: k). Eq (Void3 a b c)
forall k (a :: k) k (b :: k) k (c :: k).
Void3 a b c -&gt; Void3 a b c -&gt; Bool
forall k (a :: k) k (b :: k) k (c :: k).
Void3 a b c -&gt; Void3 a b c -&gt; Ordering
forall k (a :: k) k (b :: k) k (c :: k).
Void3 a b c -&gt; Void3 a b c -&gt; Void3 a b c
min :: Void3 a b c -&gt; Void3 a b c -&gt; Void3 a b c
$cmin :: forall k (a :: k) k (b :: k) k (c :: k).
Void3 a b c -&gt; Void3 a b c -&gt; Void3 a b c
max :: Void3 a b c -&gt; Void3 a b c -&gt; Void3 a b c
$cmax :: forall k (a :: k) k (b :: k) k (c :: k).
Void3 a b c -&gt; Void3 a b c -&gt; Void3 a b c
&gt;= :: Void3 a b c -&gt; Void3 a b c -&gt; Bool
$c&gt;= :: forall k (a :: k) k (b :: k) k (c :: k).
Void3 a b c -&gt; Void3 a b c -&gt; Bool
&gt; :: Void3 a b c -&gt; Void3 a b c -&gt; Bool
$c&gt; :: forall k (a :: k) k (b :: k) k (c :: k).
Void3 a b c -&gt; Void3 a b c -&gt; Bool
&lt;= :: Void3 a b c -&gt; Void3 a b c -&gt; Bool
$c&lt;= :: forall k (a :: k) k (b :: k) k (c :: k).
Void3 a b c -&gt; Void3 a b c -&gt; Bool
&lt; :: Void3 a b c -&gt; Void3 a b c -&gt; Bool
$c&lt; :: forall k (a :: k) k (b :: k) k (c :: k).
Void3 a b c -&gt; Void3 a b c -&gt; Bool
compare :: Void3 a b c -&gt; Void3 a b c -&gt; Ordering
$ccompare :: forall k (a :: k) k (b :: k) k (c :: k).
Void3 a b c -&gt; Void3 a b c -&gt; Ordering
$cp1Ord :: forall k (a :: k) k (b :: k) k (c :: k). Eq (Void3 a b c)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679478934"><span id="local-6989586621679478936"><span class="annot"><span class="annottext">(a -&gt; b) -&gt; Void3 a b a -&gt; Void3 a b b
(forall a b. (a -&gt; b) -&gt; Void3 a b a -&gt; Void3 a b b)
-&gt; (forall a b. a -&gt; Void3 a b b -&gt; Void3 a b a)
-&gt; Functor (Void3 a b)
forall k (a :: k) k (b :: k) a b. a -&gt; Void3 a b b -&gt; Void3 a b a
forall k (a :: k) k (b :: k) a b.
(a -&gt; b) -&gt; Void3 a b a -&gt; Void3 a b b
forall a b. a -&gt; Void3 a b b -&gt; Void3 a b a
forall a b. (a -&gt; b) -&gt; Void3 a b a -&gt; Void3 a b b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: a -&gt; Void3 a b b -&gt; Void3 a b a
$c&lt;$ :: forall k (a :: k) k (b :: k) a b. a -&gt; Void3 a b b -&gt; Void3 a b a
fmap :: (a -&gt; b) -&gt; Void3 a b a -&gt; Void3 a b b
$cfmap :: forall k (a :: k) k (b :: k) a b.
(a -&gt; b) -&gt; Void3 a b a -&gt; Void3 a b b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679478900"><span id="local-6989586621679478902"><span id="local-6989586621679478904"><span id="local-6989586621679478906"><span id="local-6989586621679478908"><span id="local-6989586621679478910"><span id="local-6989586621679478912"><span id="local-6989586621679478914"><span id="local-6989586621679478916"><span id="local-6989586621679478918"><span id="local-6989586621679478920"><span id="local-6989586621679478922"><span id="local-6989586621679478924"><span id="local-6989586621679478926"><span id="local-6989586621679478928"><span id="local-6989586621679478930"><span id="local-6989586621679478932"><span class="annot"><span class="annottext">(a -&gt; m) -&gt; Void3 a b a -&gt; m
(forall m. Monoid m =&gt; Void3 a b m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Void3 a b a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Void3 a b a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Void3 a b a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Void3 a b a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Void3 a b a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Void3 a b a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; Void3 a b a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; Void3 a b a -&gt; a)
-&gt; (forall a. Void3 a b a -&gt; [a])
-&gt; (forall a. Void3 a b a -&gt; Bool)
-&gt; (forall a. Void3 a b a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; Void3 a b a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; Void3 a b a -&gt; a)
-&gt; (forall a. Ord a =&gt; Void3 a b a -&gt; a)
-&gt; (forall a. Num a =&gt; Void3 a b a -&gt; a)
-&gt; (forall a. Num a =&gt; Void3 a b a -&gt; a)
-&gt; Foldable (Void3 a b)
forall a. Eq a =&gt; a -&gt; Void3 a b a -&gt; Bool
forall a. Num a =&gt; Void3 a b a -&gt; a
forall a. Ord a =&gt; Void3 a b a -&gt; a
forall m. Monoid m =&gt; Void3 a b m -&gt; m
forall a. Void3 a b a -&gt; Bool
forall a. Void3 a b a -&gt; Int
forall a. Void3 a b a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; Void3 a b a -&gt; a
forall k (a :: k) k (b :: k) a. Eq a =&gt; a -&gt; Void3 a b a -&gt; Bool
forall k (a :: k) k (b :: k) a. Num a =&gt; Void3 a b a -&gt; a
forall k (a :: k) k (b :: k) a. Ord a =&gt; Void3 a b a -&gt; a
forall k (a :: k) k (b :: k) m. Monoid m =&gt; Void3 a b m -&gt; m
forall k (a :: k) k (b :: k) a. Void3 a b a -&gt; Bool
forall k (a :: k) k (b :: k) a. Void3 a b a -&gt; Int
forall k (a :: k) k (b :: k) a. Void3 a b a -&gt; [a]
forall k (a :: k) k (b :: k) a. (a -&gt; a -&gt; a) -&gt; Void3 a b a -&gt; a
forall k (a :: k) k (b :: k) m a.
Monoid m =&gt;
(a -&gt; m) -&gt; Void3 a b a -&gt; m
forall k (a :: k) k (b :: k) b a.
(b -&gt; a -&gt; b) -&gt; b -&gt; Void3 a b a -&gt; b
forall k (a :: k) k (b :: k) a b.
(a -&gt; b -&gt; b) -&gt; b -&gt; Void3 a b a -&gt; b
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Void3 a b a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Void3 a b a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Void3 a b a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: Void3 a b a -&gt; a
$cproduct :: forall k (a :: k) k (b :: k) a. Num a =&gt; Void3 a b a -&gt; a
sum :: Void3 a b a -&gt; a
$csum :: forall k (a :: k) k (b :: k) a. Num a =&gt; Void3 a b a -&gt; a
minimum :: Void3 a b a -&gt; a
$cminimum :: forall k (a :: k) k (b :: k) a. Ord a =&gt; Void3 a b a -&gt; a
maximum :: Void3 a b a -&gt; a
$cmaximum :: forall k (a :: k) k (b :: k) a. Ord a =&gt; Void3 a b a -&gt; a
elem :: a -&gt; Void3 a b a -&gt; Bool
$celem :: forall k (a :: k) k (b :: k) a. Eq a =&gt; a -&gt; Void3 a b a -&gt; Bool
length :: Void3 a b a -&gt; Int
$clength :: forall k (a :: k) k (b :: k) a. Void3 a b a -&gt; Int
null :: Void3 a b a -&gt; Bool
$cnull :: forall k (a :: k) k (b :: k) a. Void3 a b a -&gt; Bool
toList :: Void3 a b a -&gt; [a]
$ctoList :: forall k (a :: k) k (b :: k) a. Void3 a b a -&gt; [a]
foldl1 :: (a -&gt; a -&gt; a) -&gt; Void3 a b a -&gt; a
$cfoldl1 :: forall k (a :: k) k (b :: k) a. (a -&gt; a -&gt; a) -&gt; Void3 a b a -&gt; a
foldr1 :: (a -&gt; a -&gt; a) -&gt; Void3 a b a -&gt; a
$cfoldr1 :: forall k (a :: k) k (b :: k) a. (a -&gt; a -&gt; a) -&gt; Void3 a b a -&gt; a
foldl' :: (b -&gt; a -&gt; b) -&gt; b -&gt; Void3 a b a -&gt; b
$cfoldl' :: forall k (a :: k) k (b :: k) b a.
(b -&gt; a -&gt; b) -&gt; b -&gt; Void3 a b a -&gt; b
foldl :: (b -&gt; a -&gt; b) -&gt; b -&gt; Void3 a b a -&gt; b
$cfoldl :: forall k (a :: k) k (b :: k) b a.
(b -&gt; a -&gt; b) -&gt; b -&gt; Void3 a b a -&gt; b
foldr' :: (a -&gt; b -&gt; b) -&gt; b -&gt; Void3 a b a -&gt; b
$cfoldr' :: forall k (a :: k) k (b :: k) a b.
(a -&gt; b -&gt; b) -&gt; b -&gt; Void3 a b a -&gt; b
foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; Void3 a b a -&gt; b
$cfoldr :: forall k (a :: k) k (b :: k) a b.
(a -&gt; b -&gt; b) -&gt; b -&gt; Void3 a b a -&gt; b
foldMap' :: (a -&gt; m) -&gt; Void3 a b a -&gt; m
$cfoldMap' :: forall k (a :: k) k (b :: k) m a.
Monoid m =&gt;
(a -&gt; m) -&gt; Void3 a b a -&gt; m
foldMap :: (a -&gt; m) -&gt; Void3 a b a -&gt; m
$cfoldMap :: forall k (a :: k) k (b :: k) m a.
Monoid m =&gt;
(a -&gt; m) -&gt; Void3 a b a -&gt; m
fold :: Void3 a b m -&gt; m
$cfold :: forall k (a :: k) k (b :: k) m. Monoid m =&gt; Void3 a b m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679478890"><span id="local-6989586621679478892"><span id="local-6989586621679478894"><span id="local-6989586621679478896"><span class="annot"><span class="annottext">Functor (Void3 a b)
Foldable (Void3 a b)
(Functor (Void3 a b), Foldable (Void3 a b)) =&gt;
(forall (f :: * -&gt; *) a b.
 Applicative f =&gt;
 (a -&gt; f b) -&gt; Void3 a b a -&gt; f (Void3 a b b))
-&gt; (forall (f :: * -&gt; *) a.
    Applicative f =&gt;
    Void3 a b (f a) -&gt; f (Void3 a b a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; Void3 a b a -&gt; m (Void3 a b b))
-&gt; (forall (m :: * -&gt; *) a.
    Monad m =&gt;
    Void3 a b (m a) -&gt; m (Void3 a b a))
-&gt; Traversable (Void3 a b)
(a -&gt; f b) -&gt; Void3 a b a -&gt; f (Void3 a b b)
forall k (a :: k) k (b :: k). Functor (Void3 a b)
forall k (a :: k) k (b :: k). Foldable (Void3 a b)
forall k (a :: k) k (b :: k) (m :: * -&gt; *) a.
Monad m =&gt;
Void3 a b (m a) -&gt; m (Void3 a b a)
forall k (a :: k) k (b :: k) (f :: * -&gt; *) a.
Applicative f =&gt;
Void3 a b (f a) -&gt; f (Void3 a b a)
forall k (a :: k) k (b :: k) (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Void3 a b a -&gt; m (Void3 a b b)
forall k (a :: k) k (b :: k) (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Void3 a b a -&gt; f (Void3 a b b)
forall (t :: * -&gt; *).
(Functor t, Foldable t) =&gt;
(forall (f :: * -&gt; *) a b.
 Applicative f =&gt;
 (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a.
Monad m =&gt;
Void3 a b (m a) -&gt; m (Void3 a b a)
forall (f :: * -&gt; *) a.
Applicative f =&gt;
Void3 a b (f a) -&gt; f (Void3 a b a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Void3 a b a -&gt; m (Void3 a b b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Void3 a b a -&gt; f (Void3 a b b)
sequence :: Void3 a b (m a) -&gt; m (Void3 a b a)
$csequence :: forall k (a :: k) k (b :: k) (m :: * -&gt; *) a.
Monad m =&gt;
Void3 a b (m a) -&gt; m (Void3 a b a)
mapM :: (a -&gt; m b) -&gt; Void3 a b a -&gt; m (Void3 a b b)
$cmapM :: forall k (a :: k) k (b :: k) (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Void3 a b a -&gt; m (Void3 a b b)
sequenceA :: Void3 a b (f a) -&gt; f (Void3 a b a)
$csequenceA :: forall k (a :: k) k (b :: k) (f :: * -&gt; *) a.
Applicative f =&gt;
Void3 a b (f a) -&gt; f (Void3 a b a)
traverse :: (a -&gt; f b) -&gt; Void3 a b a -&gt; f (Void3 a b b)
$ctraverse :: forall k (a :: k) k (b :: k) (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Void3 a b a -&gt; f (Void3 a b b)
$cp2Traversable :: forall k (a :: k) k (b :: k). Foldable (Void3 a b)
$cp1Traversable :: forall k (a :: k) k (b :: k). Functor (Void3 a b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">(forall x. Void3 a b c -&gt; Rep (Void3 a b c) x)
-&gt; (forall x. Rep (Void3 a b c) x -&gt; Void3 a b c)
-&gt; Generic (Void3 a b c)
forall x. Rep (Void3 a b c) x -&gt; Void3 a b c
forall x. Void3 a b c -&gt; Rep (Void3 a b c) x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall k (a :: k) k (b :: k) k (c :: k) x.
Rep (Void3 a b c) x -&gt; Void3 a b c
forall k (a :: k) k (b :: k) k (c :: k) x.
Void3 a b c -&gt; Rep (Void3 a b c) x
$cto :: forall k (a :: k) k (b :: k) k (c :: k) x.
Rep (Void3 a b c) x -&gt; Void3 a b c
$cfrom :: forall k (a :: k) k (b :: k) k (c :: k) x.
Void3 a b c -&gt; Rep (Void3 a b c) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">,</span><span> </span><span id="%24tVoid3"><span id="local-6989586621679478859"><span id="local-6989586621679478861"><span id="local-6989586621679478863"><span id="local-6989586621679478865"><span id="local-6989586621679478867"><span id="local-6989586621679478869"><span id="local-6989586621679478871"><span id="local-6989586621679478873"><span id="local-6989586621679478875"><span id="local-6989586621679478877"><span id="local-6989586621679478879"><span id="local-6989586621679478881"><span id="local-6989586621679478883"><span id="local-6989586621679478885"><span class="annot"><span class="annottext">Typeable (Void3 a b c)
DataType
Typeable (Void3 a b c) =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; Void3 a b c -&gt; c (Void3 a b c))
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Void3 a b c))
-&gt; (Void3 a b c -&gt; Constr)
-&gt; (Void3 a b c -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Void3 a b c)))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e))
    -&gt; Maybe (c (Void3 a b c)))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; Void3 a b c -&gt; Void3 a b c)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Void3 a b c -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Void3 a b c -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Void3 a b c -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Void3 a b c -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Void3 a b c -&gt; m (Void3 a b c))
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Void3 a b c -&gt; m (Void3 a b c))
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Void3 a b c -&gt; m (Void3 a b c))
-&gt; Data (Void3 a b c)
Void3 a b c -&gt; DataType
Void3 a b c -&gt; Constr
(forall b. Data b =&gt; b -&gt; b) -&gt; Void3 a b c -&gt; Void3 a b c
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Void3 a b c -&gt; c (Void3 a b c)
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Void3 a b c)
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Void3 a b c -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Void3 a b c -&gt; [u]
forall k (a :: k) k (b :: k) k (c :: k).
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k) =&gt;
Typeable (Void3 a b c)
forall k (a :: k) k (b :: k) k (c :: k).
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k) =&gt;
Void3 a b c -&gt; DataType
forall k (a :: k) k (b :: k) k (c :: k).
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k) =&gt;
Void3 a b c -&gt; Constr
forall k (a :: k) k (b :: k) k (c :: k).
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k) =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Void3 a b c -&gt; Void3 a b c
forall k (a :: k) k (b :: k) k (c :: k) u.
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k) =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Void3 a b c -&gt; u
forall k (a :: k) k (b :: k) k (c :: k) u.
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k) =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; Void3 a b c -&gt; [u]
forall k (a :: k) k (b :: k) k (c :: k) r r'.
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k) =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Void3 a b c -&gt; r
forall k (a :: k) k (b :: k) k (c :: k) r r'.
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k) =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Void3 a b c -&gt; r
forall k (a :: k) k (b :: k) k (c :: k) (m :: * -&gt; *).
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Void3 a b c -&gt; m (Void3 a b c)
forall k (a :: k) k (b :: k) k (c :: k) (m :: * -&gt; *).
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Void3 a b c -&gt; m (Void3 a b c)
forall k (a :: k) k (b :: k) k (c :: k) (c :: * -&gt; *).
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k) =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Void3 a b c)
forall k (a :: k) k (b :: k) k (c :: k) (c :: * -&gt; *).
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k) =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Void3 a b c -&gt; c (Void3 a b c)
forall k (a :: k) k (b :: k) k (c :: k) (t :: * -&gt; *)
       (c :: * -&gt; *).
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Void3 a b c))
forall k (a :: k) k (b :: k) k (c :: k) (t :: * -&gt; * -&gt; *)
       (c :: * -&gt; *).
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Void3 a b c))
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Void3 a b c -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Void3 a b c -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Void3 a b c -&gt; m (Void3 a b c)
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Void3 a b c -&gt; m (Void3 a b c)
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Void3 a b c)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Void3 a b c -&gt; c (Void3 a b c)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Void3 a b c))
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Void3 a b c))
$tVoid3 :: DataType
gmapMo :: (forall d. Data d =&gt; d -&gt; m d) -&gt; Void3 a b c -&gt; m (Void3 a b c)
$cgmapMo :: forall k (a :: k) k (b :: k) k (c :: k) (m :: * -&gt; *).
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Void3 a b c -&gt; m (Void3 a b c)
gmapMp :: (forall d. Data d =&gt; d -&gt; m d) -&gt; Void3 a b c -&gt; m (Void3 a b c)
$cgmapMp :: forall k (a :: k) k (b :: k) k (c :: k) (m :: * -&gt; *).
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Void3 a b c -&gt; m (Void3 a b c)
gmapM :: (forall d. Data d =&gt; d -&gt; m d) -&gt; Void3 a b c -&gt; m (Void3 a b c)
$cgmapM :: forall k (a :: k) k (b :: k) k (c :: k) (m :: * -&gt; *).
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Void3 a b c -&gt; m (Void3 a b c)
gmapQi :: Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Void3 a b c -&gt; u
$cgmapQi :: forall k (a :: k) k (b :: k) k (c :: k) u.
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k) =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Void3 a b c -&gt; u
gmapQ :: (forall d. Data d =&gt; d -&gt; u) -&gt; Void3 a b c -&gt; [u]
$cgmapQ :: forall k (a :: k) k (b :: k) k (c :: k) u.
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k) =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; Void3 a b c -&gt; [u]
gmapQr :: (r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Void3 a b c -&gt; r
$cgmapQr :: forall k (a :: k) k (b :: k) k (c :: k) r r'.
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k) =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Void3 a b c -&gt; r
gmapQl :: (r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Void3 a b c -&gt; r
$cgmapQl :: forall k (a :: k) k (b :: k) k (c :: k) r r'.
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k) =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Void3 a b c -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Void3 a b c -&gt; Void3 a b c
$cgmapT :: forall k (a :: k) k (b :: k) k (c :: k).
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k) =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Void3 a b c -&gt; Void3 a b c
dataCast2 :: (forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Void3 a b c))
$cdataCast2 :: forall k (a :: k) k (b :: k) k (c :: k) (t :: * -&gt; * -&gt; *)
       (c :: * -&gt; *).
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Void3 a b c))
dataCast1 :: (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Void3 a b c))
$cdataCast1 :: forall k (a :: k) k (b :: k) k (c :: k) (t :: * -&gt; *)
       (c :: * -&gt; *).
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Void3 a b c))
dataTypeOf :: Void3 a b c -&gt; DataType
$cdataTypeOf :: forall k (a :: k) k (b :: k) k (c :: k).
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k) =&gt;
Void3 a b c -&gt; DataType
toConstr :: Void3 a b c -&gt; Constr
$ctoConstr :: forall k (a :: k) k (b :: k) k (c :: k).
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k) =&gt;
Void3 a b c -&gt; Constr
gunfold :: (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Void3 a b c)
$cgunfold :: forall k (a :: k) k (b :: k) k (c :: k) (c :: * -&gt; *).
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k) =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Void3 a b c)
gfoldl :: (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Void3 a b c -&gt; c (Void3 a b c)
$cgfoldl :: forall k (a :: k) k (b :: k) k (c :: k) (c :: * -&gt; *).
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k) =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Void3 a b c -&gt; c (Void3 a b c)
$cp1Data :: forall k (a :: k) k (b :: k) k (c :: k).
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k) =&gt;
Typeable (Void3 a b c)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-389"></span><span>
</span><span id="line-390"></span><span id="local-6989586621679478854"><span id="local-6989586621679478856"><span id="local-6989586621679478972"><span id="local-6989586621679478973"><span class="hs-identifier">deriveShow1</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Void3</span></span></span></span></span><span>
</span><span id="line-391"></span><span id="local-6989586621679478846"><span id="local-6989586621679478848"><span id="local-6989586621679478850"><span id="local-6989586621679478852"><span id="local-6989586621679478972"><span id="local-6989586621679478973"><span class="hs-identifier">deriveRead1</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Void3</span></span></span></span></span></span></span><span>
</span><span id="line-392"></span><span id="local-6989586621679478844"><span id="local-6989586621679478972"><span id="local-6989586621679478973"><span class="hs-identifier">deriveEq1</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Void3</span></span></span></span><span>
</span><span id="line-393"></span><span id="local-6989586621679478841"><span id="local-6989586621679478972"><span id="local-6989586621679478973"><span class="hs-identifier">deriveOrd1</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Void3</span></span></span></span><span>
</span><span id="line-394"></span><span>
</span><span id="line-395"></span><span id="local-6989586621679478838"><span id="local-6989586621679478839"><span id="local-6989586621679478840"><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679478833"><span id="local-6989586621679478835"><span class="annot"><span class="hs-identifier hs-type">Semigroup</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Void3"><span class="hs-identifier hs-type">Void3</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679478840"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679478839"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679478838"><span class="hs-identifier hs-type">c</span></a></span><span class="hs-special">)</span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-396"></span><span>    </span><span id="local-6989586621679478832"><span class="annot"><span class="annottext">x :: Void3 a b c
</span><a href="#local-6989586621679478832"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679478831"><span class="annot"><span class="annottext">&lt;&gt; :: Void3 a b c -&gt; Void3 a b c -&gt; Void3 a b c
</span><span class="hs-operator hs-var hs-var hs-var hs-var">&lt;&gt;</span></span></span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Void3 a b c
</span><a href="#local-6989586621679478832"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span></span></span></span><span>
</span><span id="line-397"></span><span>
</span><span id="line-398"></span><span id="local-6989586621679478829"><span id="local-6989586621679478830"><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679478823"><span id="local-6989586621679478825"><span class="annot"><span class="hs-identifier hs-type">Alt</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Void3"><span class="hs-identifier hs-type">Void3</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679478830"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679478829"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-399"></span><span>    </span><span id="local-6989586621679478822"><span class="annot"><span class="annottext">x :: Void3 a b a
</span><a href="#local-6989586621679478822"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679478821"><span class="annot"><span class="annottext">&lt;!&gt; :: Void3 a b a -&gt; Void3 a b a -&gt; Void3 a b a
</span><a href="#local-6989586621679478821"><span class="hs-operator hs-var hs-var hs-var hs-var">&lt;!&gt;</span></a></span></span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Void3 a b a -&gt; Void3 a b a
forall k k k (f :: k) (g :: k) (a :: k) (t :: k -&gt; k -&gt; k -&gt; *).
Void3 f g a -&gt; t f g a
</span><a href="Control.Applicative.Step.html#absurd3"><span class="hs-identifier hs-var">absurd3</span></a></span><span> </span><span class="annot"><span class="annottext">Void3 a b a
</span><a href="#local-6989586621679478822"><span class="hs-identifier hs-var">x</span></a></span></span></span><span>
</span><span id="line-400"></span><span>
</span><span id="line-401"></span><span id="local-6989586621679478819"><span id="local-6989586621679478820"><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679478815"><span class="annot"><span class="hs-identifier hs-type">Bind</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Void3"><span class="hs-identifier hs-type">Void3</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679478820"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679478819"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-402"></span><span>    </span><span id="local-6989586621679478814"><span class="annot"><span class="annottext">x :: Void3 a b a
</span><a href="#local-6989586621679478814"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679478813"><span class="annot"><span class="annottext">&gt;&gt;- :: Void3 a b a -&gt; (a -&gt; Void3 a b b) -&gt; Void3 a b b
</span><a href="#local-6989586621679478813"><span class="hs-operator hs-var hs-var hs-var hs-var">&gt;&gt;-</span></a></span></span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Void3 a b a
</span><a href="#local-6989586621679478814"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span></span></span><span>
</span><span id="line-403"></span><span>
</span><span id="line-404"></span><span id="local-6989586621679478811"><span id="local-6989586621679478812"><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679478803"><span id="local-6989586621679478805"><span id="local-6989586621679478807"><span class="annot"><span class="hs-identifier hs-type">Apply</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Void3"><span class="hs-identifier hs-type">Void3</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679478812"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679478811"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-405"></span><span>    </span><span id="local-6989586621679478802"><span class="annot"><span class="annottext">x :: Void3 a b (a -&gt; b)
</span><a href="#local-6989586621679478802"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679478801"><span class="annot"><span class="annottext">&lt;.&gt; :: Void3 a b (a -&gt; b) -&gt; Void3 a b a -&gt; Void3 a b b
</span><a href="#local-6989586621679478801"><span class="hs-operator hs-var hs-var hs-var hs-var">&lt;.&gt;</span></a></span></span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Void3 a b (a -&gt; b)
</span><a href="#local-6989586621679478802"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span></span></span><span>
</span><span id="line-406"></span><span>
</span><span id="line-407"></span><span class="hs-comment">-- | If you treat a @'Void3' f a@ as a binary functor combinator, then</span><span>
</span><span id="line-408"></span><span class="hs-comment">-- 'absurd3' lets you convert from a @'Void3' f a@ into a @t f a@ for any</span><span>
</span><span id="line-409"></span><span class="hs-comment">-- functor combinator @t@.</span><span>
</span><span id="line-410"></span><span id="local-6989586621679479787"><span id="local-6989586621679479788"><span id="local-6989586621679479789"><span id="local-6989586621679479790"><span class="annot"><a href="Control.Applicative.Step.html#absurd3"><span class="hs-identifier hs-type">absurd3</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#Void3"><span class="hs-identifier hs-type">Void3</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679479790"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679479789"><span class="hs-identifier hs-type">g</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679479788"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679479787"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679479790"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679479789"><span class="hs-identifier hs-type">g</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679479788"><span class="hs-identifier hs-type">a</span></a></span></span></span></span></span><span>
</span><span id="line-411"></span><span id="absurd3"><span class="annot"><span class="annottext">absurd3 :: Void3 f g a -&gt; t f g a
</span><a href="Control.Applicative.Step.html#absurd3"><span class="hs-identifier hs-var hs-var">absurd3</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span>
</span><span id="line-412"></span></pre></body></html>