<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-pragma">{-# LANGUAGE AllowAmbiguousTypes        #-}</span><span>
</span><span id="line-2"></span><span class="hs-pragma">{-# LANGUAGE DeriveDataTypeable         #-}</span><span>
</span><span id="line-3"></span><span class="hs-pragma">{-# LANGUAGE DeriveFoldable             #-}</span><span>
</span><span id="line-4"></span><span class="hs-pragma">{-# LANGUAGE DeriveFunctor              #-}</span><span>
</span><span id="line-5"></span><span class="hs-pragma">{-# LANGUAGE DeriveGeneric              #-}</span><span>
</span><span id="line-6"></span><span class="hs-pragma">{-# LANGUAGE DeriveTraversable          #-}</span><span>
</span><span id="line-7"></span><span class="hs-pragma">{-# LANGUAGE EmptyCase                  #-}</span><span>
</span><span id="line-8"></span><span class="hs-pragma">{-# LANGUAGE EmptyDataDeriving          #-}</span><span>
</span><span id="line-9"></span><span class="hs-pragma">{-# LANGUAGE ExistentialQuantification  #-}</span><span>
</span><span id="line-10"></span><span class="hs-pragma">{-# LANGUAGE FlexibleInstances          #-}</span><span>
</span><span id="line-11"></span><span class="hs-pragma">{-# LANGUAGE GADTs                      #-}</span><span>
</span><span id="line-12"></span><span class="hs-pragma">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span><span>
</span><span id="line-13"></span><span class="hs-pragma">{-# LANGUAGE LambdaCase                 #-}</span><span>
</span><span id="line-14"></span><span class="hs-pragma">{-# LANGUAGE PolyKinds                  #-}</span><span>
</span><span id="line-15"></span><span class="hs-pragma">{-# LANGUAGE ScopedTypeVariables        #-}</span><span>
</span><span id="line-16"></span><span class="hs-pragma">{-# LANGUAGE TemplateHaskell            #-}</span><span>
</span><span id="line-17"></span><span class="hs-pragma">{-# LANGUAGE TypeApplications           #-}</span><span>
</span><span id="line-18"></span><span class="hs-pragma">{-# LANGUAGE TypeInType                 #-}</span><span>
</span><span id="line-19"></span><span class="hs-pragma">{-# LANGUAGE TypeOperators              #-}</span><span>
</span><span id="line-20"></span><span>
</span><span id="line-21"></span><span class="hs-comment">-- |</span><span>
</span><span id="line-22"></span><span class="hs-comment">-- Module      : Control.Applicative.Step</span><span>
</span><span id="line-23"></span><span class="hs-comment">-- Copyright   : (c) Justin Le 2019</span><span>
</span><span id="line-24"></span><span class="hs-comment">-- License     : BSD3</span><span>
</span><span id="line-25"></span><span class="hs-comment">--</span><span>
</span><span id="line-26"></span><span class="hs-comment">-- Maintainer  : justin@jle.im</span><span>
</span><span id="line-27"></span><span class="hs-comment">-- Stability   : experimental</span><span>
</span><span id="line-28"></span><span class="hs-comment">-- Portability : non-portable</span><span>
</span><span id="line-29"></span><span class="hs-comment">--</span><span>
</span><span id="line-30"></span><span class="hs-comment">-- This module provides functor combinators that are the fixed points of</span><span>
</span><span id="line-31"></span><span class="hs-comment">-- applications of ':+:' and 'Data.Functor.These.These1'.  They are useful</span><span>
</span><span id="line-32"></span><span class="hs-comment">-- for their 'Data.HFunctor.Interpret.Interpret' instances, along with</span><span>
</span><span id="line-33"></span><span class="hs-comment">-- their relationship to the 'Data.HBifunctor.Tensor.Monoidal' instances of</span><span>
</span><span id="line-34"></span><span class="hs-comment">-- ':+:' and 'Data.Functor.These.These1'.</span><span>
</span><span id="line-35"></span><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Control.Applicative.Step</span><span> </span><span class="hs-special">(</span><span>
</span><span id="line-36"></span><span>  </span><span class="annot"><span class="hs-comment">-- * Fixed Points</span></span><span>
</span><span id="line-37"></span><span>    </span><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier">Step</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><span id="line-38"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier">Steps</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><span id="line-39"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#Flagged"><span class="hs-identifier">Flagged</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><span id="line-40"></span><span>  </span><span class="annot"><span class="hs-comment">-- ** Steppers</span></span><span>
</span><span id="line-41"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#stepUp"><span class="hs-identifier">stepUp</span></a></span><span>
</span><span id="line-42"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#stepDown"><span class="hs-identifier">stepDown</span></a></span><span>
</span><span id="line-43"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#stepping"><span class="hs-identifier">stepping</span></a></span><span>
</span><span id="line-44"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#stepsUp"><span class="hs-identifier">stepsUp</span></a></span><span>
</span><span id="line-45"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#stepsDown"><span class="hs-identifier">stepsDown</span></a></span><span>
</span><span id="line-46"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#steppings"><span class="hs-identifier">steppings</span></a></span><span>
</span><span id="line-47"></span><span>  </span><span class="annot"><span class="hs-comment">-- * Void</span></span><span>
</span><span id="line-48"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#absurd1"><span class="hs-identifier">absurd1</span></a></span><span>
</span><span id="line-49"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#Void2"><span class="hs-identifier">Void2</span></a></span><span>
</span><span id="line-50"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#absurd2"><span class="hs-identifier">absurd2</span></a></span><span>
</span><span id="line-51"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#Void3"><span class="hs-identifier">Void3</span></a></span><span>
</span><span id="line-52"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#absurd3"><span class="hs-identifier">absurd3</span></a></span><span>
</span><span id="line-53"></span><span>  </span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-54"></span><span>
</span><span id="line-55"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Control.Natural</span></span><span>
</span><span id="line-56"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><a href="Control.Natural.IsoF.html"><span class="hs-identifier">Control.Natural.IsoF</span></a></span><span>
</span><span id="line-57"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.Bifunctor</span></span><span>
</span><span id="line-58"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.Data</span></span><span>
</span><span id="line-59"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.Deriving</span></span><span>
</span><span id="line-60"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.Functor.Alt</span></span><span>
</span><span id="line-61"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.Functor.Bind</span></span><span>
</span><span id="line-62"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.Functor.These</span></span><span>
</span><span id="line-63"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.Map.NonEmpty</span></span><span>          </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">NEMap</span></span><span class="hs-special">)</span><span>
</span><span id="line-64"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.Pointed</span></span><span>
</span><span id="line-65"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.Semigroup</span></span><span>
</span><span id="line-66"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.Semigroup.Foldable</span></span><span>
</span><span id="line-67"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.Semigroup.Traversable</span></span><span>
</span><span id="line-68"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.These</span></span><span>
</span><span id="line-69"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">GHC.Generics</span></span><span>
</span><span id="line-70"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">GHC.Natural</span></span><span>
</span><span id="line-71"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><span class="hs-identifier">Data.Map.NonEmpty</span></span><span>          </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">NEM</span></span><span>
</span><span id="line-72"></span><span>
</span><span id="line-73"></span><span class="hs-comment">-- | An @f a@, along with a 'Natural' index.</span><span>
</span><span id="line-74"></span><span class="hs-comment">--</span><span>
</span><span id="line-75"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-76"></span><span class="hs-comment">-- 'Step' f a ~ ('Natural', f a)</span><span>
</span><span id="line-77"></span><span class="hs-comment">-- Step f   ~ ((,) Natural) ':.:' f       -- functor composition</span><span>
</span><span id="line-78"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-79"></span><span class="hs-comment">--</span><span>
</span><span id="line-80"></span><span class="hs-comment">-- It is the fixed point of infinite applications of ':+:' (functor sums).</span><span>
</span><span id="line-81"></span><span class="hs-comment">--</span><span>
</span><span id="line-82"></span><span class="hs-comment">-- Intuitively, in an infinite @f :+: f :+: f :+: f ...@, you have</span><span>
</span><span id="line-83"></span><span class="hs-comment">-- exactly one @f@ /somewhere/.  A @'Step' f a@ has that @f@, with</span><span>
</span><span id="line-84"></span><span class="hs-comment">-- a 'Natural' giving you &quot;where&quot; the @f@ is in the long chain.</span><span>
</span><span id="line-85"></span><span class="hs-comment">--</span><span>
</span><span id="line-86"></span><span class="hs-comment">-- Can be useful for using with the 'Data.HBifunctor.Tensor.Monoidal'</span><span>
</span><span id="line-87"></span><span class="hs-comment">-- instance of ':+:'.</span><span>
</span><span id="line-88"></span><span class="hs-comment">--</span><span>
</span><span id="line-89"></span><span class="hs-comment">-- 'Data.HFunctor.Interpret.interpret'ing it requires no constraint on the</span><span>
</span><span id="line-90"></span><span class="hs-comment">-- target context.</span><span>
</span><span id="line-91"></span><span class="hs-comment">--</span><span>
</span><span id="line-92"></span><span class="hs-comment">-- Note that this type and its instances equivalent to</span><span>
</span><span id="line-93"></span><span class="hs-comment">-- @'Control.Comonad.Trans.Env.EnvT' ('Data.Semigroup.Sum' 'Natural')@.</span><span>
</span><span id="line-94"></span><span id="local-6989586621679407547"><span id="local-6989586621679407548"></span></span><span class="hs-keyword">data</span><span> </span><span id="Step"><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-var">Step</span></a></span></span><span> </span><span id="local-6989586621679408254"><span class="annot"><a href="#local-6989586621679408254"><span class="hs-identifier hs-type">f</span></a></span></span><span> </span><span id="local-6989586621679408253"><span class="annot"><a href="#local-6989586621679408253"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="Step"><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-var">Step</span></a></span></span><span> </span><span class="hs-special">{</span><span> </span><span id="stepPos"><span class="annot"><span class="annottext">Step f a -&gt; Natural
</span><a href="Control.Applicative.Step.html#stepPos"><span class="hs-identifier hs-var hs-var">stepPos</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Natural</span></span><span class="hs-special">,</span><span> </span><span id="stepVal"><span class="annot"><span class="annottext">Step f a -&gt; f a
</span><a href="Control.Applicative.Step.html#stepVal"><span class="hs-identifier hs-var hs-var">stepVal</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621679408254"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679408253"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-95"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679407538"><span id="local-6989586621679407540"><span id="local-6989586621679407542"><span class="annot"><span class="annottext">Int -&gt; Step f a -&gt; ShowS
[Step f a] -&gt; ShowS
Step f a -&gt; String
(Int -&gt; Step f a -&gt; ShowS)
-&gt; (Step f a -&gt; String) -&gt; ([Step f a] -&gt; ShowS) -&gt; Show (Step f a)
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
forall k (f :: k -&gt; *) (a :: k).
Show (f a) =&gt;
Int -&gt; Step f a -&gt; ShowS
forall k (f :: k -&gt; *) (a :: k). Show (f a) =&gt; [Step f a] -&gt; ShowS
forall k (f :: k -&gt; *) (a :: k). Show (f a) =&gt; Step f a -&gt; String
showList :: [Step f a] -&gt; ShowS
$cshowList :: forall k (f :: k -&gt; *) (a :: k). Show (f a) =&gt; [Step f a] -&gt; ShowS
show :: Step f a -&gt; String
$cshow :: forall k (f :: k -&gt; *) (a :: k). Show (f a) =&gt; Step f a -&gt; String
showsPrec :: Int -&gt; Step f a -&gt; ShowS
$cshowsPrec :: forall k (f :: k -&gt; *) (a :: k).
Show (f a) =&gt;
Int -&gt; Step f a -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679407529"><span id="local-6989586621679407531"><span id="local-6989586621679407533"><span id="local-6989586621679407535"><span class="annot"><span class="annottext">ReadPrec [Step f a]
ReadPrec (Step f a)
Int -&gt; ReadS (Step f a)
ReadS [Step f a]
(Int -&gt; ReadS (Step f a))
-&gt; ReadS [Step f a]
-&gt; ReadPrec (Step f a)
-&gt; ReadPrec [Step f a]
-&gt; Read (Step f a)
forall a.
(Int -&gt; ReadS a)
-&gt; ReadS [a] -&gt; ReadPrec a -&gt; ReadPrec [a] -&gt; Read a
forall k (f :: k -&gt; *) (a :: k). Read (f a) =&gt; ReadPrec [Step f a]
forall k (f :: k -&gt; *) (a :: k). Read (f a) =&gt; ReadPrec (Step f a)
forall k (f :: k -&gt; *) (a :: k).
Read (f a) =&gt;
Int -&gt; ReadS (Step f a)
forall k (f :: k -&gt; *) (a :: k). Read (f a) =&gt; ReadS [Step f a]
readListPrec :: ReadPrec [Step f a]
$creadListPrec :: forall k (f :: k -&gt; *) (a :: k). Read (f a) =&gt; ReadPrec [Step f a]
readPrec :: ReadPrec (Step f a)
$creadPrec :: forall k (f :: k -&gt; *) (a :: k). Read (f a) =&gt; ReadPrec (Step f a)
readList :: ReadS [Step f a]
$creadList :: forall k (f :: k -&gt; *) (a :: k). Read (f a) =&gt; ReadS [Step f a]
readsPrec :: Int -&gt; ReadS (Step f a)
$creadsPrec :: forall k (f :: k -&gt; *) (a :: k).
Read (f a) =&gt;
Int -&gt; ReadS (Step f a)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Read</span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679407524"><span id="local-6989586621679407526"><span class="annot"><span class="annottext">Step f a -&gt; Step f a -&gt; Bool
(Step f a -&gt; Step f a -&gt; Bool)
-&gt; (Step f a -&gt; Step f a -&gt; Bool) -&gt; Eq (Step f a)
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
forall k (f :: k -&gt; *) (a :: k).
Eq (f a) =&gt;
Step f a -&gt; Step f a -&gt; Bool
/= :: Step f a -&gt; Step f a -&gt; Bool
$c/= :: forall k (f :: k -&gt; *) (a :: k).
Eq (f a) =&gt;
Step f a -&gt; Step f a -&gt; Bool
== :: Step f a -&gt; Step f a -&gt; Bool
$c== :: forall k (f :: k -&gt; *) (a :: k).
Eq (f a) =&gt;
Step f a -&gt; Step f a -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679407508"><span id="local-6989586621679407510"><span id="local-6989586621679407512"><span id="local-6989586621679407514"><span id="local-6989586621679407516"><span id="local-6989586621679407518"><span id="local-6989586621679407520"><span class="annot"><span class="annottext">Eq (Step f a)
Eq (Step f a) =&gt;
(Step f a -&gt; Step f a -&gt; Ordering)
-&gt; (Step f a -&gt; Step f a -&gt; Bool)
-&gt; (Step f a -&gt; Step f a -&gt; Bool)
-&gt; (Step f a -&gt; Step f a -&gt; Bool)
-&gt; (Step f a -&gt; Step f a -&gt; Bool)
-&gt; (Step f a -&gt; Step f a -&gt; Step f a)
-&gt; (Step f a -&gt; Step f a -&gt; Step f a)
-&gt; Ord (Step f a)
Step f a -&gt; Step f a -&gt; Bool
Step f a -&gt; Step f a -&gt; Ordering
Step f a -&gt; Step f a -&gt; Step f a
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall k (f :: k -&gt; *) (a :: k). Ord (f a) =&gt; Eq (Step f a)
forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Step f a -&gt; Step f a -&gt; Bool
forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Step f a -&gt; Step f a -&gt; Ordering
forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Step f a -&gt; Step f a -&gt; Step f a
min :: Step f a -&gt; Step f a -&gt; Step f a
$cmin :: forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Step f a -&gt; Step f a -&gt; Step f a
max :: Step f a -&gt; Step f a -&gt; Step f a
$cmax :: forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Step f a -&gt; Step f a -&gt; Step f a
&gt;= :: Step f a -&gt; Step f a -&gt; Bool
$c&gt;= :: forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Step f a -&gt; Step f a -&gt; Bool
&gt; :: Step f a -&gt; Step f a -&gt; Bool
$c&gt; :: forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Step f a -&gt; Step f a -&gt; Bool
&lt;= :: Step f a -&gt; Step f a -&gt; Bool
$c&lt;= :: forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Step f a -&gt; Step f a -&gt; Bool
&lt; :: Step f a -&gt; Step f a -&gt; Bool
$c&lt; :: forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Step f a -&gt; Step f a -&gt; Bool
compare :: Step f a -&gt; Step f a -&gt; Ordering
$ccompare :: forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Step f a -&gt; Step f a -&gt; Ordering
$cp1Ord :: forall k (f :: k -&gt; *) (a :: k). Ord (f a) =&gt; Eq (Step f a)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679407503"><span id="local-6989586621679407505"><span class="annot"><span class="annottext">a -&gt; Step f b -&gt; Step f a
(a -&gt; b) -&gt; Step f a -&gt; Step f b
(forall a b. (a -&gt; b) -&gt; Step f a -&gt; Step f b)
-&gt; (forall a b. a -&gt; Step f b -&gt; Step f a) -&gt; Functor (Step f)
forall a b. a -&gt; Step f b -&gt; Step f a
forall a b. (a -&gt; b) -&gt; Step f a -&gt; Step f b
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; Step f b -&gt; Step f a
forall (f :: * -&gt; *) a b.
Functor f =&gt;
(a -&gt; b) -&gt; Step f a -&gt; Step f b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: a -&gt; Step f b -&gt; Step f a
$c&lt;$ :: forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; Step f b -&gt; Step f a
fmap :: (a -&gt; b) -&gt; Step f a -&gt; Step f b
$cfmap :: forall (f :: * -&gt; *) a b.
Functor f =&gt;
(a -&gt; b) -&gt; Step f a -&gt; Step f b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679407468"><span id="local-6989586621679407470"><span id="local-6989586621679407472"><span id="local-6989586621679407474"><span id="local-6989586621679407476"><span id="local-6989586621679407478"><span id="local-6989586621679407480"><span id="local-6989586621679407482"><span id="local-6989586621679407484"><span id="local-6989586621679407486"><span id="local-6989586621679407488"><span id="local-6989586621679407490"><span id="local-6989586621679407492"><span id="local-6989586621679407494"><span id="local-6989586621679407496"><span id="local-6989586621679407498"><span id="local-6989586621679407500"><span class="annot"><span class="annottext">Step f a -&gt; Bool
(a -&gt; m) -&gt; Step f a -&gt; m
(a -&gt; b -&gt; b) -&gt; b -&gt; Step f a -&gt; b
(forall m. Monoid m =&gt; Step f m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Step f a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Step f a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Step f a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Step f a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Step f a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Step f a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; Step f a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; Step f a -&gt; a)
-&gt; (forall a. Step f a -&gt; [a])
-&gt; (forall a. Step f a -&gt; Bool)
-&gt; (forall a. Step f a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; Step f a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; Step f a -&gt; a)
-&gt; (forall a. Ord a =&gt; Step f a -&gt; a)
-&gt; (forall a. Num a =&gt; Step f a -&gt; a)
-&gt; (forall a. Num a =&gt; Step f a -&gt; a)
-&gt; Foldable (Step f)
forall a. Eq a =&gt; a -&gt; Step f a -&gt; Bool
forall a. Num a =&gt; Step f a -&gt; a
forall a. Ord a =&gt; Step f a -&gt; a
forall m. Monoid m =&gt; Step f m -&gt; m
forall a. Step f a -&gt; Bool
forall a. Step f a -&gt; Int
forall a. Step f a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; Step f a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Step f a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Step f a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Step f a -&gt; b
forall (f :: * -&gt; *) a. (Foldable f, Eq a) =&gt; a -&gt; Step f a -&gt; Bool
forall (f :: * -&gt; *) a. (Foldable f, Num a) =&gt; Step f a -&gt; a
forall (f :: * -&gt; *) a. (Foldable f, Ord a) =&gt; Step f a -&gt; a
forall (f :: * -&gt; *) m. (Foldable f, Monoid m) =&gt; Step f m -&gt; m
forall (f :: * -&gt; *) a. Foldable f =&gt; Step f a -&gt; Bool
forall (f :: * -&gt; *) a. Foldable f =&gt; Step f a -&gt; Int
forall (f :: * -&gt; *) a. Foldable f =&gt; Step f a -&gt; [a]
forall (f :: * -&gt; *) a.
Foldable f =&gt;
(a -&gt; a -&gt; a) -&gt; Step f a -&gt; a
forall (f :: * -&gt; *) m a.
(Foldable f, Monoid m) =&gt;
(a -&gt; m) -&gt; Step f a -&gt; m
forall (f :: * -&gt; *) b a.
Foldable f =&gt;
(b -&gt; a -&gt; b) -&gt; b -&gt; Step f a -&gt; b
forall (f :: * -&gt; *) a b.
Foldable f =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; Step f a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: Step f a -&gt; a
$cproduct :: forall (f :: * -&gt; *) a. (Foldable f, Num a) =&gt; Step f a -&gt; a
sum :: Step f a -&gt; a
$csum :: forall (f :: * -&gt; *) a. (Foldable f, Num a) =&gt; Step f a -&gt; a
minimum :: Step f a -&gt; a
$cminimum :: forall (f :: * -&gt; *) a. (Foldable f, Ord a) =&gt; Step f a -&gt; a
maximum :: Step f a -&gt; a
$cmaximum :: forall (f :: * -&gt; *) a. (Foldable f, Ord a) =&gt; Step f a -&gt; a
elem :: a -&gt; Step f a -&gt; Bool
$celem :: forall (f :: * -&gt; *) a. (Foldable f, Eq a) =&gt; a -&gt; Step f a -&gt; Bool
length :: Step f a -&gt; Int
$clength :: forall (f :: * -&gt; *) a. Foldable f =&gt; Step f a -&gt; Int
null :: Step f a -&gt; Bool
$cnull :: forall (f :: * -&gt; *) a. Foldable f =&gt; Step f a -&gt; Bool
toList :: Step f a -&gt; [a]
$ctoList :: forall (f :: * -&gt; *) a. Foldable f =&gt; Step f a -&gt; [a]
foldl1 :: (a -&gt; a -&gt; a) -&gt; Step f a -&gt; a
$cfoldl1 :: forall (f :: * -&gt; *) a.
Foldable f =&gt;
(a -&gt; a -&gt; a) -&gt; Step f a -&gt; a
foldr1 :: (a -&gt; a -&gt; a) -&gt; Step f a -&gt; a
$cfoldr1 :: forall (f :: * -&gt; *) a.
Foldable f =&gt;
(a -&gt; a -&gt; a) -&gt; Step f a -&gt; a
foldl' :: (b -&gt; a -&gt; b) -&gt; b -&gt; Step f a -&gt; b
$cfoldl' :: forall (f :: * -&gt; *) b a.
Foldable f =&gt;
(b -&gt; a -&gt; b) -&gt; b -&gt; Step f a -&gt; b
foldl :: (b -&gt; a -&gt; b) -&gt; b -&gt; Step f a -&gt; b
$cfoldl :: forall (f :: * -&gt; *) b a.
Foldable f =&gt;
(b -&gt; a -&gt; b) -&gt; b -&gt; Step f a -&gt; b
foldr' :: (a -&gt; b -&gt; b) -&gt; b -&gt; Step f a -&gt; b
$cfoldr' :: forall (f :: * -&gt; *) a b.
Foldable f =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; Step f a -&gt; b
foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; Step f a -&gt; b
$cfoldr :: forall (f :: * -&gt; *) a b.
Foldable f =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; Step f a -&gt; b
foldMap' :: (a -&gt; m) -&gt; Step f a -&gt; m
$cfoldMap' :: forall (f :: * -&gt; *) m a.
(Foldable f, Monoid m) =&gt;
(a -&gt; m) -&gt; Step f a -&gt; m
foldMap :: (a -&gt; m) -&gt; Step f a -&gt; m
$cfoldMap :: forall (f :: * -&gt; *) m a.
(Foldable f, Monoid m) =&gt;
(a -&gt; m) -&gt; Step f a -&gt; m
fold :: Step f m -&gt; m
$cfold :: forall (f :: * -&gt; *) m. (Foldable f, Monoid m) =&gt; Step f m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679407457"><span id="local-6989586621679407459"><span id="local-6989586621679407461"><span id="local-6989586621679407463"><span class="annot"><span class="annottext">Functor (Step f)
Foldable (Step f)
(Functor (Step f), Foldable (Step f)) =&gt;
(forall (f :: * -&gt; *) a b.
 Applicative f =&gt;
 (a -&gt; f b) -&gt; Step f a -&gt; f (Step f b))
-&gt; (forall (f :: * -&gt; *) a.
    Applicative f =&gt;
    Step f (f a) -&gt; f (Step f a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; Step f a -&gt; m (Step f b))
-&gt; (forall (m :: * -&gt; *) a.
    Monad m =&gt;
    Step f (m a) -&gt; m (Step f a))
-&gt; Traversable (Step f)
(a -&gt; f b) -&gt; Step f a -&gt; f (Step f b)
forall (t :: * -&gt; *).
(Functor t, Foldable t) =&gt;
(forall (f :: * -&gt; *) a b.
 Applicative f =&gt;
 (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (f :: * -&gt; *). Traversable f =&gt; Functor (Step f)
forall (f :: * -&gt; *). Traversable f =&gt; Foldable (Step f)
forall (f :: * -&gt; *) (m :: * -&gt; *) a.
(Traversable f, Monad m) =&gt;
Step f (m a) -&gt; m (Step f a)
forall (f :: * -&gt; *) (f :: * -&gt; *) a.
(Traversable f, Applicative f) =&gt;
Step f (f a) -&gt; f (Step f a)
forall (f :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable f, Monad m) =&gt;
(a -&gt; m b) -&gt; Step f a -&gt; m (Step f b)
forall (f :: * -&gt; *) (f :: * -&gt; *) a b.
(Traversable f, Applicative f) =&gt;
(a -&gt; f b) -&gt; Step f a -&gt; f (Step f b)
forall (m :: * -&gt; *) a. Monad m =&gt; Step f (m a) -&gt; m (Step f a)
forall (f :: * -&gt; *) a.
Applicative f =&gt;
Step f (f a) -&gt; f (Step f a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Step f a -&gt; m (Step f b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Step f a -&gt; f (Step f b)
sequence :: Step f (m a) -&gt; m (Step f a)
$csequence :: forall (f :: * -&gt; *) (m :: * -&gt; *) a.
(Traversable f, Monad m) =&gt;
Step f (m a) -&gt; m (Step f a)
mapM :: (a -&gt; m b) -&gt; Step f a -&gt; m (Step f b)
$cmapM :: forall (f :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable f, Monad m) =&gt;
(a -&gt; m b) -&gt; Step f a -&gt; m (Step f b)
sequenceA :: Step f (f a) -&gt; f (Step f a)
$csequenceA :: forall (f :: * -&gt; *) (f :: * -&gt; *) a.
(Traversable f, Applicative f) =&gt;
Step f (f a) -&gt; f (Step f a)
traverse :: (a -&gt; f b) -&gt; Step f a -&gt; f (Step f b)
$ctraverse :: forall (f :: * -&gt; *) (f :: * -&gt; *) a b.
(Traversable f, Applicative f) =&gt;
(a -&gt; f b) -&gt; Step f a -&gt; f (Step f b)
$cp2Traversable :: forall (f :: * -&gt; *). Traversable f =&gt; Foldable (Step f)
$cp1Traversable :: forall (f :: * -&gt; *). Traversable f =&gt; Functor (Step f)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">(forall x. Step f a -&gt; Rep (Step f a) x)
-&gt; (forall x. Rep (Step f a) x -&gt; Step f a) -&gt; Generic (Step f a)
forall x. Rep (Step f a) x -&gt; Step f a
forall x. Step f a -&gt; Rep (Step f a) x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall k (f :: k -&gt; *) (a :: k) x. Rep (Step f a) x -&gt; Step f a
forall k (f :: k -&gt; *) (a :: k) x. Step f a -&gt; Rep (Step f a) x
$cto :: forall k (f :: k -&gt; *) (a :: k) x. Rep (Step f a) x -&gt; Step f a
$cfrom :: forall k (f :: k -&gt; *) (a :: k) x. Step f a -&gt; Rep (Step f a) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">,</span><span> </span><span id="%24cStep"><span id="%24tStep"><span id="local-6989586621679407424"><span id="local-6989586621679407426"><span id="local-6989586621679407428"><span id="local-6989586621679407430"><span id="local-6989586621679407432"><span id="local-6989586621679407434"><span id="local-6989586621679407436"><span id="local-6989586621679407438"><span id="local-6989586621679407440"><span id="local-6989586621679407442"><span id="local-6989586621679407444"><span id="local-6989586621679407446"><span id="local-6989586621679407448"><span id="local-6989586621679407450"><span class="annot"><span class="annottext">Typeable (Step f a)
DataType
Constr
Typeable (Step f a) =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; Step f a -&gt; c (Step f a))
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Step f a))
-&gt; (Step f a -&gt; Constr)
-&gt; (Step f a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Step f a)))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e))
    -&gt; Maybe (c (Step f a)))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; Step f a -&gt; Step f a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Step f a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Step f a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Step f a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Step f a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Step f a -&gt; m (Step f a))
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Step f a -&gt; m (Step f a))
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Step f a -&gt; m (Step f a))
-&gt; Data (Step f a)
Step f a -&gt; DataType
Step f a -&gt; Constr
(forall b. Data b =&gt; b -&gt; b) -&gt; Step f a -&gt; Step f a
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Step f a -&gt; c (Step f a)
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Step f a)
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Step f a -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Step f a -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Step f a -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Step f a -&gt; r
forall k (f :: k -&gt; *) (a :: k).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
Typeable (Step f a)
forall k (f :: k -&gt; *) (a :: k).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
Step f a -&gt; DataType
forall k (f :: k -&gt; *) (a :: k).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
Step f a -&gt; Constr
forall k (f :: k -&gt; *) (a :: k).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Step f a -&gt; Step f a
forall k (f :: k -&gt; *) (a :: k) u.
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Step f a -&gt; u
forall k (f :: k -&gt; *) (a :: k) u.
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; Step f a -&gt; [u]
forall k (f :: k -&gt; *) (a :: k) r r'.
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Step f a -&gt; r
forall k (f :: k -&gt; *) (a :: k) r r'.
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Step f a -&gt; r
forall k (f :: k -&gt; *) (a :: k) (m :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Step f a -&gt; m (Step f a)
forall k (f :: k -&gt; *) (a :: k) (m :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Step f a -&gt; m (Step f a)
forall k (f :: k -&gt; *) (a :: k) (c :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Step f a)
forall k (f :: k -&gt; *) (a :: k) (c :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Step f a -&gt; c (Step f a)
forall k (f :: k -&gt; *) (a :: k) (t :: * -&gt; *) (c :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Step f a))
forall k (f :: k -&gt; *) (a :: k) (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (Step f a))
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Step f a -&gt; m (Step f a)
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Step f a -&gt; m (Step f a)
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Step f a)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Step f a -&gt; c (Step f a)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Step f a))
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (Step f a))
$cStep :: Constr
$tStep :: DataType
gmapMo :: (forall d. Data d =&gt; d -&gt; m d) -&gt; Step f a -&gt; m (Step f a)
$cgmapMo :: forall k (f :: k -&gt; *) (a :: k) (m :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Step f a -&gt; m (Step f a)
gmapMp :: (forall d. Data d =&gt; d -&gt; m d) -&gt; Step f a -&gt; m (Step f a)
$cgmapMp :: forall k (f :: k -&gt; *) (a :: k) (m :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Step f a -&gt; m (Step f a)
gmapM :: (forall d. Data d =&gt; d -&gt; m d) -&gt; Step f a -&gt; m (Step f a)
$cgmapM :: forall k (f :: k -&gt; *) (a :: k) (m :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Step f a -&gt; m (Step f a)
gmapQi :: Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Step f a -&gt; u
$cgmapQi :: forall k (f :: k -&gt; *) (a :: k) u.
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Step f a -&gt; u
gmapQ :: (forall d. Data d =&gt; d -&gt; u) -&gt; Step f a -&gt; [u]
$cgmapQ :: forall k (f :: k -&gt; *) (a :: k) u.
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; Step f a -&gt; [u]
gmapQr :: (r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Step f a -&gt; r
$cgmapQr :: forall k (f :: k -&gt; *) (a :: k) r r'.
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Step f a -&gt; r
gmapQl :: (r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Step f a -&gt; r
$cgmapQl :: forall k (f :: k -&gt; *) (a :: k) r r'.
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Step f a -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Step f a -&gt; Step f a
$cgmapT :: forall k (f :: k -&gt; *) (a :: k).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Step f a -&gt; Step f a
dataCast2 :: (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (Step f a))
$cdataCast2 :: forall k (f :: k -&gt; *) (a :: k) (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (Step f a))
dataCast1 :: (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Step f a))
$cdataCast1 :: forall k (f :: k -&gt; *) (a :: k) (t :: * -&gt; *) (c :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Step f a))
dataTypeOf :: Step f a -&gt; DataType
$cdataTypeOf :: forall k (f :: k -&gt; *) (a :: k).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
Step f a -&gt; DataType
toConstr :: Step f a -&gt; Constr
$ctoConstr :: forall k (f :: k -&gt; *) (a :: k).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
Step f a -&gt; Constr
gunfold :: (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Step f a)
$cgunfold :: forall k (f :: k -&gt; *) (a :: k) (c :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Step f a)
gfoldl :: (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Step f a -&gt; c (Step f a)
$cgfoldl :: forall k (f :: k -&gt; *) (a :: k) (c :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Step f a -&gt; c (Step f a)
$cp1Data :: forall k (f :: k -&gt; *) (a :: k).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
Typeable (Step f a)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-96"></span><span>
</span><span id="line-97"></span><span id="local-6989586621679407417"><span id="local-6989586621679407419"><span id="local-6989586621679408254"><span class="hs-identifier">deriveShow1</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Step</span></span></span></span><span>
</span><span id="line-98"></span><span id="local-6989586621679407407"><span id="local-6989586621679407409"><span id="local-6989586621679407411"><span id="local-6989586621679407413"><span id="local-6989586621679408254"><span class="hs-identifier">deriveRead1</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Step</span></span></span></span></span></span><span>
</span><span id="line-99"></span><span id="local-6989586621679407402"><span id="local-6989586621679408254"><span class="hs-identifier">deriveEq1</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Step</span></span></span><span>
</span><span id="line-100"></span><span id="local-6989586621679407397"><span id="local-6989586621679408254"><span class="hs-identifier">deriveOrd1</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Step</span></span></span><span>
</span><span id="line-101"></span><span>
</span><span id="line-102"></span><span id="local-6989586621679407394"><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679407385"><span id="local-6989586621679407387"><span id="local-6989586621679407389"><span class="annot"><span class="hs-identifier hs-type">Applicative</span></span><span> </span><span class="annot"><a href="#local-6989586621679407394"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Applicative</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-type">Step</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679407394"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-103"></span><span>    </span><span id="local-6989586621679407383"><span class="annot"><span class="annottext">pure :: a -&gt; Step f a
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">pure</span></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Natural -&gt; f a -&gt; Step f a
forall k (f :: k -&gt; *) (a :: k). Natural -&gt; f a -&gt; Step f a
</span><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-var">Step</span></a></span><span> </span><span class="annot"><span class="hs-number">0</span></span><span> </span><span class="annot"><span class="annottext">(f a -&gt; Step f a) -&gt; (a -&gt; f a) -&gt; a -&gt; Step f a
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; f a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span>
</span><span id="line-104"></span><span>    </span><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-type">Step</span></a></span><span> </span><span id="local-6989586621679407381"><span class="annot"><span class="annottext">n :: Natural
</span><a href="#local-6989586621679407381"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679407380"><span class="annot"><span class="annottext">f :: f (a -&gt; b)
</span><a href="#local-6989586621679407380"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679407379"><span class="annot"><span class="annottext">&lt;*&gt; :: Step f (a -&gt; b) -&gt; Step f a -&gt; Step f b
</span><span class="hs-operator hs-var hs-var hs-var hs-var">&lt;*&gt;</span></span></span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-type">Step</span></a></span><span> </span><span id="local-6989586621679407378"><span class="annot"><span class="annottext">m :: Natural
</span><a href="#local-6989586621679407378"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span id="local-6989586621679407377"><span class="annot"><span class="annottext">x :: f a
</span><a href="#local-6989586621679407377"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Natural -&gt; f b -&gt; Step f b
forall k (f :: k -&gt; *) (a :: k). Natural -&gt; f a -&gt; Step f a
</span><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-var">Step</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Natural
</span><a href="#local-6989586621679407381"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Natural -&gt; Natural -&gt; Natural
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">+</span></span><span> </span><span class="annot"><span class="annottext">Natural
</span><a href="#local-6989586621679407378"><span class="hs-identifier hs-var">m</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">f (a -&gt; b)
</span><a href="#local-6989586621679407380"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">f (a -&gt; b) -&gt; f a -&gt; f b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">f a
</span><a href="#local-6989586621679407377"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-105"></span><span>
</span><span id="line-106"></span><span id="local-6989586621679407375"><span class="hs-keyword">instance</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Pointed</span></span><span> </span><span class="annot"><a href="#local-6989586621679407375"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Pointed</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-type">Step</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679407375"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-107"></span><span>    </span><span id="local-6989586621679407372"><span class="annot"><span class="annottext">point :: a -&gt; Step f a
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">point</span></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Natural -&gt; f a -&gt; Step f a
forall k (f :: k -&gt; *) (a :: k). Natural -&gt; f a -&gt; Step f a
</span><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-var">Step</span></a></span><span> </span><span class="annot"><span class="hs-number">0</span></span><span> </span><span class="annot"><span class="annottext">(f a -&gt; Step f a) -&gt; (a -&gt; f a) -&gt; a -&gt; Step f a
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; f a
forall (p :: * -&gt; *) a. Pointed p =&gt; a -&gt; p a
</span><span class="hs-identifier hs-var">point</span></span></span><span>
</span><span id="line-108"></span><span>
</span><span id="line-109"></span><span id="local-6989586621679407370"><span class="hs-keyword">instance</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Foldable1</span></span><span> </span><span class="annot"><a href="#local-6989586621679407370"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Foldable1</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-type">Step</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679407370"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-110"></span><span>    </span><span id="local-6989586621679407364"><span class="annot"><span class="annottext">fold1 :: Step f m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">fold1</span></span></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">f m -&gt; m
forall (t :: * -&gt; *) m. (Foldable1 t, Semigroup m) =&gt; t m -&gt; m
</span><span class="hs-identifier hs-var">fold1</span></span><span> </span><span class="annot"><span class="annottext">(f m -&gt; m) -&gt; (Step f m -&gt; f m) -&gt; Step f m -&gt; m
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Step f m -&gt; f m
forall k (f :: k -&gt; *) (a :: k). Step f a -&gt; f a
</span><a href="Control.Applicative.Step.html#stepVal"><span class="hs-identifier hs-var hs-var">stepVal</span></a></span><span>
</span><span id="line-111"></span><span>    </span><span id="local-6989586621679407362"><span class="annot"><span class="annottext">foldMap1 :: (a -&gt; m) -&gt; Step f a -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">foldMap1</span></span></span><span> </span><span id="local-6989586621679407360"><span class="annot"><span class="annottext">f :: a -&gt; m
</span><a href="#local-6989586621679407360"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; m) -&gt; f a -&gt; m
forall (t :: * -&gt; *) m a.
(Foldable1 t, Semigroup m) =&gt;
(a -&gt; m) -&gt; t a -&gt; m
</span><span class="hs-identifier hs-var">foldMap1</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; m
</span><a href="#local-6989586621679407360"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">(f a -&gt; m) -&gt; (Step f a -&gt; f a) -&gt; Step f a -&gt; m
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Step f a -&gt; f a
forall k (f :: k -&gt; *) (a :: k). Step f a -&gt; f a
</span><a href="Control.Applicative.Step.html#stepVal"><span class="hs-identifier hs-var hs-var">stepVal</span></a></span><span>
</span><span id="line-112"></span><span>    </span><span id="local-6989586621679407359"><span class="annot"><span class="annottext">toNonEmpty :: Step f a -&gt; NonEmpty a
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">toNonEmpty</span></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">f a -&gt; NonEmpty a
forall (t :: * -&gt; *) a. Foldable1 t =&gt; t a -&gt; NonEmpty a
</span><span class="hs-identifier hs-var">toNonEmpty</span></span><span> </span><span class="annot"><span class="annottext">(f a -&gt; NonEmpty a) -&gt; (Step f a -&gt; f a) -&gt; Step f a -&gt; NonEmpty a
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Step f a -&gt; f a
forall k (f :: k -&gt; *) (a :: k). Step f a -&gt; f a
</span><a href="Control.Applicative.Step.html#stepVal"><span class="hs-identifier hs-var hs-var">stepVal</span></a></span></span><span>
</span><span id="line-113"></span><span>
</span><span id="line-114"></span><span id="local-6989586621679407357"><span class="hs-keyword">instance</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Traversable1</span></span><span> </span><span class="annot"><a href="#local-6989586621679407357"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Traversable1</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-type">Step</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679407357"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-115"></span><span>    </span><span id="local-6989586621679407351"><span class="annot"><span class="annottext">traverse1 :: (a -&gt; f b) -&gt; Step f a -&gt; f (Step f b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">traverse1</span></span></span><span> </span><span id="local-6989586621679407349"><span class="annot"><span class="annottext">f :: a -&gt; f b
</span><a href="#local-6989586621679407349"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-type">Step</span></a></span><span> </span><span id="local-6989586621679407348"><span class="annot"><span class="annottext">n :: Natural
</span><a href="#local-6989586621679407348"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679407347"><span class="annot"><span class="annottext">x :: f a
</span><a href="#local-6989586621679407347"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Natural -&gt; f b -&gt; Step f b
forall k (f :: k -&gt; *) (a :: k). Natural -&gt; f a -&gt; Step f a
</span><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-var">Step</span></a></span><span> </span><span class="annot"><span class="annottext">Natural
</span><a href="#local-6989586621679407348"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">(f b -&gt; Step f b) -&gt; f (f b) -&gt; f (Step f b)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">(a -&gt; f b) -&gt; f a -&gt; f (f b)
forall (t :: * -&gt; *) (f :: * -&gt; *) a b.
(Traversable1 t, Apply f) =&gt;
(a -&gt; f b) -&gt; t a -&gt; f (t b)
</span><span class="hs-identifier hs-var">traverse1</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; f b
</span><a href="#local-6989586621679407349"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">f a
</span><a href="#local-6989586621679407347"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-116"></span><span>    </span><span id="local-6989586621679407345"><span class="annot"><span class="annottext">sequence1 :: Step f (f b) -&gt; f (Step f b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">sequence1</span></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-type">Step</span></a></span><span> </span><span id="local-6989586621679407343"><span class="annot"><span class="annottext">n :: Natural
</span><a href="#local-6989586621679407343"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679407342"><span class="annot"><span class="annottext">x :: f (f b)
</span><a href="#local-6989586621679407342"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Natural -&gt; f b -&gt; Step f b
forall k (f :: k -&gt; *) (a :: k). Natural -&gt; f a -&gt; Step f a
</span><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-var">Step</span></a></span><span> </span><span class="annot"><span class="annottext">Natural
</span><a href="#local-6989586621679407343"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">(f b -&gt; Step f b) -&gt; f (f b) -&gt; f (Step f b)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">f (f b) -&gt; f (f b)
forall (t :: * -&gt; *) (f :: * -&gt; *) b.
(Traversable1 t, Apply f) =&gt;
t (f b) -&gt; f (t b)
</span><span class="hs-identifier hs-var">sequence1</span></span><span> </span><span class="annot"><span class="annottext">f (f b)
</span><a href="#local-6989586621679407342"><span class="hs-identifier hs-var">x</span></a></span></span><span>
</span><span id="line-117"></span><span>
</span><span id="line-118"></span><span class="hs-comment">-- | &quot;Uncons and cons&quot; an @f@ branch before a 'Step'.  This is basically</span><span>
</span><span id="line-119"></span><span class="hs-comment">-- a witness that 'stepDown' and 'stepUp' form an isomorphism.</span><span>
</span><span id="line-120"></span><span id="local-6989586621679407341"><span class="annot"><a href="Control.Applicative.Step.html#stepping"><span class="hs-identifier hs-type">stepping</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-type">Step</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679407341"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="Control.Natural.IsoF.html#%3C~%3E"><span class="hs-operator hs-type">&lt;~&gt;</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679407341"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">:+:</span></span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-type">Step</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679407341"><span class="hs-identifier hs-type">f</span></a></span></span><span>
</span><span id="line-121"></span><span id="stepping"><span class="annot"><span class="annottext">stepping :: p ((:+:) f (Step f) a) ((:+:) f (Step f) a)
-&gt; p (Step f a) (Step f a)
</span><a href="Control.Applicative.Step.html#stepping"><span class="hs-identifier hs-var hs-var">stepping</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Step f ~&gt; (f :+: Step f))
-&gt; ((f :+: Step f) ~&gt; Step f) -&gt; Step f &lt;~&gt; (f :+: Step f)
forall (f :: * -&gt; *) (g :: * -&gt; *). (f ~&gt; g) -&gt; (g ~&gt; f) -&gt; f &lt;~&gt; g
</span><a href="Control.Natural.IsoF.html#isoF"><span class="hs-identifier hs-var">isoF</span></a></span><span> </span><span class="annot"><span class="annottext">Step f ~&gt; (f :+: Step f)
forall k (f :: k -&gt; *). Step f ~&gt; (f :+: Step f)
</span><a href="Control.Applicative.Step.html#stepDown"><span class="hs-identifier hs-var">stepDown</span></a></span><span> </span><span class="annot"><span class="annottext">(f :+: Step f) ~&gt; Step f
forall k (f :: k -&gt; *). (f :+: Step f) ~&gt; Step f
</span><a href="Control.Applicative.Step.html#stepUp"><span class="hs-identifier hs-var">stepUp</span></a></span><span>
</span><span id="line-122"></span><span>
</span><span id="line-123"></span><span class="hs-comment">-- | Pop off the first item in a 'Step'.  Because a @'Step' f@ is @f :+:</span><span>
</span><span id="line-124"></span><span class="hs-comment">-- f :+: f :+: ...@ forever, this matches on the first branch.</span><span>
</span><span id="line-125"></span><span class="hs-comment">--</span><span>
</span><span id="line-126"></span><span class="hs-comment">-- You can think of it as reassociating</span><span>
</span><span id="line-127"></span><span class="hs-comment">--</span><span>
</span><span id="line-128"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-129"></span><span class="hs-comment">-- f :+: f :+: f :+: f :+: ...</span><span>
</span><span id="line-130"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-131"></span><span class="hs-comment">--</span><span>
</span><span id="line-132"></span><span class="hs-comment">-- into</span><span>
</span><span id="line-133"></span><span class="hs-comment">--</span><span>
</span><span id="line-134"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-135"></span><span class="hs-comment">-- f :+: ( f :+: f :+: f :+: ...)</span><span>
</span><span id="line-136"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-137"></span><span class="hs-comment">--</span><span>
</span><span id="line-138"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-139"></span><span class="hs-comment">-- 'stepDown' ('Step' 2 &quot;hello&quot;)</span><span>
</span><span id="line-140"></span><span class="hs-comment">-- -- 'R1' (Step 1 &quot;hello&quot;)</span><span>
</span><span id="line-141"></span><span class="hs-comment">-- stepDown (Step 0 &quot;hello&quot;)</span><span>
</span><span id="line-142"></span><span class="hs-comment">-- -- 'L1' &quot;hello&quot;</span><span>
</span><span id="line-143"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-144"></span><span class="hs-comment">--</span><span>
</span><span id="line-145"></span><span class="hs-comment">-- Forms an isomorphism with 'stepUp' (see 'stepping').</span><span>
</span><span id="line-146"></span><span id="local-6989586621679408204"><span class="annot"><a href="Control.Applicative.Step.html#stepDown"><span class="hs-identifier hs-type">stepDown</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-type">Step</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679408204"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">~&gt;</span></span><span> </span><span class="annot"><a href="#local-6989586621679408204"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">:+:</span></span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-type">Step</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679408204"><span class="hs-identifier hs-type">f</span></a></span></span><span>
</span><span id="line-147"></span><span id="stepDown"><span class="annot"><span class="annottext">stepDown :: Step f x -&gt; (:+:) f (Step f) x
</span><a href="Control.Applicative.Step.html#stepDown"><span class="hs-identifier hs-var hs-var">stepDown</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-type">Step</span></a></span><span> </span><span id="local-6989586621679407339"><span class="annot"><span class="annottext">n :: Natural
</span><a href="#local-6989586621679407339"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679407338"><span class="annot"><span class="annottext">x :: f x
</span><a href="#local-6989586621679407338"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Natural -&gt; Natural -&gt; Maybe Natural
</span><span class="hs-identifier hs-var">minusNaturalMaybe</span></span><span> </span><span class="annot"><span class="annottext">Natural
</span><a href="#local-6989586621679407339"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="hs-number">1</span></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-148"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">Nothing</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">f x -&gt; (:+:) f (Step f) x
forall k (f :: k -&gt; *) (g :: k -&gt; *) (p :: k). f p -&gt; (:+:) f g p
</span><span class="hs-identifier hs-var">L1</span></span><span> </span><span class="annot"><span class="annottext">f x
</span><a href="#local-6989586621679407338"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-149"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621679407335"><span class="annot"><span class="annottext">m :: Natural
</span><a href="#local-6989586621679407335"><span class="hs-identifier hs-var">m</span></a></span></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Step f x -&gt; (:+:) f (Step f) x
forall k (f :: k -&gt; *) (g :: k -&gt; *) (p :: k). g p -&gt; (:+:) f g p
</span><span class="hs-identifier hs-var">R1</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Natural -&gt; f x -&gt; Step f x
forall k (f :: k -&gt; *) (a :: k). Natural -&gt; f a -&gt; Step f a
</span><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-var">Step</span></a></span><span> </span><span class="annot"><span class="annottext">Natural
</span><a href="#local-6989586621679407335"><span class="hs-identifier hs-var">m</span></a></span><span> </span><span class="annot"><span class="annottext">f x
</span><a href="#local-6989586621679407338"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-150"></span><span>
</span><span id="line-151"></span><span class="hs-comment">-- | Unshift an item into a 'Step'.  Because a @'Step' f@ is @f :+: f :+:</span><span>
</span><span id="line-152"></span><span class="hs-comment">-- f :+: f :+: ...@ forever, this basically conses an additional</span><span>
</span><span id="line-153"></span><span class="hs-comment">-- possibility of @f@ to the beginning of it all.</span><span>
</span><span id="line-154"></span><span class="hs-comment">--</span><span>
</span><span id="line-155"></span><span class="hs-comment">-- You can think of it as reassociating</span><span>
</span><span id="line-156"></span><span class="hs-comment">--</span><span>
</span><span id="line-157"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-158"></span><span class="hs-comment">-- f :+: ( f :+: f :+: f :+: ...)</span><span>
</span><span id="line-159"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-160"></span><span class="hs-comment">--</span><span>
</span><span id="line-161"></span><span class="hs-comment">-- into</span><span>
</span><span id="line-162"></span><span class="hs-comment">--</span><span>
</span><span id="line-163"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-164"></span><span class="hs-comment">-- f :+: f :+: f :+: f :+: ...</span><span>
</span><span id="line-165"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-166"></span><span class="hs-comment">--</span><span>
</span><span id="line-167"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-168"></span><span class="hs-comment">-- 'stepUp' ('L1' &quot;hello&quot;)</span><span>
</span><span id="line-169"></span><span class="hs-comment">-- -- 'Step' 0 &quot;hello&quot;</span><span>
</span><span id="line-170"></span><span class="hs-comment">-- stepUp ('R1' (Step 1 &quot;hello&quot;))</span><span>
</span><span id="line-171"></span><span class="hs-comment">-- -- Step 2 &quot;hello&quot;</span><span>
</span><span id="line-172"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-173"></span><span class="hs-comment">--</span><span>
</span><span id="line-174"></span><span class="hs-comment">-- Forms an isomorphism with 'stepDown' (see 'stepping').</span><span>
</span><span id="line-175"></span><span id="local-6989586621679408202"><span class="annot"><a href="Control.Applicative.Step.html#stepUp"><span class="hs-identifier hs-type">stepUp</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621679408202"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">:+:</span></span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-type">Step</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679408202"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">~&gt;</span></span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-type">Step</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679408202"><span class="hs-identifier hs-type">f</span></a></span></span><span>
</span><span id="line-176"></span><span id="stepUp"><span class="annot"><span class="annottext">stepUp :: (:+:) f (Step f) x -&gt; Step f x
</span><a href="Control.Applicative.Step.html#stepUp"><span class="hs-identifier hs-var hs-var">stepUp</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-177"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">L1</span></span><span> </span><span id="local-6989586621679407333"><span class="annot"><span class="annottext">x :: f x
</span><a href="#local-6989586621679407333"><span class="hs-identifier hs-var">x</span></a></span></span><span>          </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Natural -&gt; f x -&gt; Step f x
forall k (f :: k -&gt; *) (a :: k). Natural -&gt; f a -&gt; Step f a
</span><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-var">Step</span></a></span><span> </span><span class="annot"><span class="hs-number">0</span></span><span>       </span><span class="annot"><span class="annottext">f x
</span><a href="#local-6989586621679407333"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-178"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">R1</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-type">Step</span></a></span><span> </span><span id="local-6989586621679407332"><span class="annot"><span class="annottext">n :: Natural
</span><a href="#local-6989586621679407332"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679407331"><span class="annot"><span class="annottext">y :: f x
</span><a href="#local-6989586621679407331"><span class="hs-identifier hs-var">y</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Natural -&gt; f x -&gt; Step f x
forall k (f :: k -&gt; *) (a :: k). Natural -&gt; f a -&gt; Step f a
</span><a href="Control.Applicative.Step.html#Step"><span class="hs-identifier hs-var">Step</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Natural
</span><a href="#local-6989586621679407332"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Natural -&gt; Natural -&gt; Natural
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">+</span></span><span> </span><span class="annot"><span class="hs-number">1</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">f x
</span><a href="#local-6989586621679407331"><span class="hs-identifier hs-var">y</span></a></span><span>
</span><span id="line-179"></span><span>
</span><span id="line-180"></span><span class="hs-comment">-- | We have a natural transformation between 'V1' and any other</span><span>
</span><span id="line-181"></span><span class="hs-comment">-- functor @f@ with no constraints.</span><span>
</span><span id="line-182"></span><span id="local-6989586621679407329"><span id="local-6989586621679407330"><span class="annot"><a href="Control.Applicative.Step.html#absurd1"><span class="hs-identifier hs-type">absurd1</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">V1</span></span><span> </span><span class="annot"><a href="#local-6989586621679407330"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679407329"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679407330"><span class="hs-identifier hs-type">a</span></a></span></span></span><span>
</span><span id="line-183"></span><span id="absurd1"><span class="annot"><span class="annottext">absurd1 :: V1 a -&gt; f a
</span><a href="Control.Applicative.Step.html#absurd1"><span class="hs-identifier hs-var hs-var">absurd1</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span>
</span><span id="line-184"></span><span>
</span><span id="line-185"></span><span class="hs-comment">-- | A non-empty map of 'Natural' to @f a@.  Basically, contains multiple</span><span>
</span><span id="line-186"></span><span class="hs-comment">-- @f a@s, each at a given 'Natural' index.</span><span>
</span><span id="line-187"></span><span class="hs-comment">--</span><span>
</span><span id="line-188"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-189"></span><span class="hs-comment">-- Steps f a ~ 'M.Map' 'Natural' (f a)</span><span>
</span><span id="line-190"></span><span class="hs-comment">-- Steps f   ~ 'M.Map' 'Natural' ':.:' f       -- functor composition</span><span>
</span><span id="line-191"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-192"></span><span class="hs-comment">--</span><span>
</span><span id="line-193"></span><span class="hs-comment">-- It is the fixed point of applications of 'Data.Functor.These.TheseT'.</span><span>
</span><span id="line-194"></span><span class="hs-comment">--</span><span>
</span><span id="line-195"></span><span class="hs-comment">-- You can think of this as an infinite sparse array of @f a@s.</span><span>
</span><span id="line-196"></span><span class="hs-comment">--</span><span>
</span><span id="line-197"></span><span class="hs-comment">-- Intuitively, in an infinite @f \`TheseT\` f \`TheseT\` f \`TheseT\` f ...@,</span><span>
</span><span id="line-198"></span><span class="hs-comment">-- each of those infinite positions may have an @f@ in them.  However,</span><span>
</span><span id="line-199"></span><span class="hs-comment">-- because of the at-least-one nature of 'Data.Functor.These.TheseT', we know we have at least</span><span>
</span><span id="line-200"></span><span class="hs-comment">-- one f at one position /somewhere/.</span><span>
</span><span id="line-201"></span><span class="hs-comment">--</span><span>
</span><span id="line-202"></span><span class="hs-comment">-- A @'Steps' f a@ has potentially many @f@s, each stored at a different</span><span>
</span><span id="line-203"></span><span class="hs-comment">-- 'Natural' position, with the guaruntee that at least one @f@ exists.</span><span>
</span><span id="line-204"></span><span class="hs-comment">--</span><span>
</span><span id="line-205"></span><span class="hs-comment">-- Can be useful for using with the 'Data.HBifunctor.Tensor.Monoidal' instance</span><span>
</span><span id="line-206"></span><span class="hs-comment">-- of 'Data.Functor.These.TheseT'.</span><span>
</span><span id="line-207"></span><span class="hs-comment">--</span><span>
</span><span id="line-208"></span><span class="hs-comment">-- 'Data.HFunctor.interpret'ing it requires at least an 'Alt'</span><span>
</span><span id="line-209"></span><span class="hs-comment">-- instance in the target context, since we have to handle potentially more</span><span>
</span><span id="line-210"></span><span class="hs-comment">-- than one @f@.</span><span>
</span><span id="line-211"></span><span class="hs-comment">--</span><span>
</span><span id="line-212"></span><span class="hs-comment">-- This type is essentailly the same as @'Control.Applicative.ListF.NEMapF'</span><span>
</span><span id="line-213"></span><span class="hs-comment">-- ('Sum' 'Natural')@ (except with a different 'Semigroup' instance).</span><span>
</span><span id="line-214"></span><span id="local-6989586621679407327"><span id="local-6989586621679407328"></span></span><span class="hs-keyword">newtype</span><span> </span><span id="Steps"><span class="annot"><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-var">Steps</span></a></span></span><span> </span><span id="local-6989586621679408091"><span class="annot"><a href="#local-6989586621679408091"><span class="hs-identifier hs-type">f</span></a></span></span><span> </span><span id="local-6989586621679408090"><span class="annot"><a href="#local-6989586621679408090"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="Steps"><span class="annot"><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-var">Steps</span></a></span></span><span> </span><span class="hs-special">{</span><span> </span><span id="getSteps"><span class="annot"><span class="annottext">Steps f a -&gt; NEMap Natural (f a)
</span><a href="Control.Applicative.Step.html#getSteps"><span class="hs-identifier hs-var hs-var">getSteps</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">NEMap</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Natural</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679408091"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679408090"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-215"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679407319"><span id="local-6989586621679407321"><span id="local-6989586621679407323"><span class="annot"><span class="annottext">Int -&gt; Steps f a -&gt; ShowS
[Steps f a] -&gt; ShowS
Steps f a -&gt; String
(Int -&gt; Steps f a -&gt; ShowS)
-&gt; (Steps f a -&gt; String)
-&gt; ([Steps f a] -&gt; ShowS)
-&gt; Show (Steps f a)
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
forall k (f :: k -&gt; *) (a :: k).
Show (f a) =&gt;
Int -&gt; Steps f a -&gt; ShowS
forall k (f :: k -&gt; *) (a :: k). Show (f a) =&gt; [Steps f a] -&gt; ShowS
forall k (f :: k -&gt; *) (a :: k). Show (f a) =&gt; Steps f a -&gt; String
showList :: [Steps f a] -&gt; ShowS
$cshowList :: forall k (f :: k -&gt; *) (a :: k). Show (f a) =&gt; [Steps f a] -&gt; ShowS
show :: Steps f a -&gt; String
$cshow :: forall k (f :: k -&gt; *) (a :: k). Show (f a) =&gt; Steps f a -&gt; String
showsPrec :: Int -&gt; Steps f a -&gt; ShowS
$cshowsPrec :: forall k (f :: k -&gt; *) (a :: k).
Show (f a) =&gt;
Int -&gt; Steps f a -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679407311"><span id="local-6989586621679407313"><span id="local-6989586621679407315"><span id="local-6989586621679407317"><span class="annot"><span class="annottext">ReadPrec [Steps f a]
ReadPrec (Steps f a)
Int -&gt; ReadS (Steps f a)
ReadS [Steps f a]
(Int -&gt; ReadS (Steps f a))
-&gt; ReadS [Steps f a]
-&gt; ReadPrec (Steps f a)
-&gt; ReadPrec [Steps f a]
-&gt; Read (Steps f a)
forall a.
(Int -&gt; ReadS a)
-&gt; ReadS [a] -&gt; ReadPrec a -&gt; ReadPrec [a] -&gt; Read a
forall k (f :: k -&gt; *) (a :: k). Read (f a) =&gt; ReadPrec [Steps f a]
forall k (f :: k -&gt; *) (a :: k). Read (f a) =&gt; ReadPrec (Steps f a)
forall k (f :: k -&gt; *) (a :: k).
Read (f a) =&gt;
Int -&gt; ReadS (Steps f a)
forall k (f :: k -&gt; *) (a :: k). Read (f a) =&gt; ReadS [Steps f a]
readListPrec :: ReadPrec [Steps f a]
$creadListPrec :: forall k (f :: k -&gt; *) (a :: k). Read (f a) =&gt; ReadPrec [Steps f a]
readPrec :: ReadPrec (Steps f a)
$creadPrec :: forall k (f :: k -&gt; *) (a :: k). Read (f a) =&gt; ReadPrec (Steps f a)
readList :: ReadS [Steps f a]
$creadList :: forall k (f :: k -&gt; *) (a :: k). Read (f a) =&gt; ReadS [Steps f a]
readsPrec :: Int -&gt; ReadS (Steps f a)
$creadsPrec :: forall k (f :: k -&gt; *) (a :: k).
Read (f a) =&gt;
Int -&gt; ReadS (Steps f a)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Read</span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679407307"><span id="local-6989586621679407309"><span class="annot"><span class="annottext">Steps f a -&gt; Steps f a -&gt; Bool
(Steps f a -&gt; Steps f a -&gt; Bool)
-&gt; (Steps f a -&gt; Steps f a -&gt; Bool) -&gt; Eq (Steps f a)
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
forall k (f :: k -&gt; *) (a :: k).
Eq (f a) =&gt;
Steps f a -&gt; Steps f a -&gt; Bool
/= :: Steps f a -&gt; Steps f a -&gt; Bool
$c/= :: forall k (f :: k -&gt; *) (a :: k).
Eq (f a) =&gt;
Steps f a -&gt; Steps f a -&gt; Bool
== :: Steps f a -&gt; Steps f a -&gt; Bool
$c== :: forall k (f :: k -&gt; *) (a :: k).
Eq (f a) =&gt;
Steps f a -&gt; Steps f a -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679407292"><span id="local-6989586621679407294"><span id="local-6989586621679407296"><span id="local-6989586621679407298"><span id="local-6989586621679407300"><span id="local-6989586621679407302"><span id="local-6989586621679407304"><span class="annot"><span class="annottext">Eq (Steps f a)
Eq (Steps f a) =&gt;
(Steps f a -&gt; Steps f a -&gt; Ordering)
-&gt; (Steps f a -&gt; Steps f a -&gt; Bool)
-&gt; (Steps f a -&gt; Steps f a -&gt; Bool)
-&gt; (Steps f a -&gt; Steps f a -&gt; Bool)
-&gt; (Steps f a -&gt; Steps f a -&gt; Bool)
-&gt; (Steps f a -&gt; Steps f a -&gt; Steps f a)
-&gt; (Steps f a -&gt; Steps f a -&gt; Steps f a)
-&gt; Ord (Steps f a)
Steps f a -&gt; Steps f a -&gt; Bool
Steps f a -&gt; Steps f a -&gt; Ordering
Steps f a -&gt; Steps f a -&gt; Steps f a
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall k (f :: k -&gt; *) (a :: k). Ord (f a) =&gt; Eq (Steps f a)
forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Steps f a -&gt; Steps f a -&gt; Bool
forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Steps f a -&gt; Steps f a -&gt; Ordering
forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Steps f a -&gt; Steps f a -&gt; Steps f a
min :: Steps f a -&gt; Steps f a -&gt; Steps f a
$cmin :: forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Steps f a -&gt; Steps f a -&gt; Steps f a
max :: Steps f a -&gt; Steps f a -&gt; Steps f a
$cmax :: forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Steps f a -&gt; Steps f a -&gt; Steps f a
&gt;= :: Steps f a -&gt; Steps f a -&gt; Bool
$c&gt;= :: forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Steps f a -&gt; Steps f a -&gt; Bool
&gt; :: Steps f a -&gt; Steps f a -&gt; Bool
$c&gt; :: forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Steps f a -&gt; Steps f a -&gt; Bool
&lt;= :: Steps f a -&gt; Steps f a -&gt; Bool
$c&lt;= :: forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Steps f a -&gt; Steps f a -&gt; Bool
&lt; :: Steps f a -&gt; Steps f a -&gt; Bool
$c&lt; :: forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Steps f a -&gt; Steps f a -&gt; Bool
compare :: Steps f a -&gt; Steps f a -&gt; Ordering
$ccompare :: forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Steps f a -&gt; Steps f a -&gt; Ordering
$cp1Ord :: forall k (f :: k -&gt; *) (a :: k). Ord (f a) =&gt; Eq (Steps f a)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679407288"><span id="local-6989586621679407290"><span class="annot"><span class="annottext">a -&gt; Steps f b -&gt; Steps f a
(a -&gt; b) -&gt; Steps f a -&gt; Steps f b
(forall a b. (a -&gt; b) -&gt; Steps f a -&gt; Steps f b)
-&gt; (forall a b. a -&gt; Steps f b -&gt; Steps f a) -&gt; Functor (Steps f)
forall a b. a -&gt; Steps f b -&gt; Steps f a
forall a b. (a -&gt; b) -&gt; Steps f a -&gt; Steps f b
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; Steps f b -&gt; Steps f a
forall (f :: * -&gt; *) a b.
Functor f =&gt;
(a -&gt; b) -&gt; Steps f a -&gt; Steps f b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: a -&gt; Steps f b -&gt; Steps f a
$c&lt;$ :: forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; Steps f b -&gt; Steps f a
fmap :: (a -&gt; b) -&gt; Steps f a -&gt; Steps f b
$cfmap :: forall (f :: * -&gt; *) a b.
Functor f =&gt;
(a -&gt; b) -&gt; Steps f a -&gt; Steps f b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679407254"><span id="local-6989586621679407256"><span id="local-6989586621679407258"><span id="local-6989586621679407260"><span id="local-6989586621679407262"><span id="local-6989586621679407264"><span id="local-6989586621679407266"><span id="local-6989586621679407268"><span id="local-6989586621679407270"><span id="local-6989586621679407272"><span id="local-6989586621679407274"><span id="local-6989586621679407276"><span id="local-6989586621679407278"><span id="local-6989586621679407280"><span id="local-6989586621679407282"><span id="local-6989586621679407284"><span id="local-6989586621679407286"><span class="annot"><span class="annottext">Steps f a -&gt; Bool
(a -&gt; m) -&gt; Steps f a -&gt; m
(a -&gt; b -&gt; b) -&gt; b -&gt; Steps f a -&gt; b
(forall m. Monoid m =&gt; Steps f m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Steps f a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Steps f a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Steps f a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Steps f a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Steps f a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Steps f a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; Steps f a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; Steps f a -&gt; a)
-&gt; (forall a. Steps f a -&gt; [a])
-&gt; (forall a. Steps f a -&gt; Bool)
-&gt; (forall a. Steps f a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; Steps f a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; Steps f a -&gt; a)
-&gt; (forall a. Ord a =&gt; Steps f a -&gt; a)
-&gt; (forall a. Num a =&gt; Steps f a -&gt; a)
-&gt; (forall a. Num a =&gt; Steps f a -&gt; a)
-&gt; Foldable (Steps f)
forall a. Eq a =&gt; a -&gt; Steps f a -&gt; Bool
forall a. Num a =&gt; Steps f a -&gt; a
forall a. Ord a =&gt; Steps f a -&gt; a
forall m. Monoid m =&gt; Steps f m -&gt; m
forall a. Steps f a -&gt; Bool
forall a. Steps f a -&gt; Int
forall a. Steps f a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; Steps f a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Steps f a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Steps f a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Steps f a -&gt; b
forall (f :: * -&gt; *) a.
(Foldable f, Eq a) =&gt;
a -&gt; Steps f a -&gt; Bool
forall (f :: * -&gt; *) a. (Foldable f, Num a) =&gt; Steps f a -&gt; a
forall (f :: * -&gt; *) a. (Foldable f, Ord a) =&gt; Steps f a -&gt; a
forall (f :: * -&gt; *) m. (Foldable f, Monoid m) =&gt; Steps f m -&gt; m
forall (f :: * -&gt; *) a. Foldable f =&gt; Steps f a -&gt; Bool
forall (f :: * -&gt; *) a. Foldable f =&gt; Steps f a -&gt; Int
forall (f :: * -&gt; *) a. Foldable f =&gt; Steps f a -&gt; [a]
forall (f :: * -&gt; *) a.
Foldable f =&gt;
(a -&gt; a -&gt; a) -&gt; Steps f a -&gt; a
forall (f :: * -&gt; *) m a.
(Foldable f, Monoid m) =&gt;
(a -&gt; m) -&gt; Steps f a -&gt; m
forall (f :: * -&gt; *) b a.
Foldable f =&gt;
(b -&gt; a -&gt; b) -&gt; b -&gt; Steps f a -&gt; b
forall (f :: * -&gt; *) a b.
Foldable f =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; Steps f a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: Steps f a -&gt; a
$cproduct :: forall (f :: * -&gt; *) a. (Foldable f, Num a) =&gt; Steps f a -&gt; a
sum :: Steps f a -&gt; a
$csum :: forall (f :: * -&gt; *) a. (Foldable f, Num a) =&gt; Steps f a -&gt; a
minimum :: Steps f a -&gt; a
$cminimum :: forall (f :: * -&gt; *) a. (Foldable f, Ord a) =&gt; Steps f a -&gt; a
maximum :: Steps f a -&gt; a
$cmaximum :: forall (f :: * -&gt; *) a. (Foldable f, Ord a) =&gt; Steps f a -&gt; a
elem :: a -&gt; Steps f a -&gt; Bool
$celem :: forall (f :: * -&gt; *) a.
(Foldable f, Eq a) =&gt;
a -&gt; Steps f a -&gt; Bool
length :: Steps f a -&gt; Int
$clength :: forall (f :: * -&gt; *) a. Foldable f =&gt; Steps f a -&gt; Int
null :: Steps f a -&gt; Bool
$cnull :: forall (f :: * -&gt; *) a. Foldable f =&gt; Steps f a -&gt; Bool
toList :: Steps f a -&gt; [a]
$ctoList :: forall (f :: * -&gt; *) a. Foldable f =&gt; Steps f a -&gt; [a]
foldl1 :: (a -&gt; a -&gt; a) -&gt; Steps f a -&gt; a
$cfoldl1 :: forall (f :: * -&gt; *) a.
Foldable f =&gt;
(a -&gt; a -&gt; a) -&gt; Steps f a -&gt; a
foldr1 :: (a -&gt; a -&gt; a) -&gt; Steps f a -&gt; a
$cfoldr1 :: forall (f :: * -&gt; *) a.
Foldable f =&gt;
(a -&gt; a -&gt; a) -&gt; Steps f a -&gt; a
foldl' :: (b -&gt; a -&gt; b) -&gt; b -&gt; Steps f a -&gt; b
$cfoldl' :: forall (f :: * -&gt; *) b a.
Foldable f =&gt;
(b -&gt; a -&gt; b) -&gt; b -&gt; Steps f a -&gt; b
foldl :: (b -&gt; a -&gt; b) -&gt; b -&gt; Steps f a -&gt; b
$cfoldl :: forall (f :: * -&gt; *) b a.
Foldable f =&gt;
(b -&gt; a -&gt; b) -&gt; b -&gt; Steps f a -&gt; b
foldr' :: (a -&gt; b -&gt; b) -&gt; b -&gt; Steps f a -&gt; b
$cfoldr' :: forall (f :: * -&gt; *) a b.
Foldable f =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; Steps f a -&gt; b
foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; Steps f a -&gt; b
$cfoldr :: forall (f :: * -&gt; *) a b.
Foldable f =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; Steps f a -&gt; b
foldMap' :: (a -&gt; m) -&gt; Steps f a -&gt; m
$cfoldMap' :: forall (f :: * -&gt; *) m a.
(Foldable f, Monoid m) =&gt;
(a -&gt; m) -&gt; Steps f a -&gt; m
foldMap :: (a -&gt; m) -&gt; Steps f a -&gt; m
$cfoldMap :: forall (f :: * -&gt; *) m a.
(Foldable f, Monoid m) =&gt;
(a -&gt; m) -&gt; Steps f a -&gt; m
fold :: Steps f m -&gt; m
$cfold :: forall (f :: * -&gt; *) m. (Foldable f, Monoid m) =&gt; Steps f m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679407244"><span id="local-6989586621679407246"><span id="local-6989586621679407248"><span id="local-6989586621679407250"><span class="annot"><span class="annottext">Functor (Steps f)
Foldable (Steps f)
(Functor (Steps f), Foldable (Steps f)) =&gt;
(forall (f :: * -&gt; *) a b.
 Applicative f =&gt;
 (a -&gt; f b) -&gt; Steps f a -&gt; f (Steps f b))
-&gt; (forall (f :: * -&gt; *) a.
    Applicative f =&gt;
    Steps f (f a) -&gt; f (Steps f a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; Steps f a -&gt; m (Steps f b))
-&gt; (forall (m :: * -&gt; *) a.
    Monad m =&gt;
    Steps f (m a) -&gt; m (Steps f a))
-&gt; Traversable (Steps f)
(a -&gt; f b) -&gt; Steps f a -&gt; f (Steps f b)
forall (t :: * -&gt; *).
(Functor t, Foldable t) =&gt;
(forall (f :: * -&gt; *) a b.
 Applicative f =&gt;
 (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (f :: * -&gt; *). Traversable f =&gt; Functor (Steps f)
forall (f :: * -&gt; *). Traversable f =&gt; Foldable (Steps f)
forall (f :: * -&gt; *) (m :: * -&gt; *) a.
(Traversable f, Monad m) =&gt;
Steps f (m a) -&gt; m (Steps f a)
forall (f :: * -&gt; *) (f :: * -&gt; *) a.
(Traversable f, Applicative f) =&gt;
Steps f (f a) -&gt; f (Steps f a)
forall (f :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable f, Monad m) =&gt;
(a -&gt; m b) -&gt; Steps f a -&gt; m (Steps f b)
forall (f :: * -&gt; *) (f :: * -&gt; *) a b.
(Traversable f, Applicative f) =&gt;
(a -&gt; f b) -&gt; Steps f a -&gt; f (Steps f b)
forall (m :: * -&gt; *) a. Monad m =&gt; Steps f (m a) -&gt; m (Steps f a)
forall (f :: * -&gt; *) a.
Applicative f =&gt;
Steps f (f a) -&gt; f (Steps f a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Steps f a -&gt; m (Steps f b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Steps f a -&gt; f (Steps f b)
sequence :: Steps f (m a) -&gt; m (Steps f a)
$csequence :: forall (f :: * -&gt; *) (m :: * -&gt; *) a.
(Traversable f, Monad m) =&gt;
Steps f (m a) -&gt; m (Steps f a)
mapM :: (a -&gt; m b) -&gt; Steps f a -&gt; m (Steps f b)
$cmapM :: forall (f :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable f, Monad m) =&gt;
(a -&gt; m b) -&gt; Steps f a -&gt; m (Steps f b)
sequenceA :: Steps f (f a) -&gt; f (Steps f a)
$csequenceA :: forall (f :: * -&gt; *) (f :: * -&gt; *) a.
(Traversable f, Applicative f) =&gt;
Steps f (f a) -&gt; f (Steps f a)
traverse :: (a -&gt; f b) -&gt; Steps f a -&gt; f (Steps f b)
$ctraverse :: forall (f :: * -&gt; *) (f :: * -&gt; *) a b.
(Traversable f, Applicative f) =&gt;
(a -&gt; f b) -&gt; Steps f a -&gt; f (Steps f b)
$cp2Traversable :: forall (f :: * -&gt; *). Traversable f =&gt; Foldable (Steps f)
$cp1Traversable :: forall (f :: * -&gt; *). Traversable f =&gt; Functor (Steps f)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">(forall x. Steps f a -&gt; Rep (Steps f a) x)
-&gt; (forall x. Rep (Steps f a) x -&gt; Steps f a)
-&gt; Generic (Steps f a)
forall x. Rep (Steps f a) x -&gt; Steps f a
forall x. Steps f a -&gt; Rep (Steps f a) x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall k (f :: k -&gt; *) (a :: k) x. Rep (Steps f a) x -&gt; Steps f a
forall k (f :: k -&gt; *) (a :: k) x. Steps f a -&gt; Rep (Steps f a) x
$cto :: forall k (f :: k -&gt; *) (a :: k) x. Rep (Steps f a) x -&gt; Steps f a
$cfrom :: forall k (f :: k -&gt; *) (a :: k) x. Steps f a -&gt; Rep (Steps f a) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">,</span><span> </span><span id="%24cSteps"><span id="%24tSteps"><span id="local-6989586621679407213"><span id="local-6989586621679407215"><span id="local-6989586621679407217"><span id="local-6989586621679407219"><span id="local-6989586621679407221"><span id="local-6989586621679407223"><span id="local-6989586621679407225"><span id="local-6989586621679407227"><span id="local-6989586621679407229"><span id="local-6989586621679407231"><span id="local-6989586621679407233"><span id="local-6989586621679407235"><span id="local-6989586621679407237"><span id="local-6989586621679407239"><span class="annot"><span class="annottext">Typeable (Steps f a)
DataType
Constr
Typeable (Steps f a) =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; Steps f a -&gt; c (Steps f a))
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Steps f a))
-&gt; (Steps f a -&gt; Constr)
-&gt; (Steps f a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Steps f a)))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e))
    -&gt; Maybe (c (Steps f a)))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; Steps f a -&gt; Steps f a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Steps f a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Steps f a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Steps f a -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Steps f a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Steps f a -&gt; m (Steps f a))
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Steps f a -&gt; m (Steps f a))
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Steps f a -&gt; m (Steps f a))
-&gt; Data (Steps f a)
Steps f a -&gt; DataType
Steps f a -&gt; Constr
(forall b. Data b =&gt; b -&gt; b) -&gt; Steps f a -&gt; Steps f a
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Steps f a -&gt; c (Steps f a)
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Steps f a)
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Steps f a -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Steps f a -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Steps f a -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Steps f a -&gt; r
forall k (f :: k -&gt; *) (a :: k).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
Typeable (Steps f a)
forall k (f :: k -&gt; *) (a :: k).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
Steps f a -&gt; DataType
forall k (f :: k -&gt; *) (a :: k).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
Steps f a -&gt; Constr
forall k (f :: k -&gt; *) (a :: k).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Steps f a -&gt; Steps f a
forall k (f :: k -&gt; *) (a :: k) u.
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Steps f a -&gt; u
forall k (f :: k -&gt; *) (a :: k) u.
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; Steps f a -&gt; [u]
forall k (f :: k -&gt; *) (a :: k) r r'.
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Steps f a -&gt; r
forall k (f :: k -&gt; *) (a :: k) r r'.
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Steps f a -&gt; r
forall k (f :: k -&gt; *) (a :: k) (m :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Steps f a -&gt; m (Steps f a)
forall k (f :: k -&gt; *) (a :: k) (m :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Steps f a -&gt; m (Steps f a)
forall k (f :: k -&gt; *) (a :: k) (c :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Steps f a)
forall k (f :: k -&gt; *) (a :: k) (c :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Steps f a -&gt; c (Steps f a)
forall k (f :: k -&gt; *) (a :: k) (t :: * -&gt; *) (c :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Steps f a))
forall k (f :: k -&gt; *) (a :: k) (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Steps f a))
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Steps f a -&gt; m (Steps f a)
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Steps f a -&gt; m (Steps f a)
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Steps f a)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Steps f a -&gt; c (Steps f a)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Steps f a))
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Steps f a))
$cSteps :: Constr
$tSteps :: DataType
gmapMo :: (forall d. Data d =&gt; d -&gt; m d) -&gt; Steps f a -&gt; m (Steps f a)
$cgmapMo :: forall k (f :: k -&gt; *) (a :: k) (m :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Steps f a -&gt; m (Steps f a)
gmapMp :: (forall d. Data d =&gt; d -&gt; m d) -&gt; Steps f a -&gt; m (Steps f a)
$cgmapMp :: forall k (f :: k -&gt; *) (a :: k) (m :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Steps f a -&gt; m (Steps f a)
gmapM :: (forall d. Data d =&gt; d -&gt; m d) -&gt; Steps f a -&gt; m (Steps f a)
$cgmapM :: forall k (f :: k -&gt; *) (a :: k) (m :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Steps f a -&gt; m (Steps f a)
gmapQi :: Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Steps f a -&gt; u
$cgmapQi :: forall k (f :: k -&gt; *) (a :: k) u.
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Steps f a -&gt; u
gmapQ :: (forall d. Data d =&gt; d -&gt; u) -&gt; Steps f a -&gt; [u]
$cgmapQ :: forall k (f :: k -&gt; *) (a :: k) u.
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; Steps f a -&gt; [u]
gmapQr :: (r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Steps f a -&gt; r
$cgmapQr :: forall k (f :: k -&gt; *) (a :: k) r r'.
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Steps f a -&gt; r
gmapQl :: (r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Steps f a -&gt; r
$cgmapQl :: forall k (f :: k -&gt; *) (a :: k) r r'.
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Steps f a -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Steps f a -&gt; Steps f a
$cgmapT :: forall k (f :: k -&gt; *) (a :: k).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Steps f a -&gt; Steps f a
dataCast2 :: (forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Steps f a))
$cdataCast2 :: forall k (f :: k -&gt; *) (a :: k) (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Steps f a))
dataCast1 :: (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Steps f a))
$cdataCast1 :: forall k (f :: k -&gt; *) (a :: k) (t :: * -&gt; *) (c :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Steps f a))
dataTypeOf :: Steps f a -&gt; DataType
$cdataTypeOf :: forall k (f :: k -&gt; *) (a :: k).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
Steps f a -&gt; DataType
toConstr :: Steps f a -&gt; Constr
$ctoConstr :: forall k (f :: k -&gt; *) (a :: k).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
Steps f a -&gt; Constr
gunfold :: (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Steps f a)
$cgunfold :: forall k (f :: k -&gt; *) (a :: k) (c :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Steps f a)
gfoldl :: (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Steps f a -&gt; c (Steps f a)
$cgfoldl :: forall k (f :: k -&gt; *) (a :: k) (c :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Steps f a -&gt; c (Steps f a)
$cp1Data :: forall k (f :: k -&gt; *) (a :: k).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
Typeable (Steps f a)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-216"></span><span>
</span><span id="line-217"></span><span id="local-6989586621679407207"><span id="local-6989586621679407209"><span id="local-6989586621679408091"><span class="hs-identifier">deriveShow1</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Steps</span></span></span></span><span>
</span><span id="line-218"></span><span id="local-6989586621679407199"><span id="local-6989586621679407201"><span id="local-6989586621679407203"><span id="local-6989586621679407205"><span id="local-6989586621679408091"><span class="hs-identifier">deriveRead1</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Steps</span></span></span></span></span></span><span>
</span><span id="line-219"></span><span id="local-6989586621679407197"><span id="local-6989586621679408091"><span class="hs-identifier">deriveEq1</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Steps</span></span></span><span>
</span><span id="line-220"></span><span id="local-6989586621679407194"><span id="local-6989586621679408091"><span class="hs-identifier">deriveOrd1</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Steps</span></span></span><span>
</span><span id="line-221"></span><span>
</span><span id="line-222"></span><span id="local-6989586621679407193"><span class="hs-keyword">instance</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Foldable1</span></span><span> </span><span class="annot"><a href="#local-6989586621679407193"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Foldable1</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-type">Steps</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679407193"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-223"></span><span>    </span><span id="local-6989586621679407188"><span class="annot"><span class="annottext">fold1 :: Steps f m -&gt; m
</span><a href="#local-6989586621679407188"><span class="hs-identifier hs-var hs-var hs-var hs-var">fold1</span></a></span></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(f m -&gt; m) -&gt; NEMap Natural (f m) -&gt; m
forall (t :: * -&gt; *) m a.
(Foldable1 t, Semigroup m) =&gt;
(a -&gt; m) -&gt; t a -&gt; m
</span><span class="hs-identifier hs-var">foldMap1</span></span><span> </span><span class="annot"><span class="annottext">f m -&gt; m
forall (t :: * -&gt; *) m. (Foldable1 t, Semigroup m) =&gt; t m -&gt; m
</span><span class="hs-identifier hs-var">fold1</span></span><span> </span><span class="annot"><span class="annottext">(NEMap Natural (f m) -&gt; m)
-&gt; (Steps f m -&gt; NEMap Natural (f m)) -&gt; Steps f m -&gt; m
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Steps f m -&gt; NEMap Natural (f m)
forall k (f :: k -&gt; *) (a :: k). Steps f a -&gt; NEMap Natural (f a)
</span><a href="Control.Applicative.Step.html#getSteps"><span class="hs-identifier hs-var hs-var">getSteps</span></a></span><span>
</span><span id="line-224"></span><span>    </span><span id="local-6989586621679407187"><span class="annot"><span class="annottext">foldMap1 :: (a -&gt; m) -&gt; Steps f a -&gt; m
</span><a href="#local-6989586621679407187"><span class="hs-identifier hs-var hs-var hs-var hs-var">foldMap1</span></a></span></span><span> </span><span id="local-6989586621679407186"><span class="annot"><span class="annottext">f :: a -&gt; m
</span><a href="#local-6989586621679407186"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(f a -&gt; m) -&gt; NEMap Natural (f a) -&gt; m
forall (t :: * -&gt; *) m a.
(Foldable1 t, Semigroup m) =&gt;
(a -&gt; m) -&gt; t a -&gt; m
</span><span class="hs-identifier hs-var">foldMap1</span></span><span> </span><span class="annot"><span class="annottext">((f a -&gt; m) -&gt; NEMap Natural (f a) -&gt; m)
-&gt; ((a -&gt; m) -&gt; f a -&gt; m) -&gt; (a -&gt; m) -&gt; NEMap Natural (f a) -&gt; m
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">(a -&gt; m) -&gt; f a -&gt; m
forall (t :: * -&gt; *) m a.
(Foldable1 t, Semigroup m) =&gt;
(a -&gt; m) -&gt; t a -&gt; m
</span><span class="hs-identifier hs-var">foldMap1</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">a -&gt; m
</span><a href="#local-6989586621679407186"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">(NEMap Natural (f a) -&gt; m)
-&gt; (Steps f a -&gt; NEMap Natural (f a)) -&gt; Steps f a -&gt; m
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Steps f a -&gt; NEMap Natural (f a)
forall k (f :: k -&gt; *) (a :: k). Steps f a -&gt; NEMap Natural (f a)
</span><a href="Control.Applicative.Step.html#getSteps"><span class="hs-identifier hs-var hs-var">getSteps</span></a></span><span>
</span><span id="line-225"></span><span>    </span><span id="local-6989586621679407185"><span class="annot"><span class="annottext">toNonEmpty :: Steps f a -&gt; NonEmpty a
</span><a href="#local-6989586621679407185"><span class="hs-identifier hs-var hs-var hs-var hs-var">toNonEmpty</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(f a -&gt; NonEmpty a) -&gt; NEMap Natural (f a) -&gt; NonEmpty a
forall (t :: * -&gt; *) m a.
(Foldable1 t, Semigroup m) =&gt;
(a -&gt; m) -&gt; t a -&gt; m
</span><span class="hs-identifier hs-var">foldMap1</span></span><span> </span><span class="annot"><span class="annottext">f a -&gt; NonEmpty a
forall (t :: * -&gt; *) a. Foldable1 t =&gt; t a -&gt; NonEmpty a
</span><span class="hs-identifier hs-var">toNonEmpty</span></span><span> </span><span class="annot"><span class="annottext">(NEMap Natural (f a) -&gt; NonEmpty a)
-&gt; (Steps f a -&gt; NEMap Natural (f a)) -&gt; Steps f a -&gt; NonEmpty a
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Steps f a -&gt; NEMap Natural (f a)
forall k (f :: k -&gt; *) (a :: k). Steps f a -&gt; NEMap Natural (f a)
</span><a href="Control.Applicative.Step.html#getSteps"><span class="hs-identifier hs-var hs-var">getSteps</span></a></span></span><span>
</span><span id="line-226"></span><span>
</span><span id="line-227"></span><span id="local-6989586621679407184"><span class="hs-keyword">instance</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Traversable1</span></span><span> </span><span class="annot"><a href="#local-6989586621679407184"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Traversable1</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-type">Steps</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679407184"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-228"></span><span>    </span><span id="local-6989586621679407179"><span class="annot"><span class="annottext">traverse1 :: (a -&gt; f b) -&gt; Steps f a -&gt; f (Steps f b)
</span><a href="#local-6989586621679407179"><span class="hs-identifier hs-var hs-var hs-var hs-var">traverse1</span></a></span></span><span> </span><span id="local-6989586621679407178"><span class="annot"><span class="annottext">f :: a -&gt; f b
</span><a href="#local-6989586621679407178"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(NEMap Natural (f b) -&gt; Steps f b)
-&gt; f (NEMap Natural (f b)) -&gt; f (Steps f b)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="annot"><span class="annottext">NEMap Natural (f b) -&gt; Steps f b
forall k (f :: k -&gt; *) (a :: k). NEMap Natural (f a) -&gt; Steps f a
</span><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-var">Steps</span></a></span><span> </span><span class="annot"><span class="annottext">(f (NEMap Natural (f b)) -&gt; f (Steps f b))
-&gt; (Steps f a -&gt; f (NEMap Natural (f b)))
-&gt; Steps f a
-&gt; f (Steps f b)
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(f a -&gt; f (f b)) -&gt; NEMap Natural (f a) -&gt; f (NEMap Natural (f b))
forall (t :: * -&gt; *) (f :: * -&gt; *) a b.
(Traversable1 t, Apply f) =&gt;
(a -&gt; f b) -&gt; t a -&gt; f (t b)
</span><span class="hs-identifier hs-var">traverse1</span></span><span> </span><span class="annot"><span class="annottext">((f a -&gt; f (f b))
 -&gt; NEMap Natural (f a) -&gt; f (NEMap Natural (f b)))
-&gt; ((a -&gt; f b) -&gt; f a -&gt; f (f b))
-&gt; (a -&gt; f b)
-&gt; NEMap Natural (f a)
-&gt; f (NEMap Natural (f b))
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">(a -&gt; f b) -&gt; f a -&gt; f (f b)
forall (t :: * -&gt; *) (f :: * -&gt; *) a b.
(Traversable1 t, Apply f) =&gt;
(a -&gt; f b) -&gt; t a -&gt; f (t b)
</span><span class="hs-identifier hs-var">traverse1</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">a -&gt; f b
</span><a href="#local-6989586621679407178"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">(NEMap Natural (f a) -&gt; f (NEMap Natural (f b)))
-&gt; (Steps f a -&gt; NEMap Natural (f a))
-&gt; Steps f a
-&gt; f (NEMap Natural (f b))
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Steps f a -&gt; NEMap Natural (f a)
forall k (f :: k -&gt; *) (a :: k). Steps f a -&gt; NEMap Natural (f a)
</span><a href="Control.Applicative.Step.html#getSteps"><span class="hs-identifier hs-var hs-var">getSteps</span></a></span><span>
</span><span id="line-229"></span><span>    </span><span id="local-6989586621679407177"><span class="annot"><span class="annottext">sequence1 :: Steps f (f b) -&gt; f (Steps f b)
</span><a href="#local-6989586621679407177"><span class="hs-identifier hs-var hs-var hs-var hs-var">sequence1</span></a></span></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(NEMap Natural (f b) -&gt; Steps f b)
-&gt; f (NEMap Natural (f b)) -&gt; f (Steps f b)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="annot"><span class="annottext">NEMap Natural (f b) -&gt; Steps f b
forall k (f :: k -&gt; *) (a :: k). NEMap Natural (f a) -&gt; Steps f a
</span><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-var">Steps</span></a></span><span> </span><span class="annot"><span class="annottext">(f (NEMap Natural (f b)) -&gt; f (Steps f b))
-&gt; (Steps f (f b) -&gt; f (NEMap Natural (f b)))
-&gt; Steps f (f b)
-&gt; f (Steps f b)
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">(f (f b) -&gt; f (f b))
-&gt; NEMap Natural (f (f b)) -&gt; f (NEMap Natural (f b))
forall (t :: * -&gt; *) (f :: * -&gt; *) a b.
(Traversable1 t, Apply f) =&gt;
(a -&gt; f b) -&gt; t a -&gt; f (t b)
</span><span class="hs-identifier hs-var">traverse1</span></span><span> </span><span class="annot"><span class="annottext">f (f b) -&gt; f (f b)
forall (t :: * -&gt; *) (f :: * -&gt; *) b.
(Traversable1 t, Apply f) =&gt;
t (f b) -&gt; f (t b)
</span><span class="hs-identifier hs-var">sequence1</span></span><span> </span><span class="annot"><span class="annottext">(NEMap Natural (f (f b)) -&gt; f (NEMap Natural (f b)))
-&gt; (Steps f (f b) -&gt; NEMap Natural (f (f b)))
-&gt; Steps f (f b)
-&gt; f (NEMap Natural (f b))
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Steps f (f b) -&gt; NEMap Natural (f (f b))
forall k (f :: k -&gt; *) (a :: k). Steps f a -&gt; NEMap Natural (f a)
</span><a href="Control.Applicative.Step.html#getSteps"><span class="hs-identifier hs-var hs-var">getSteps</span></a></span></span><span>
</span><span id="line-230"></span><span>
</span><span id="line-231"></span><span class="hs-comment">-- | Appends the items back-to-back, shifting all of the items in the</span><span>
</span><span id="line-232"></span><span class="hs-comment">-- second map.  Matches the behavior as the fixed-point of 'These1'.</span><span>
</span><span id="line-233"></span><span id="local-6989586621679407175"><span id="local-6989586621679407176"><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679407170"><span id="local-6989586621679407172"><span class="annot"><span class="hs-identifier hs-type">Semigroup</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-type">Steps</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679407176"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679407175"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-234"></span><span>    </span><span class="annot"><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-type">Steps</span></a></span><span> </span><span id="local-6989586621679407168"><span class="annot"><span class="annottext">xs :: NEMap Natural (f a)
</span><a href="#local-6989586621679407168"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span id="local-6989586621679407167"><span class="annot"><span class="annottext">&lt;&gt; :: Steps f a -&gt; Steps f a -&gt; Steps f a
</span><span class="hs-operator hs-var hs-var hs-var hs-var">&lt;&gt;</span></span></span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-type">Steps</span></a></span><span> </span><span id="local-6989586621679407166"><span class="annot"><span class="annottext">ys :: NEMap Natural (f a)
</span><a href="#local-6989586621679407166"><span class="hs-identifier hs-var">ys</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">NEMap Natural (f a) -&gt; Steps f a
forall k (f :: k -&gt; *) (a :: k). NEMap Natural (f a) -&gt; Steps f a
</span><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-var">Steps</span></a></span><span> </span><span class="annot"><span class="annottext">(NEMap Natural (f a) -&gt; Steps f a)
-&gt; NEMap Natural (f a) -&gt; Steps f a
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>
</span><span id="line-235"></span><span>      </span><span class="hs-keyword">let</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679407165"><span class="annot"><span class="annottext">k :: Natural
</span><a href="#local-6989586621679407165"><span class="hs-identifier hs-var">k</span></a></span></span><span class="hs-special">,</span><span> </span><span class="hs-identifier">_</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">NEMap Natural (f a) -&gt; (Natural, f a)
forall k a. NEMap k a -&gt; (k, a)
</span><span class="hs-identifier hs-var">NEM.findMax</span></span><span> </span><span class="annot"><span class="annottext">NEMap Natural (f a)
</span><a href="#local-6989586621679407168"><span class="hs-identifier hs-var">xs</span></a></span><span>
</span><span id="line-236"></span><span>      </span><span class="hs-keyword">in</span><span>  </span><span class="annot"><span class="annottext">NEMap Natural (f a)
</span><a href="#local-6989586621679407168"><span class="hs-identifier hs-var">xs</span></a></span><span> </span><span class="annot"><span class="annottext">NEMap Natural (f a) -&gt; NEMap Natural (f a) -&gt; NEMap Natural (f a)
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">(Natural -&gt; Natural) -&gt; NEMap Natural (f a) -&gt; NEMap Natural (f a)
forall k1 k2 a. (k1 -&gt; k2) -&gt; NEMap k1 a -&gt; NEMap k2 a
</span><span class="hs-identifier hs-var">NEM.mapKeysMonotonic</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Natural -&gt; Natural -&gt; Natural
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">+</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Natural
</span><a href="#local-6989586621679407165"><span class="hs-identifier hs-var">k</span></a></span><span> </span><span class="annot"><span class="annottext">Natural -&gt; Natural -&gt; Natural
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">+</span></span><span> </span><span class="annot"><span class="hs-number">1</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">NEMap Natural (f a)
</span><a href="#local-6989586621679407166"><span class="hs-identifier hs-var">ys</span></a></span></span></span><span>
</span><span id="line-237"></span><span>
</span><span id="line-238"></span><span class="hs-comment">-- | Left-biased untion</span><span>
</span><span id="line-239"></span><span id="local-6989586621679407162"><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679407156"><span id="local-6989586621679407158"><span class="annot"><span class="hs-identifier hs-type">Functor</span></span><span> </span><span class="annot"><a href="#local-6989586621679407162"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Alt</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-type">Steps</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679407162"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-240"></span><span>    </span><span class="annot"><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-type">Steps</span></a></span><span> </span><span id="local-6989586621679407154"><span class="annot"><span class="annottext">xs :: NEMap Natural (f a)
</span><a href="#local-6989586621679407154"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span id="local-6989586621679407153"><span class="annot"><span class="annottext">&lt;!&gt; :: Steps f a -&gt; Steps f a -&gt; Steps f a
</span><span class="hs-operator hs-var hs-var hs-var hs-var">&lt;!&gt;</span></span></span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-type">Steps</span></a></span><span> </span><span id="local-6989586621679407151"><span class="annot"><span class="annottext">ys :: NEMap Natural (f a)
</span><a href="#local-6989586621679407151"><span class="hs-identifier hs-var">ys</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">NEMap Natural (f a) -&gt; Steps f a
forall k (f :: k -&gt; *) (a :: k). NEMap Natural (f a) -&gt; Steps f a
</span><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-var">Steps</span></a></span><span> </span><span class="annot"><span class="annottext">(NEMap Natural (f a) -&gt; Steps f a)
-&gt; NEMap Natural (f a) -&gt; Steps f a
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">NEMap Natural (f a) -&gt; NEMap Natural (f a) -&gt; NEMap Natural (f a)
forall k a. Ord k =&gt; NEMap k a -&gt; NEMap k a -&gt; NEMap k a
</span><span class="hs-identifier hs-var">NEM.union</span></span><span> </span><span class="annot"><span class="annottext">NEMap Natural (f a)
</span><a href="#local-6989586621679407154"><span class="hs-identifier hs-var">xs</span></a></span><span> </span><span class="annot"><span class="annottext">NEMap Natural (f a)
</span><a href="#local-6989586621679407151"><span class="hs-identifier hs-var">ys</span></a></span></span><span>
</span><span id="line-241"></span><span>
</span><span id="line-242"></span><span id="local-6989586621679407149"><span class="hs-keyword">instance</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Pointed</span></span><span> </span><span class="annot"><a href="#local-6989586621679407149"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Pointed</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-type">Steps</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679407149"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-243"></span><span>    </span><span id="local-6989586621679407147"><span class="annot"><span class="annottext">point :: a -&gt; Steps f a
</span><a href="#local-6989586621679407147"><span class="hs-identifier hs-var hs-var hs-var hs-var">point</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">NEMap Natural (f a) -&gt; Steps f a
forall k (f :: k -&gt; *) (a :: k). NEMap Natural (f a) -&gt; Steps f a
</span><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-var">Steps</span></a></span><span> </span><span class="annot"><span class="annottext">(NEMap Natural (f a) -&gt; Steps f a)
-&gt; (a -&gt; NEMap Natural (f a)) -&gt; a -&gt; Steps f a
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Natural -&gt; f a -&gt; NEMap Natural (f a)
forall k a. k -&gt; a -&gt; NEMap k a
</span><span class="hs-identifier hs-var">NEM.singleton</span></span><span> </span><span class="annot"><span class="hs-number">0</span></span><span> </span><span class="annot"><span class="annottext">(f a -&gt; NEMap Natural (f a))
-&gt; (a -&gt; f a) -&gt; a -&gt; NEMap Natural (f a)
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; f a
forall (p :: * -&gt; *) a. Pointed p =&gt; a -&gt; p a
</span><span class="hs-identifier hs-var">point</span></span></span><span>
</span><span id="line-244"></span><span>
</span><span id="line-245"></span><span class="hs-comment">-- | &quot;Uncons and cons&quot; an @f@ branch before a 'Steps'.  This is basically</span><span>
</span><span id="line-246"></span><span class="hs-comment">-- a witness that 'stepsDown' and 'stepsUp' form an isomorphism.</span><span>
</span><span id="line-247"></span><span id="local-6989586621679407145"><span class="annot"><a href="Control.Applicative.Step.html#steppings"><span class="hs-identifier hs-type">steppings</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-type">Steps</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679407145"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="Control.Natural.IsoF.html#%3C~%3E"><span class="hs-operator hs-type">&lt;~&gt;</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">These1</span></span><span> </span><span class="annot"><a href="#local-6989586621679407145"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-type">Steps</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679407145"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-248"></span><span id="steppings"><span class="annot"><span class="annottext">steppings :: p (These1 f (Steps f) a) (These1 f (Steps f) a)
-&gt; p (Steps f a) (Steps f a)
</span><a href="Control.Applicative.Step.html#steppings"><span class="hs-identifier hs-var hs-var">steppings</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Steps f ~&gt; These1 f (Steps f))
-&gt; (These1 f (Steps f) ~&gt; Steps f)
-&gt; Steps f &lt;~&gt; These1 f (Steps f)
forall (f :: * -&gt; *) (g :: * -&gt; *). (f ~&gt; g) -&gt; (g ~&gt; f) -&gt; f &lt;~&gt; g
</span><a href="Control.Natural.IsoF.html#isoF"><span class="hs-identifier hs-var">isoF</span></a></span><span> </span><span class="annot"><span class="annottext">Steps f ~&gt; These1 f (Steps f)
forall (f :: * -&gt; *). Steps f ~&gt; These1 f (Steps f)
</span><a href="Control.Applicative.Step.html#stepsDown"><span class="hs-identifier hs-var">stepsDown</span></a></span><span> </span><span class="annot"><span class="annottext">These1 f (Steps f) ~&gt; Steps f
forall (f :: * -&gt; *). These1 f (Steps f) ~&gt; Steps f
</span><a href="Control.Applicative.Step.html#stepsUp"><span class="hs-identifier hs-var">stepsUp</span></a></span><span>
</span><span id="line-249"></span><span>
</span><span id="line-250"></span><span class="hs-comment">-- | Pop off the first item in a 'Steps'.  Because a @'Steps' f@ is @f</span><span>
</span><span id="line-251"></span><span class="hs-comment">-- `These1` f `These1` f `These1` ...@ forever, this matches on the first branch.</span><span>
</span><span id="line-252"></span><span class="hs-comment">--</span><span>
</span><span id="line-253"></span><span class="hs-comment">-- You can think of it as reassociating</span><span>
</span><span id="line-254"></span><span class="hs-comment">--</span><span>
</span><span id="line-255"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-256"></span><span class="hs-comment">-- f `These1` f `These1` f `These1` f `These1` ...</span><span>
</span><span id="line-257"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-258"></span><span class="hs-comment">--</span><span>
</span><span id="line-259"></span><span class="hs-comment">-- into</span><span>
</span><span id="line-260"></span><span class="hs-comment">--</span><span>
</span><span id="line-261"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-262"></span><span class="hs-comment">-- f `These1` ( f `These1` f `These1` f `These1` ...)</span><span>
</span><span id="line-263"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-264"></span><span class="hs-comment">--</span><span>
</span><span id="line-265"></span><span class="hs-comment">-- It returns:</span><span>
</span><span id="line-266"></span><span class="hs-comment">--</span><span>
</span><span id="line-267"></span><span class="hs-comment">-- *  'This1' if the first item is the /only/ item in the 'Steps'</span><span>
</span><span id="line-268"></span><span class="hs-comment">-- *  'That1' if the first item in the 'Steps' is empty, but there are more</span><span>
</span><span id="line-269"></span><span class="hs-comment">--    items left.  The extra items are all shfited down.</span><span>
</span><span id="line-270"></span><span class="hs-comment">-- *  'These1' if the first item in the 'Steps' exists, and there are also</span><span>
</span><span id="line-271"></span><span class="hs-comment">--    more items left.  The extra items are all shifted down.</span><span>
</span><span id="line-272"></span><span class="hs-comment">--</span><span>
</span><span id="line-273"></span><span class="hs-comment">-- Forms an isomorphism with 'stepsUp' (see 'steppings').</span><span>
</span><span id="line-274"></span><span id="local-6989586621679408048"><span class="annot"><a href="Control.Applicative.Step.html#stepsDown"><span class="hs-identifier hs-type">stepsDown</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-type">Steps</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679408048"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">~&gt;</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">These1</span></span><span> </span><span class="annot"><a href="#local-6989586621679408048"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-type">Steps</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679408048"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-275"></span><span id="stepsDown"><span class="annot"><span class="annottext">stepsDown :: Steps f x -&gt; These1 f (Steps f) x
</span><a href="Control.Applicative.Step.html#stepsDown"><span class="hs-identifier hs-var hs-var">stepsDown</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(f x -&gt; These1 f (Steps f) x)
-&gt; (Steps f x -&gt; These1 f (Steps f) x)
-&gt; (f x -&gt; Steps f x -&gt; These1 f (Steps f) x)
-&gt; These (f x) (Steps f x)
-&gt; These1 f (Steps f) x
forall a c b.
(a -&gt; c) -&gt; (b -&gt; c) -&gt; (a -&gt; b -&gt; c) -&gt; These a b -&gt; c
</span><span class="hs-identifier hs-var">these</span></span><span> </span><span class="annot"><span class="annottext">f x -&gt; These1 f (Steps f) x
forall (f :: * -&gt; *) (g :: * -&gt; *) a. f a -&gt; These1 f g a
</span><span class="hs-identifier hs-var">This1</span></span><span> </span><span class="annot"><span class="annottext">Steps f x -&gt; These1 f (Steps f) x
forall (f :: * -&gt; *) (g :: * -&gt; *) a. g a -&gt; These1 f g a
</span><span class="hs-identifier hs-var">That1</span></span><span> </span><span class="annot"><span class="annottext">f x -&gt; Steps f x -&gt; These1 f (Steps f) x
forall (f :: * -&gt; *) (g :: * -&gt; *) a. f a -&gt; g a -&gt; These1 f g a
</span><span class="hs-identifier hs-var">These1</span></span><span>
</span><span id="line-276"></span><span>          </span><span class="annot"><span class="annottext">(These (f x) (Steps f x) -&gt; These1 f (Steps f) x)
-&gt; (Steps f x -&gt; These (f x) (Steps f x))
-&gt; Steps f x
-&gt; These1 f (Steps f) x
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">(First (f x) -&gt; f x)
-&gt; (NEMap Natural (f x) -&gt; Steps f x)
-&gt; These (First (f x)) (NEMap Natural (f x))
-&gt; These (f x) (Steps f x)
forall (p :: * -&gt; * -&gt; *) a b c d.
Bifunctor p =&gt;
(a -&gt; b) -&gt; (c -&gt; d) -&gt; p a c -&gt; p b d
</span><span class="hs-identifier hs-var">bimap</span></span><span> </span><span class="annot"><span class="annottext">First (f x) -&gt; f x
forall a. First a -&gt; a
</span><span class="hs-identifier hs-var hs-var">getFirst</span></span><span> </span><span class="annot"><span class="annottext">NEMap Natural (f x) -&gt; Steps f x
forall k (f :: k -&gt; *) (a :: k). NEMap Natural (f a) -&gt; Steps f a
</span><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-var">Steps</span></a></span><span>
</span><span id="line-277"></span><span>          </span><span class="annot"><span class="annottext">(These (First (f x)) (NEMap Natural (f x))
 -&gt; These (f x) (Steps f x))
-&gt; (Steps f x -&gt; These (First (f x)) (NEMap Natural (f x)))
-&gt; Steps f x
-&gt; These (f x) (Steps f x)
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">(Natural -&gt; f x -&gt; These (First (f x)) (NEMap Natural (f x)))
-&gt; NEMap Natural (f x) -&gt; These (First (f x)) (NEMap Natural (f x))
forall m k a. Semigroup m =&gt; (k -&gt; a -&gt; m) -&gt; NEMap k a -&gt; m
</span><span class="hs-identifier hs-var">NEM.foldMapWithKey</span></span><span> </span><span class="annot"><span class="annottext">Natural -&gt; f x -&gt; These (First (f x)) (NEMap Natural (f x))
forall k (f :: k -&gt; *) (a :: k).
Natural -&gt; f a -&gt; These (First (f a)) (NEMap Natural (f a))
</span><a href="Control.Applicative.Step.html#decr"><span class="hs-identifier hs-var">decr</span></a></span><span>
</span><span id="line-278"></span><span>          </span><span class="annot"><span class="annottext">(NEMap Natural (f x) -&gt; These (First (f x)) (NEMap Natural (f x)))
-&gt; (Steps f x -&gt; NEMap Natural (f x))
-&gt; Steps f x
-&gt; These (First (f x)) (NEMap Natural (f x))
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Steps f x -&gt; NEMap Natural (f x)
forall k (f :: k -&gt; *) (a :: k). Steps f a -&gt; NEMap Natural (f a)
</span><a href="Control.Applicative.Step.html#getSteps"><span class="hs-identifier hs-var hs-var">getSteps</span></a></span><span>
</span><span id="line-279"></span><span>
</span><span id="line-280"></span><span id="local-6989586621679408024"><span id="local-6989586621679408025"><span class="annot"><a href="Control.Applicative.Step.html#decr"><span class="hs-identifier hs-type">decr</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Natural</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679408025"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679408024"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">These</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">First</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679408025"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679408024"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">NEMap</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Natural</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679408025"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679408024"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span></span></span><span>
</span><span id="line-281"></span><span id="decr"><span class="annot"><span class="annottext">decr :: Natural -&gt; f a -&gt; These (First (f a)) (NEMap Natural (f a))
</span><a href="Control.Applicative.Step.html#decr"><span class="hs-identifier hs-var hs-var">decr</span></a></span></span><span> </span><span id="local-6989586621679407136"><span class="annot"><span class="annottext">i :: Natural
</span><a href="#local-6989586621679407136"><span class="hs-identifier hs-var">i</span></a></span></span><span> </span><span id="local-6989586621679407135"><span class="annot"><span class="annottext">x :: f a
</span><a href="#local-6989586621679407135"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Natural -&gt; Natural -&gt; Maybe Natural
</span><span class="hs-identifier hs-var">minusNaturalMaybe</span></span><span> </span><span class="annot"><span class="annottext">Natural
</span><a href="#local-6989586621679407136"><span class="hs-identifier hs-var">i</span></a></span><span> </span><span class="annot"><span class="hs-number">1</span></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-282"></span><span>      </span><span class="annot"><span class="hs-identifier hs-type">Nothing</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">First (f a) -&gt; These (First (f a)) (NEMap Natural (f a))
forall a b. a -&gt; These a b
</span><span class="hs-identifier hs-var">This</span></span><span> </span><span class="annot"><span class="annottext">(First (f a) -&gt; These (First (f a)) (NEMap Natural (f a)))
-&gt; First (f a) -&gt; These (First (f a)) (NEMap Natural (f a))
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">f a -&gt; First (f a)
forall a. a -&gt; First a
</span><span class="hs-identifier hs-var">First</span></span><span> </span><span class="annot"><span class="annottext">f a
</span><a href="#local-6989586621679407135"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-283"></span><span>      </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621679407132"><span class="annot"><span class="annottext">i' :: Natural
</span><a href="#local-6989586621679407132"><span class="hs-identifier hs-var">i'</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">NEMap Natural (f a) -&gt; These (First (f a)) (NEMap Natural (f a))
forall a b. b -&gt; These a b
</span><span class="hs-identifier hs-var">That</span></span><span> </span><span class="annot"><span class="annottext">(NEMap Natural (f a) -&gt; These (First (f a)) (NEMap Natural (f a)))
-&gt; NEMap Natural (f a) -&gt; These (First (f a)) (NEMap Natural (f a))
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Natural -&gt; f a -&gt; NEMap Natural (f a)
forall k a. k -&gt; a -&gt; NEMap k a
</span><span class="hs-identifier hs-var">NEM.singleton</span></span><span> </span><span class="annot"><span class="annottext">Natural
</span><a href="#local-6989586621679407132"><span class="hs-identifier hs-var">i'</span></a></span><span> </span><span class="annot"><span class="annottext">f a
</span><a href="#local-6989586621679407135"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-284"></span><span>
</span><span id="line-285"></span><span class="hs-comment">-- | Unshift an item into a 'Steps'.  Because a @'Steps' f@ is @f `These1`</span><span>
</span><span id="line-286"></span><span class="hs-comment">-- f `These1` f `These1` f `These1` ...@ forever, this basically conses an</span><span>
</span><span id="line-287"></span><span class="hs-comment">-- additional possibility of @f@ to the beginning of it all.</span><span>
</span><span id="line-288"></span><span class="hs-comment">--</span><span>
</span><span id="line-289"></span><span class="hs-comment">-- You can think of it as reassociating</span><span>
</span><span id="line-290"></span><span class="hs-comment">--</span><span>
</span><span id="line-291"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-292"></span><span class="hs-comment">-- f `These1` ( f `These1` f `These1` f `These1` ...)</span><span>
</span><span id="line-293"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-294"></span><span class="hs-comment">--</span><span>
</span><span id="line-295"></span><span class="hs-comment">-- into</span><span>
</span><span id="line-296"></span><span class="hs-comment">--</span><span>
</span><span id="line-297"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-298"></span><span class="hs-comment">-- f `These1` f `These1` f `These1` f `These1` ...</span><span>
</span><span id="line-299"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-300"></span><span class="hs-comment">--</span><span>
</span><span id="line-301"></span><span class="hs-comment">-- If you give:</span><span>
</span><span id="line-302"></span><span class="hs-comment">--</span><span>
</span><span id="line-303"></span><span class="hs-comment">-- *  'This1', then it returns a singleton 'Steps' with one item at</span><span>
</span><span id="line-304"></span><span class="hs-comment">--    index 0</span><span>
</span><span id="line-305"></span><span class="hs-comment">-- *  'That1', then it shifts every item in the given 'Steps' up one</span><span>
</span><span id="line-306"></span><span class="hs-comment">--    index.</span><span>
</span><span id="line-307"></span><span class="hs-comment">-- *  'These1', then it shifts every item in the given 'Steps' up one</span><span>
</span><span id="line-308"></span><span class="hs-comment">--    index, and adds the given item (the @f@) at index zero.</span><span>
</span><span id="line-309"></span><span class="hs-comment">--</span><span>
</span><span id="line-310"></span><span class="hs-comment">-- Forms an isomorphism with 'stepDown' (see 'stepping').</span><span>
</span><span id="line-311"></span><span id="local-6989586621679408047"><span class="annot"><a href="Control.Applicative.Step.html#stepsUp"><span class="hs-identifier hs-type">stepsUp</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">These1</span></span><span> </span><span class="annot"><a href="#local-6989586621679408047"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-type">Steps</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679408047"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="hs-operator hs-type">~&gt;</span></span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-type">Steps</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679408047"><span class="hs-identifier hs-type">f</span></a></span></span><span>
</span><span id="line-312"></span><span id="stepsUp"><span class="annot"><span class="annottext">stepsUp :: These1 f (Steps f) x -&gt; Steps f x
</span><a href="Control.Applicative.Step.html#stepsUp"><span class="hs-identifier hs-var hs-var">stepsUp</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-313"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">This1</span></span><span>  </span><span id="local-6989586621679407130"><span class="annot"><span class="annottext">x :: f x
</span><a href="#local-6989586621679407130"><span class="hs-identifier hs-var">x</span></a></span></span><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">NEMap Natural (f x) -&gt; Steps f x
forall k (f :: k -&gt; *) (a :: k). NEMap Natural (f a) -&gt; Steps f a
</span><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-var">Steps</span></a></span><span> </span><span class="annot"><span class="annottext">(NEMap Natural (f x) -&gt; Steps f x)
-&gt; NEMap Natural (f x) -&gt; Steps f x
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Natural -&gt; f x -&gt; NEMap Natural (f x)
forall k a. k -&gt; a -&gt; NEMap k a
</span><span class="hs-identifier hs-var">NEM.singleton</span></span><span> </span><span class="annot"><span class="hs-number">0</span></span><span> </span><span class="annot"><span class="annottext">f x
</span><a href="#local-6989586621679407130"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-314"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">That1</span></span><span>    </span><span id="local-6989586621679407129"><span class="annot"><span class="annottext">xs :: Steps f x
</span><a href="#local-6989586621679407129"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">NEMap Natural (f x) -&gt; Steps f x
forall k (f :: k -&gt; *) (a :: k). NEMap Natural (f a) -&gt; Steps f a
</span><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-var">Steps</span></a></span><span> </span><span class="annot"><span class="annottext">(NEMap Natural (f x) -&gt; Steps f x)
-&gt; (Steps f x -&gt; NEMap Natural (f x)) -&gt; Steps f x -&gt; Steps f x
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">(Natural -&gt; Natural) -&gt; NEMap Natural (f x) -&gt; NEMap Natural (f x)
forall k1 k2 a. (k1 -&gt; k2) -&gt; NEMap k1 a -&gt; NEMap k2 a
</span><span class="hs-identifier hs-var">NEM.mapKeysMonotonic</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Natural -&gt; Natural -&gt; Natural
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">+</span></span><span> </span><span class="annot"><span class="hs-number">1</span></span><span class="hs-special">)</span><span>
</span><span id="line-315"></span><span>                         </span><span class="annot"><span class="annottext">(NEMap Natural (f x) -&gt; NEMap Natural (f x))
-&gt; (Steps f x -&gt; NEMap Natural (f x))
-&gt; Steps f x
-&gt; NEMap Natural (f x)
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Steps f x -&gt; NEMap Natural (f x)
forall k (f :: k -&gt; *) (a :: k). Steps f a -&gt; NEMap Natural (f a)
</span><a href="Control.Applicative.Step.html#getSteps"><span class="hs-identifier hs-var hs-var">getSteps</span></a></span><span>
</span><span id="line-316"></span><span>                         </span><span class="annot"><span class="annottext">(Steps f x -&gt; Steps f x) -&gt; Steps f x -&gt; Steps f x
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Steps f x
</span><a href="#local-6989586621679407129"><span class="hs-identifier hs-var">xs</span></a></span><span>
</span><span id="line-317"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">These1</span></span><span> </span><span id="local-6989586621679407128"><span class="annot"><span class="annottext">x :: f x
</span><a href="#local-6989586621679407128"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679407127"><span class="annot"><span class="annottext">xs :: Steps f x
</span><a href="#local-6989586621679407127"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">NEMap Natural (f x) -&gt; Steps f x
forall k (f :: k -&gt; *) (a :: k). NEMap Natural (f a) -&gt; Steps f a
</span><a href="Control.Applicative.Step.html#Steps"><span class="hs-identifier hs-var">Steps</span></a></span><span> </span><span class="annot"><span class="annottext">(NEMap Natural (f x) -&gt; Steps f x)
-&gt; (Steps f x -&gt; NEMap Natural (f x)) -&gt; Steps f x -&gt; Steps f x
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Natural -&gt; f x -&gt; Map Natural (f x) -&gt; NEMap Natural (f x)
forall k a. k -&gt; a -&gt; Map k a -&gt; NEMap k a
</span><span class="hs-identifier hs-var">NEM.insertMapMin</span></span><span> </span><span class="annot"><span class="hs-number">0</span></span><span> </span><span class="annot"><span class="annottext">f x
</span><a href="#local-6989586621679407128"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-318"></span><span>                         </span><span class="annot"><span class="annottext">(Map Natural (f x) -&gt; NEMap Natural (f x))
-&gt; (Steps f x -&gt; Map Natural (f x))
-&gt; Steps f x
-&gt; NEMap Natural (f x)
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">NEMap Natural (f x) -&gt; Map Natural (f x)
forall k a. NEMap k a -&gt; Map k a
</span><span class="hs-identifier hs-var">NEM.toMap</span></span><span>
</span><span id="line-319"></span><span>                         </span><span class="annot"><span class="annottext">(NEMap Natural (f x) -&gt; Map Natural (f x))
-&gt; (Steps f x -&gt; NEMap Natural (f x))
-&gt; Steps f x
-&gt; Map Natural (f x)
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">(Natural -&gt; Natural) -&gt; NEMap Natural (f x) -&gt; NEMap Natural (f x)
forall k1 k2 a. (k1 -&gt; k2) -&gt; NEMap k1 a -&gt; NEMap k2 a
</span><span class="hs-identifier hs-var">NEM.mapKeysMonotonic</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Natural -&gt; Natural -&gt; Natural
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">+</span></span><span> </span><span class="annot"><span class="hs-number">1</span></span><span class="hs-special">)</span><span>
</span><span id="line-320"></span><span>                         </span><span class="annot"><span class="annottext">(NEMap Natural (f x) -&gt; NEMap Natural (f x))
-&gt; (Steps f x -&gt; NEMap Natural (f x))
-&gt; Steps f x
-&gt; NEMap Natural (f x)
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Steps f x -&gt; NEMap Natural (f x)
forall k (f :: k -&gt; *) (a :: k). Steps f a -&gt; NEMap Natural (f a)
</span><a href="Control.Applicative.Step.html#getSteps"><span class="hs-identifier hs-var hs-var">getSteps</span></a></span><span>
</span><span id="line-321"></span><span>                         </span><span class="annot"><span class="annottext">(Steps f x -&gt; Steps f x) -&gt; Steps f x -&gt; Steps f x
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Steps f x
</span><a href="#local-6989586621679407127"><span class="hs-identifier hs-var">xs</span></a></span><span>
</span><span id="line-322"></span><span>
</span><span id="line-323"></span><span>
</span><span id="line-324"></span><span class="hs-comment">-- | An @f a@, along with a 'Bool' flag</span><span>
</span><span id="line-325"></span><span class="hs-comment">--</span><span>
</span><span id="line-326"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-327"></span><span class="hs-comment">-- 'Flagged' f a ~ ('Bool', f a)</span><span>
</span><span id="line-328"></span><span class="hs-comment">-- Flagged f   ~ ((,) Bool) ':.:' f       -- functor composition</span><span>
</span><span id="line-329"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-330"></span><span class="hs-comment">--</span><span>
</span><span id="line-331"></span><span class="hs-comment">-- Creation with 'Data.HFunctor.inject' or 'pure' uses 'False' as the</span><span>
</span><span id="line-332"></span><span class="hs-comment">-- boolean.</span><span>
</span><span id="line-333"></span><span class="hs-comment">--</span><span>
</span><span id="line-334"></span><span class="hs-comment">-- You can think of it as an @f a@ that is &quot;flagged&quot; with a boolean value,</span><span>
</span><span id="line-335"></span><span class="hs-comment">-- and that value can indicuate whether or not it is &quot;pure&quot; (made with</span><span>
</span><span id="line-336"></span><span class="hs-comment">-- 'Data.HFunctor.inject' or 'pure') as 'False', or &quot;impure&quot;</span><span>
</span><span id="line-337"></span><span class="hs-comment">-- (made from some other source) as 'True'.  However, 'False' may be always</span><span>
</span><span id="line-338"></span><span class="hs-comment">-- created directly, of course, using the constructor.</span><span>
</span><span id="line-339"></span><span class="hs-comment">--</span><span>
</span><span id="line-340"></span><span class="hs-comment">-- You can think of it like a 'Step' that is either 0 or 1, as well.</span><span>
</span><span id="line-341"></span><span class="hs-comment">--</span><span>
</span><span id="line-342"></span><span class="hs-comment">-- 'Data.HFunctor.Interpret.interpret'ing it requires no constraint on the</span><span>
</span><span id="line-343"></span><span class="hs-comment">-- target context.</span><span>
</span><span id="line-344"></span><span class="hs-comment">--</span><span>
</span><span id="line-345"></span><span class="hs-comment">-- This type is equivalent (along with its instances) to:</span><span>
</span><span id="line-346"></span><span class="hs-comment">--</span><span>
</span><span id="line-347"></span><span class="hs-comment">-- *   @'Data.HFunctor.HLift' 'Control.Monad.Trans.Identity.IdentityT'@</span><span>
</span><span id="line-348"></span><span class="hs-comment">-- *   @'Control.COmonad.Trans.Env.EnvT' 'Data.Semigroup.Any'@</span><span>
</span><span id="line-349"></span><span id="local-6989586621679407123"><span id="local-6989586621679407124"></span></span><span class="hs-keyword">data</span><span> </span><span id="Flagged"><span class="annot"><a href="Control.Applicative.Step.html#Flagged"><span class="hs-identifier hs-var">Flagged</span></a></span></span><span> </span><span id="local-6989586621679407905"><span class="annot"><a href="#local-6989586621679407905"><span class="hs-identifier hs-type">f</span></a></span></span><span> </span><span id="local-6989586621679407904"><span class="annot"><a href="#local-6989586621679407904"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="Flagged"><span class="annot"><a href="Control.Applicative.Step.html#Flagged"><span class="hs-identifier hs-var">Flagged</span></a></span></span><span> </span><span class="hs-special">{</span><span> </span><span id="flaggedFlag"><span class="annot"><span class="annottext">Flagged f a -&gt; Bool
</span><a href="Control.Applicative.Step.html#flaggedFlag"><span class="hs-identifier hs-var hs-var">flaggedFlag</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span class="hs-special">,</span><span> </span><span id="flaggedVal"><span class="annot"><span class="annottext">Flagged f a -&gt; f a
</span><a href="Control.Applicative.Step.html#flaggedVal"><span class="hs-identifier hs-var hs-var">flaggedVal</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621679407905"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679407904"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-350"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679407114"><span id="local-6989586621679407116"><span id="local-6989586621679407118"><span class="annot"><span class="annottext">Int -&gt; Flagged f a -&gt; ShowS
[Flagged f a] -&gt; ShowS
Flagged f a -&gt; String
(Int -&gt; Flagged f a -&gt; ShowS)
-&gt; (Flagged f a -&gt; String)
-&gt; ([Flagged f a] -&gt; ShowS)
-&gt; Show (Flagged f a)
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
forall k (f :: k -&gt; *) (a :: k).
Show (f a) =&gt;
Int -&gt; Flagged f a -&gt; ShowS
forall k (f :: k -&gt; *) (a :: k).
Show (f a) =&gt;
[Flagged f a] -&gt; ShowS
forall k (f :: k -&gt; *) (a :: k).
Show (f a) =&gt;
Flagged f a -&gt; String
showList :: [Flagged f a] -&gt; ShowS
$cshowList :: forall k (f :: k -&gt; *) (a :: k).
Show (f a) =&gt;
[Flagged f a] -&gt; ShowS
show :: Flagged f a -&gt; String
$cshow :: forall k (f :: k -&gt; *) (a :: k).
Show (f a) =&gt;
Flagged f a -&gt; String
showsPrec :: Int -&gt; Flagged f a -&gt; ShowS
$cshowsPrec :: forall k (f :: k -&gt; *) (a :: k).
Show (f a) =&gt;
Int -&gt; Flagged f a -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679407106"><span id="local-6989586621679407108"><span id="local-6989586621679407110"><span id="local-6989586621679407112"><span class="annot"><span class="annottext">ReadPrec [Flagged f a]
ReadPrec (Flagged f a)
Int -&gt; ReadS (Flagged f a)
ReadS [Flagged f a]
(Int -&gt; ReadS (Flagged f a))
-&gt; ReadS [Flagged f a]
-&gt; ReadPrec (Flagged f a)
-&gt; ReadPrec [Flagged f a]
-&gt; Read (Flagged f a)
forall a.
(Int -&gt; ReadS a)
-&gt; ReadS [a] -&gt; ReadPrec a -&gt; ReadPrec [a] -&gt; Read a
forall k (f :: k -&gt; *) (a :: k).
Read (f a) =&gt;
ReadPrec [Flagged f a]
forall k (f :: k -&gt; *) (a :: k).
Read (f a) =&gt;
ReadPrec (Flagged f a)
forall k (f :: k -&gt; *) (a :: k).
Read (f a) =&gt;
Int -&gt; ReadS (Flagged f a)
forall k (f :: k -&gt; *) (a :: k). Read (f a) =&gt; ReadS [Flagged f a]
readListPrec :: ReadPrec [Flagged f a]
$creadListPrec :: forall k (f :: k -&gt; *) (a :: k).
Read (f a) =&gt;
ReadPrec [Flagged f a]
readPrec :: ReadPrec (Flagged f a)
$creadPrec :: forall k (f :: k -&gt; *) (a :: k).
Read (f a) =&gt;
ReadPrec (Flagged f a)
readList :: ReadS [Flagged f a]
$creadList :: forall k (f :: k -&gt; *) (a :: k). Read (f a) =&gt; ReadS [Flagged f a]
readsPrec :: Int -&gt; ReadS (Flagged f a)
$creadsPrec :: forall k (f :: k -&gt; *) (a :: k).
Read (f a) =&gt;
Int -&gt; ReadS (Flagged f a)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Read</span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679407102"><span id="local-6989586621679407104"><span class="annot"><span class="annottext">Flagged f a -&gt; Flagged f a -&gt; Bool
(Flagged f a -&gt; Flagged f a -&gt; Bool)
-&gt; (Flagged f a -&gt; Flagged f a -&gt; Bool) -&gt; Eq (Flagged f a)
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
forall k (f :: k -&gt; *) (a :: k).
Eq (f a) =&gt;
Flagged f a -&gt; Flagged f a -&gt; Bool
/= :: Flagged f a -&gt; Flagged f a -&gt; Bool
$c/= :: forall k (f :: k -&gt; *) (a :: k).
Eq (f a) =&gt;
Flagged f a -&gt; Flagged f a -&gt; Bool
== :: Flagged f a -&gt; Flagged f a -&gt; Bool
$c== :: forall k (f :: k -&gt; *) (a :: k).
Eq (f a) =&gt;
Flagged f a -&gt; Flagged f a -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679407087"><span id="local-6989586621679407089"><span id="local-6989586621679407091"><span id="local-6989586621679407093"><span id="local-6989586621679407095"><span id="local-6989586621679407097"><span id="local-6989586621679407099"><span class="annot"><span class="annottext">Eq (Flagged f a)
Eq (Flagged f a) =&gt;
(Flagged f a -&gt; Flagged f a -&gt; Ordering)
-&gt; (Flagged f a -&gt; Flagged f a -&gt; Bool)
-&gt; (Flagged f a -&gt; Flagged f a -&gt; Bool)
-&gt; (Flagged f a -&gt; Flagged f a -&gt; Bool)
-&gt; (Flagged f a -&gt; Flagged f a -&gt; Bool)
-&gt; (Flagged f a -&gt; Flagged f a -&gt; Flagged f a)
-&gt; (Flagged f a -&gt; Flagged f a -&gt; Flagged f a)
-&gt; Ord (Flagged f a)
Flagged f a -&gt; Flagged f a -&gt; Bool
Flagged f a -&gt; Flagged f a -&gt; Ordering
Flagged f a -&gt; Flagged f a -&gt; Flagged f a
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall k (f :: k -&gt; *) (a :: k). Ord (f a) =&gt; Eq (Flagged f a)
forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Flagged f a -&gt; Flagged f a -&gt; Bool
forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Flagged f a -&gt; Flagged f a -&gt; Ordering
forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Flagged f a -&gt; Flagged f a -&gt; Flagged f a
min :: Flagged f a -&gt; Flagged f a -&gt; Flagged f a
$cmin :: forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Flagged f a -&gt; Flagged f a -&gt; Flagged f a
max :: Flagged f a -&gt; Flagged f a -&gt; Flagged f a
$cmax :: forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Flagged f a -&gt; Flagged f a -&gt; Flagged f a
&gt;= :: Flagged f a -&gt; Flagged f a -&gt; Bool
$c&gt;= :: forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Flagged f a -&gt; Flagged f a -&gt; Bool
&gt; :: Flagged f a -&gt; Flagged f a -&gt; Bool
$c&gt; :: forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Flagged f a -&gt; Flagged f a -&gt; Bool
&lt;= :: Flagged f a -&gt; Flagged f a -&gt; Bool
$c&lt;= :: forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Flagged f a -&gt; Flagged f a -&gt; Bool
&lt; :: Flagged f a -&gt; Flagged f a -&gt; Bool
$c&lt; :: forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Flagged f a -&gt; Flagged f a -&gt; Bool
compare :: Flagged f a -&gt; Flagged f a -&gt; Ordering
$ccompare :: forall k (f :: k -&gt; *) (a :: k).
Ord (f a) =&gt;
Flagged f a -&gt; Flagged f a -&gt; Ordering
$cp1Ord :: forall k (f :: k -&gt; *) (a :: k). Ord (f a) =&gt; Eq (Flagged f a)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679407083"><span id="local-6989586621679407085"><span class="annot"><span class="annottext">a -&gt; Flagged f b -&gt; Flagged f a
(a -&gt; b) -&gt; Flagged f a -&gt; Flagged f b
(forall a b. (a -&gt; b) -&gt; Flagged f a -&gt; Flagged f b)
-&gt; (forall a b. a -&gt; Flagged f b -&gt; Flagged f a)
-&gt; Functor (Flagged f)
forall a b. a -&gt; Flagged f b -&gt; Flagged f a
forall a b. (a -&gt; b) -&gt; Flagged f a -&gt; Flagged f b
forall (f :: * -&gt; *) a b.
Functor f =&gt;
a -&gt; Flagged f b -&gt; Flagged f a
forall (f :: * -&gt; *) a b.
Functor f =&gt;
(a -&gt; b) -&gt; Flagged f a -&gt; Flagged f b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: a -&gt; Flagged f b -&gt; Flagged f a
$c&lt;$ :: forall (f :: * -&gt; *) a b.
Functor f =&gt;
a -&gt; Flagged f b -&gt; Flagged f a
fmap :: (a -&gt; b) -&gt; Flagged f a -&gt; Flagged f b
$cfmap :: forall (f :: * -&gt; *) a b.
Functor f =&gt;
(a -&gt; b) -&gt; Flagged f a -&gt; Flagged f b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679407049"><span id="local-6989586621679407051"><span id="local-6989586621679407053"><span id="local-6989586621679407055"><span id="local-6989586621679407057"><span id="local-6989586621679407059"><span id="local-6989586621679407061"><span id="local-6989586621679407063"><span id="local-6989586621679407065"><span id="local-6989586621679407067"><span id="local-6989586621679407069"><span id="local-6989586621679407071"><span id="local-6989586621679407073"><span id="local-6989586621679407075"><span id="local-6989586621679407077"><span id="local-6989586621679407079"><span id="local-6989586621679407081"><span class="annot"><span class="annottext">Flagged f a -&gt; Bool
(a -&gt; m) -&gt; Flagged f a -&gt; m
(a -&gt; b -&gt; b) -&gt; b -&gt; Flagged f a -&gt; b
(forall m. Monoid m =&gt; Flagged f m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Flagged f a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Flagged f a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Flagged f a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Flagged f a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Flagged f a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Flagged f a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; Flagged f a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; Flagged f a -&gt; a)
-&gt; (forall a. Flagged f a -&gt; [a])
-&gt; (forall a. Flagged f a -&gt; Bool)
-&gt; (forall a. Flagged f a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; Flagged f a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; Flagged f a -&gt; a)
-&gt; (forall a. Ord a =&gt; Flagged f a -&gt; a)
-&gt; (forall a. Num a =&gt; Flagged f a -&gt; a)
-&gt; (forall a. Num a =&gt; Flagged f a -&gt; a)
-&gt; Foldable (Flagged f)
forall a. Eq a =&gt; a -&gt; Flagged f a -&gt; Bool
forall a. Num a =&gt; Flagged f a -&gt; a
forall a. Ord a =&gt; Flagged f a -&gt; a
forall m. Monoid m =&gt; Flagged f m -&gt; m
forall a. Flagged f a -&gt; Bool
forall a. Flagged f a -&gt; Int
forall a. Flagged f a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; Flagged f a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Flagged f a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Flagged f a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Flagged f a -&gt; b
forall (f :: * -&gt; *) a.
(Foldable f, Eq a) =&gt;
a -&gt; Flagged f a -&gt; Bool
forall (f :: * -&gt; *) a. (Foldable f, Num a) =&gt; Flagged f a -&gt; a
forall (f :: * -&gt; *) a. (Foldable f, Ord a) =&gt; Flagged f a -&gt; a
forall (f :: * -&gt; *) m. (Foldable f, Monoid m) =&gt; Flagged f m -&gt; m
forall (f :: * -&gt; *) a. Foldable f =&gt; Flagged f a -&gt; Bool
forall (f :: * -&gt; *) a. Foldable f =&gt; Flagged f a -&gt; Int
forall (f :: * -&gt; *) a. Foldable f =&gt; Flagged f a -&gt; [a]
forall (f :: * -&gt; *) a.
Foldable f =&gt;
(a -&gt; a -&gt; a) -&gt; Flagged f a -&gt; a
forall (f :: * -&gt; *) m a.
(Foldable f, Monoid m) =&gt;
(a -&gt; m) -&gt; Flagged f a -&gt; m
forall (f :: * -&gt; *) b a.
Foldable f =&gt;
(b -&gt; a -&gt; b) -&gt; b -&gt; Flagged f a -&gt; b
forall (f :: * -&gt; *) a b.
Foldable f =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; Flagged f a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: Flagged f a -&gt; a
$cproduct :: forall (f :: * -&gt; *) a. (Foldable f, Num a) =&gt; Flagged f a -&gt; a
sum :: Flagged f a -&gt; a
$csum :: forall (f :: * -&gt; *) a. (Foldable f, Num a) =&gt; Flagged f a -&gt; a
minimum :: Flagged f a -&gt; a
$cminimum :: forall (f :: * -&gt; *) a. (Foldable f, Ord a) =&gt; Flagged f a -&gt; a
maximum :: Flagged f a -&gt; a
$cmaximum :: forall (f :: * -&gt; *) a. (Foldable f, Ord a) =&gt; Flagged f a -&gt; a
elem :: a -&gt; Flagged f a -&gt; Bool
$celem :: forall (f :: * -&gt; *) a.
(Foldable f, Eq a) =&gt;
a -&gt; Flagged f a -&gt; Bool
length :: Flagged f a -&gt; Int
$clength :: forall (f :: * -&gt; *) a. Foldable f =&gt; Flagged f a -&gt; Int
null :: Flagged f a -&gt; Bool
$cnull :: forall (f :: * -&gt; *) a. Foldable f =&gt; Flagged f a -&gt; Bool
toList :: Flagged f a -&gt; [a]
$ctoList :: forall (f :: * -&gt; *) a. Foldable f =&gt; Flagged f a -&gt; [a]
foldl1 :: (a -&gt; a -&gt; a) -&gt; Flagged f a -&gt; a
$cfoldl1 :: forall (f :: * -&gt; *) a.
Foldable f =&gt;
(a -&gt; a -&gt; a) -&gt; Flagged f a -&gt; a
foldr1 :: (a -&gt; a -&gt; a) -&gt; Flagged f a -&gt; a
$cfoldr1 :: forall (f :: * -&gt; *) a.
Foldable f =&gt;
(a -&gt; a -&gt; a) -&gt; Flagged f a -&gt; a
foldl' :: (b -&gt; a -&gt; b) -&gt; b -&gt; Flagged f a -&gt; b
$cfoldl' :: forall (f :: * -&gt; *) b a.
Foldable f =&gt;
(b -&gt; a -&gt; b) -&gt; b -&gt; Flagged f a -&gt; b
foldl :: (b -&gt; a -&gt; b) -&gt; b -&gt; Flagged f a -&gt; b
$cfoldl :: forall (f :: * -&gt; *) b a.
Foldable f =&gt;
(b -&gt; a -&gt; b) -&gt; b -&gt; Flagged f a -&gt; b
foldr' :: (a -&gt; b -&gt; b) -&gt; b -&gt; Flagged f a -&gt; b
$cfoldr' :: forall (f :: * -&gt; *) a b.
Foldable f =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; Flagged f a -&gt; b
foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; Flagged f a -&gt; b
$cfoldr :: forall (f :: * -&gt; *) a b.
Foldable f =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; Flagged f a -&gt; b
foldMap' :: (a -&gt; m) -&gt; Flagged f a -&gt; m
$cfoldMap' :: forall (f :: * -&gt; *) m a.
(Foldable f, Monoid m) =&gt;
(a -&gt; m) -&gt; Flagged f a -&gt; m
foldMap :: (a -&gt; m) -&gt; Flagged f a -&gt; m
$cfoldMap :: forall (f :: * -&gt; *) m a.
(Foldable f, Monoid m) =&gt;
(a -&gt; m) -&gt; Flagged f a -&gt; m
fold :: Flagged f m -&gt; m
$cfold :: forall (f :: * -&gt; *) m. (Foldable f, Monoid m) =&gt; Flagged f m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679407039"><span id="local-6989586621679407041"><span id="local-6989586621679407043"><span id="local-6989586621679407045"><span class="annot"><span class="annottext">Functor (Flagged f)
Foldable (Flagged f)
(Functor (Flagged f), Foldable (Flagged f)) =&gt;
(forall (f :: * -&gt; *) a b.
 Applicative f =&gt;
 (a -&gt; f b) -&gt; Flagged f a -&gt; f (Flagged f b))
-&gt; (forall (f :: * -&gt; *) a.
    Applicative f =&gt;
    Flagged f (f a) -&gt; f (Flagged f a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; Flagged f a -&gt; m (Flagged f b))
-&gt; (forall (m :: * -&gt; *) a.
    Monad m =&gt;
    Flagged f (m a) -&gt; m (Flagged f a))
-&gt; Traversable (Flagged f)
(a -&gt; f b) -&gt; Flagged f a -&gt; f (Flagged f b)
forall (t :: * -&gt; *).
(Functor t, Foldable t) =&gt;
(forall (f :: * -&gt; *) a b.
 Applicative f =&gt;
 (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (f :: * -&gt; *). Traversable f =&gt; Functor (Flagged f)
forall (f :: * -&gt; *). Traversable f =&gt; Foldable (Flagged f)
forall (f :: * -&gt; *) (m :: * -&gt; *) a.
(Traversable f, Monad m) =&gt;
Flagged f (m a) -&gt; m (Flagged f a)
forall (f :: * -&gt; *) (f :: * -&gt; *) a.
(Traversable f, Applicative f) =&gt;
Flagged f (f a) -&gt; f (Flagged f a)
forall (f :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable f, Monad m) =&gt;
(a -&gt; m b) -&gt; Flagged f a -&gt; m (Flagged f b)
forall (f :: * -&gt; *) (f :: * -&gt; *) a b.
(Traversable f, Applicative f) =&gt;
(a -&gt; f b) -&gt; Flagged f a -&gt; f (Flagged f b)
forall (m :: * -&gt; *) a.
Monad m =&gt;
Flagged f (m a) -&gt; m (Flagged f a)
forall (f :: * -&gt; *) a.
Applicative f =&gt;
Flagged f (f a) -&gt; f (Flagged f a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Flagged f a -&gt; m (Flagged f b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Flagged f a -&gt; f (Flagged f b)
sequence :: Flagged f (m a) -&gt; m (Flagged f a)
$csequence :: forall (f :: * -&gt; *) (m :: * -&gt; *) a.
(Traversable f, Monad m) =&gt;
Flagged f (m a) -&gt; m (Flagged f a)
mapM :: (a -&gt; m b) -&gt; Flagged f a -&gt; m (Flagged f b)
$cmapM :: forall (f :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable f, Monad m) =&gt;
(a -&gt; m b) -&gt; Flagged f a -&gt; m (Flagged f b)
sequenceA :: Flagged f (f a) -&gt; f (Flagged f a)
$csequenceA :: forall (f :: * -&gt; *) (f :: * -&gt; *) a.
(Traversable f, Applicative f) =&gt;
Flagged f (f a) -&gt; f (Flagged f a)
traverse :: (a -&gt; f b) -&gt; Flagged f a -&gt; f (Flagged f b)
$ctraverse :: forall (f :: * -&gt; *) (f :: * -&gt; *) a b.
(Traversable f, Applicative f) =&gt;
(a -&gt; f b) -&gt; Flagged f a -&gt; f (Flagged f b)
$cp2Traversable :: forall (f :: * -&gt; *). Traversable f =&gt; Foldable (Flagged f)
$cp1Traversable :: forall (f :: * -&gt; *). Traversable f =&gt; Functor (Flagged f)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">(forall x. Flagged f a -&gt; Rep (Flagged f a) x)
-&gt; (forall x. Rep (Flagged f a) x -&gt; Flagged f a)
-&gt; Generic (Flagged f a)
forall x. Rep (Flagged f a) x -&gt; Flagged f a
forall x. Flagged f a -&gt; Rep (Flagged f a) x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall k (f :: k -&gt; *) (a :: k) x.
Rep (Flagged f a) x -&gt; Flagged f a
forall k (f :: k -&gt; *) (a :: k) x.
Flagged f a -&gt; Rep (Flagged f a) x
$cto :: forall k (f :: k -&gt; *) (a :: k) x.
Rep (Flagged f a) x -&gt; Flagged f a
$cfrom :: forall k (f :: k -&gt; *) (a :: k) x.
Flagged f a -&gt; Rep (Flagged f a) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">,</span><span> </span><span id="%24cFlagged"><span id="%24tFlagged"><span id="local-6989586621679407008"><span id="local-6989586621679407010"><span id="local-6989586621679407012"><span id="local-6989586621679407014"><span id="local-6989586621679407016"><span id="local-6989586621679407018"><span id="local-6989586621679407020"><span id="local-6989586621679407022"><span id="local-6989586621679407024"><span id="local-6989586621679407026"><span id="local-6989586621679407028"><span id="local-6989586621679407030"><span id="local-6989586621679407032"><span id="local-6989586621679407034"><span class="annot"><span class="annottext">Typeable (Flagged f a)
DataType
Constr
Typeable (Flagged f a) =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; Flagged f a -&gt; c (Flagged f a))
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Flagged f a))
-&gt; (Flagged f a -&gt; Constr)
-&gt; (Flagged f a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Flagged f a)))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e))
    -&gt; Maybe (c (Flagged f a)))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; Flagged f a -&gt; Flagged f a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Flagged f a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Flagged f a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Flagged f a -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Flagged f a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Flagged f a -&gt; m (Flagged f a))
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Flagged f a -&gt; m (Flagged f a))
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Flagged f a -&gt; m (Flagged f a))
-&gt; Data (Flagged f a)
Flagged f a -&gt; DataType
Flagged f a -&gt; Constr
(forall b. Data b =&gt; b -&gt; b) -&gt; Flagged f a -&gt; Flagged f a
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Flagged f a -&gt; c (Flagged f a)
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Flagged f a)
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Flagged f a -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Flagged f a -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Flagged f a -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Flagged f a -&gt; r
forall k (f :: k -&gt; *) (a :: k).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
Typeable (Flagged f a)
forall k (f :: k -&gt; *) (a :: k).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
Flagged f a -&gt; DataType
forall k (f :: k -&gt; *) (a :: k).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
Flagged f a -&gt; Constr
forall k (f :: k -&gt; *) (a :: k).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Flagged f a -&gt; Flagged f a
forall k (f :: k -&gt; *) (a :: k) u.
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Flagged f a -&gt; u
forall k (f :: k -&gt; *) (a :: k) u.
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; Flagged f a -&gt; [u]
forall k (f :: k -&gt; *) (a :: k) r r'.
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Flagged f a -&gt; r
forall k (f :: k -&gt; *) (a :: k) r r'.
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Flagged f a -&gt; r
forall k (f :: k -&gt; *) (a :: k) (m :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Flagged f a -&gt; m (Flagged f a)
forall k (f :: k -&gt; *) (a :: k) (m :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Flagged f a -&gt; m (Flagged f a)
forall k (f :: k -&gt; *) (a :: k) (c :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Flagged f a)
forall k (f :: k -&gt; *) (a :: k) (c :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Flagged f a -&gt; c (Flagged f a)
forall k (f :: k -&gt; *) (a :: k) (t :: * -&gt; *) (c :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Flagged f a))
forall k (f :: k -&gt; *) (a :: k) (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Flagged f a))
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Flagged f a -&gt; m (Flagged f a)
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Flagged f a -&gt; m (Flagged f a)
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Flagged f a)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Flagged f a -&gt; c (Flagged f a)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Flagged f a))
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Flagged f a))
$cFlagged :: Constr
$tFlagged :: DataType
gmapMo :: (forall d. Data d =&gt; d -&gt; m d) -&gt; Flagged f a -&gt; m (Flagged f a)
$cgmapMo :: forall k (f :: k -&gt; *) (a :: k) (m :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Flagged f a -&gt; m (Flagged f a)
gmapMp :: (forall d. Data d =&gt; d -&gt; m d) -&gt; Flagged f a -&gt; m (Flagged f a)
$cgmapMp :: forall k (f :: k -&gt; *) (a :: k) (m :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Flagged f a -&gt; m (Flagged f a)
gmapM :: (forall d. Data d =&gt; d -&gt; m d) -&gt; Flagged f a -&gt; m (Flagged f a)
$cgmapM :: forall k (f :: k -&gt; *) (a :: k) (m :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Flagged f a -&gt; m (Flagged f a)
gmapQi :: Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Flagged f a -&gt; u
$cgmapQi :: forall k (f :: k -&gt; *) (a :: k) u.
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Flagged f a -&gt; u
gmapQ :: (forall d. Data d =&gt; d -&gt; u) -&gt; Flagged f a -&gt; [u]
$cgmapQ :: forall k (f :: k -&gt; *) (a :: k) u.
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; Flagged f a -&gt; [u]
gmapQr :: (r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Flagged f a -&gt; r
$cgmapQr :: forall k (f :: k -&gt; *) (a :: k) r r'.
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Flagged f a -&gt; r
gmapQl :: (r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Flagged f a -&gt; r
$cgmapQl :: forall k (f :: k -&gt; *) (a :: k) r r'.
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Flagged f a -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Flagged f a -&gt; Flagged f a
$cgmapT :: forall k (f :: k -&gt; *) (a :: k).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Flagged f a -&gt; Flagged f a
dataCast2 :: (forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Flagged f a))
$cdataCast2 :: forall k (f :: k -&gt; *) (a :: k) (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Flagged f a))
dataCast1 :: (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Flagged f a))
$cdataCast1 :: forall k (f :: k -&gt; *) (a :: k) (t :: * -&gt; *) (c :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a), Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Flagged f a))
dataTypeOf :: Flagged f a -&gt; DataType
$cdataTypeOf :: forall k (f :: k -&gt; *) (a :: k).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
Flagged f a -&gt; DataType
toConstr :: Flagged f a -&gt; Constr
$ctoConstr :: forall k (f :: k -&gt; *) (a :: k).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
Flagged f a -&gt; Constr
gunfold :: (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Flagged f a)
$cgunfold :: forall k (f :: k -&gt; *) (a :: k) (c :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Flagged f a)
gfoldl :: (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Flagged f a -&gt; c (Flagged f a)
$cgfoldl :: forall k (f :: k -&gt; *) (a :: k) (c :: * -&gt; *).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Flagged f a -&gt; c (Flagged f a)
$cp1Data :: forall k (f :: k -&gt; *) (a :: k).
(Typeable a, Typeable f, Typeable k, Data (f a)) =&gt;
Typeable (Flagged f a)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-351"></span><span>
</span><span id="line-352"></span><span id="local-6989586621679407002"><span id="local-6989586621679407004"><span id="local-6989586621679407905"><span class="hs-identifier">deriveShow1</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Flagged</span></span></span></span><span>
</span><span id="line-353"></span><span id="local-6989586621679406994"><span id="local-6989586621679406996"><span id="local-6989586621679406998"><span id="local-6989586621679407000"><span id="local-6989586621679407905"><span class="hs-identifier">deriveRead1</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Flagged</span></span></span></span></span></span><span>
</span><span id="line-354"></span><span id="local-6989586621679406992"><span id="local-6989586621679407905"><span class="hs-identifier">deriveEq1</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Flagged</span></span></span><span>
</span><span id="line-355"></span><span id="local-6989586621679406989"><span id="local-6989586621679407905"><span class="hs-identifier">deriveOrd1</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Flagged</span></span></span><span>
</span><span id="line-356"></span><span>
</span><span id="line-357"></span><span class="hs-comment">-- | Uses 'False' for 'pure', and '||' for '&lt;*&gt;'.</span><span>
</span><span id="line-358"></span><span id="local-6989586621679406988"><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679406979"><span id="local-6989586621679406981"><span id="local-6989586621679406983"><span class="annot"><span class="hs-identifier hs-type">Applicative</span></span><span> </span><span class="annot"><a href="#local-6989586621679406988"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Applicative</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Flagged"><span class="hs-identifier hs-type">Flagged</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679406988"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-359"></span><span>    </span><span id="local-6989586621679406978"><span class="annot"><span class="annottext">pure :: a -&gt; Flagged f a
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">pure</span></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; f a -&gt; Flagged f a
forall k (f :: k -&gt; *) (a :: k). Bool -&gt; f a -&gt; Flagged f a
</span><a href="Control.Applicative.Step.html#Flagged"><span class="hs-identifier hs-var">Flagged</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span> </span><span class="annot"><span class="annottext">(f a -&gt; Flagged f a) -&gt; (a -&gt; f a) -&gt; a -&gt; Flagged f a
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; f a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span>
</span><span id="line-360"></span><span>    </span><span class="annot"><a href="Control.Applicative.Step.html#Flagged"><span class="hs-identifier hs-type">Flagged</span></a></span><span> </span><span id="local-6989586621679406977"><span class="annot"><span class="annottext">n :: Bool
</span><a href="#local-6989586621679406977"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679406976"><span class="annot"><span class="annottext">f :: f (a -&gt; b)
</span><a href="#local-6989586621679406976"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679406975"><span class="annot"><span class="annottext">&lt;*&gt; :: Flagged f (a -&gt; b) -&gt; Flagged f a -&gt; Flagged f b
</span><span class="hs-operator hs-var hs-var hs-var hs-var">&lt;*&gt;</span></span></span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#Flagged"><span class="hs-identifier hs-type">Flagged</span></a></span><span> </span><span id="local-6989586621679406974"><span class="annot"><span class="annottext">m :: Bool
</span><a href="#local-6989586621679406974"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span id="local-6989586621679406973"><span class="annot"><span class="annottext">x :: f a
</span><a href="#local-6989586621679406973"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; f b -&gt; Flagged f b
forall k (f :: k -&gt; *) (a :: k). Bool -&gt; f a -&gt; Flagged f a
</span><a href="Control.Applicative.Step.html#Flagged"><span class="hs-identifier hs-var">Flagged</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679406977"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">||</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679406974"><span class="hs-identifier hs-var">m</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">f (a -&gt; b)
</span><a href="#local-6989586621679406976"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">f (a -&gt; b) -&gt; f a -&gt; f b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">f a
</span><a href="#local-6989586621679406973"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-361"></span><span>
</span><span id="line-362"></span><span class="hs-comment">-- | Uses 'False' for 'point'.</span><span>
</span><span id="line-363"></span><span id="local-6989586621679406971"><span class="hs-keyword">instance</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Pointed</span></span><span> </span><span class="annot"><a href="#local-6989586621679406971"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Pointed</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Flagged"><span class="hs-identifier hs-type">Flagged</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679406971"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-364"></span><span>    </span><span id="local-6989586621679406969"><span class="annot"><span class="annottext">point :: a -&gt; Flagged f a
</span><a href="#local-6989586621679406969"><span class="hs-identifier hs-var hs-var hs-var hs-var">point</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; f a -&gt; Flagged f a
forall k (f :: k -&gt; *) (a :: k). Bool -&gt; f a -&gt; Flagged f a
</span><a href="Control.Applicative.Step.html#Flagged"><span class="hs-identifier hs-var">Flagged</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span> </span><span class="annot"><span class="annottext">(f a -&gt; Flagged f a) -&gt; (a -&gt; f a) -&gt; a -&gt; Flagged f a
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; f a
forall (p :: * -&gt; *) a. Pointed p =&gt; a -&gt; p a
</span><span class="hs-identifier hs-var">point</span></span></span><span>
</span><span id="line-365"></span><span>
</span><span id="line-366"></span><span id="local-6989586621679406968"><span class="hs-keyword">instance</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Foldable1</span></span><span> </span><span class="annot"><a href="#local-6989586621679406968"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Foldable1</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Flagged"><span class="hs-identifier hs-type">Flagged</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679406968"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-367"></span><span>    </span><span id="local-6989586621679406963"><span class="annot"><span class="annottext">fold1 :: Flagged f m -&gt; m
</span><a href="#local-6989586621679406963"><span class="hs-identifier hs-var hs-var hs-var hs-var">fold1</span></a></span></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">f m -&gt; m
forall (t :: * -&gt; *) m. (Foldable1 t, Semigroup m) =&gt; t m -&gt; m
</span><span class="hs-identifier hs-var">fold1</span></span><span> </span><span class="annot"><span class="annottext">(f m -&gt; m) -&gt; (Flagged f m -&gt; f m) -&gt; Flagged f m -&gt; m
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Flagged f m -&gt; f m
forall k (f :: k -&gt; *) (a :: k). Flagged f a -&gt; f a
</span><a href="Control.Applicative.Step.html#flaggedVal"><span class="hs-identifier hs-var hs-var">flaggedVal</span></a></span><span>
</span><span id="line-368"></span><span>    </span><span id="local-6989586621679406962"><span class="annot"><span class="annottext">foldMap1 :: (a -&gt; m) -&gt; Flagged f a -&gt; m
</span><a href="#local-6989586621679406962"><span class="hs-identifier hs-var hs-var hs-var hs-var">foldMap1</span></a></span></span><span> </span><span id="local-6989586621679406961"><span class="annot"><span class="annottext">f :: a -&gt; m
</span><a href="#local-6989586621679406961"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; m) -&gt; f a -&gt; m
forall (t :: * -&gt; *) m a.
(Foldable1 t, Semigroup m) =&gt;
(a -&gt; m) -&gt; t a -&gt; m
</span><span class="hs-identifier hs-var">foldMap1</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; m
</span><a href="#local-6989586621679406961"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">(f a -&gt; m) -&gt; (Flagged f a -&gt; f a) -&gt; Flagged f a -&gt; m
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Flagged f a -&gt; f a
forall k (f :: k -&gt; *) (a :: k). Flagged f a -&gt; f a
</span><a href="Control.Applicative.Step.html#flaggedVal"><span class="hs-identifier hs-var hs-var">flaggedVal</span></a></span><span>
</span><span id="line-369"></span><span>    </span><span id="local-6989586621679406960"><span class="annot"><span class="annottext">toNonEmpty :: Flagged f a -&gt; NonEmpty a
</span><a href="#local-6989586621679406960"><span class="hs-identifier hs-var hs-var hs-var hs-var">toNonEmpty</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">f a -&gt; NonEmpty a
forall (t :: * -&gt; *) a. Foldable1 t =&gt; t a -&gt; NonEmpty a
</span><span class="hs-identifier hs-var">toNonEmpty</span></span><span> </span><span class="annot"><span class="annottext">(f a -&gt; NonEmpty a)
-&gt; (Flagged f a -&gt; f a) -&gt; Flagged f a -&gt; NonEmpty a
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Flagged f a -&gt; f a
forall k (f :: k -&gt; *) (a :: k). Flagged f a -&gt; f a
</span><a href="Control.Applicative.Step.html#flaggedVal"><span class="hs-identifier hs-var hs-var">flaggedVal</span></a></span></span><span>
</span><span id="line-370"></span><span>
</span><span id="line-371"></span><span id="local-6989586621679406959"><span class="hs-keyword">instance</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Traversable1</span></span><span> </span><span class="annot"><a href="#local-6989586621679406959"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Traversable1</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Flagged"><span class="hs-identifier hs-type">Flagged</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679406959"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-372"></span><span>    </span><span id="local-6989586621679406954"><span class="annot"><span class="annottext">traverse1 :: (a -&gt; f b) -&gt; Flagged f a -&gt; f (Flagged f b)
</span><a href="#local-6989586621679406954"><span class="hs-identifier hs-var hs-var hs-var hs-var">traverse1</span></a></span></span><span> </span><span id="local-6989586621679406953"><span class="annot"><span class="annottext">f :: a -&gt; f b
</span><a href="#local-6989586621679406953"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Flagged"><span class="hs-identifier hs-type">Flagged</span></a></span><span> </span><span id="local-6989586621679406952"><span class="annot"><span class="annottext">n :: Bool
</span><a href="#local-6989586621679406952"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679406951"><span class="annot"><span class="annottext">x :: f a
</span><a href="#local-6989586621679406951"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; f b -&gt; Flagged f b
forall k (f :: k -&gt; *) (a :: k). Bool -&gt; f a -&gt; Flagged f a
</span><a href="Control.Applicative.Step.html#Flagged"><span class="hs-identifier hs-var">Flagged</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679406952"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">(f b -&gt; Flagged f b) -&gt; f (f b) -&gt; f (Flagged f b)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">(a -&gt; f b) -&gt; f a -&gt; f (f b)
forall (t :: * -&gt; *) (f :: * -&gt; *) a b.
(Traversable1 t, Apply f) =&gt;
(a -&gt; f b) -&gt; t a -&gt; f (t b)
</span><span class="hs-identifier hs-var">traverse1</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; f b
</span><a href="#local-6989586621679406953"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">f a
</span><a href="#local-6989586621679406951"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-373"></span><span>    </span><span id="local-6989586621679406950"><span class="annot"><span class="annottext">sequence1 :: Flagged f (f b) -&gt; f (Flagged f b)
</span><a href="#local-6989586621679406950"><span class="hs-identifier hs-var hs-var hs-var hs-var">sequence1</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Flagged"><span class="hs-identifier hs-type">Flagged</span></a></span><span> </span><span id="local-6989586621679406949"><span class="annot"><span class="annottext">n :: Bool
</span><a href="#local-6989586621679406949"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679406948"><span class="annot"><span class="annottext">x :: f (f b)
</span><a href="#local-6989586621679406948"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; f b -&gt; Flagged f b
forall k (f :: k -&gt; *) (a :: k). Bool -&gt; f a -&gt; Flagged f a
</span><a href="Control.Applicative.Step.html#Flagged"><span class="hs-identifier hs-var">Flagged</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679406949"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">(f b -&gt; Flagged f b) -&gt; f (f b) -&gt; f (Flagged f b)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">f (f b) -&gt; f (f b)
forall (t :: * -&gt; *) (f :: * -&gt; *) b.
(Traversable1 t, Apply f) =&gt;
t (f b) -&gt; f (t b)
</span><span class="hs-identifier hs-var">sequence1</span></span><span> </span><span class="annot"><span class="annottext">f (f b)
</span><a href="#local-6989586621679406948"><span class="hs-identifier hs-var">x</span></a></span></span><span>
</span><span id="line-374"></span><span>
</span><span id="line-375"></span><span>
</span><span id="line-376"></span><span>
</span><span id="line-377"></span><span>
</span><span id="line-378"></span><span>
</span><span id="line-379"></span><span class="hs-comment">-- | @'Void2' a b@ is uninhabited for all @a@ and @b@.</span><span>
</span><span id="line-380"></span><span id="local-6989586621679406946"><span id="local-6989586621679406947"></span></span><span class="hs-keyword">data</span><span> </span><span id="Void2"><span class="annot"><a href="Control.Applicative.Step.html#Void2"><span class="hs-identifier hs-var">Void2</span></a></span></span><span> </span><span id="local-6989586621679406945"><span class="annot"><a href="#local-6989586621679406945"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span id="local-6989586621679406944"><span class="annot"><a href="#local-6989586621679406944"><span class="hs-identifier hs-type">b</span></a></span></span><span>
</span><span id="line-381"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679406938"><span id="local-6989586621679406940"><span id="local-6989586621679406942"><span class="annot"><span class="annottext">Int -&gt; Void2 a b -&gt; ShowS
[Void2 a b] -&gt; ShowS
Void2 a b -&gt; String
(Int -&gt; Void2 a b -&gt; ShowS)
-&gt; (Void2 a b -&gt; String)
-&gt; ([Void2 a b] -&gt; ShowS)
-&gt; Show (Void2 a b)
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
forall k (a :: k) k (b :: k). Int -&gt; Void2 a b -&gt; ShowS
forall k (a :: k) k (b :: k). [Void2 a b] -&gt; ShowS
forall k (a :: k) k (b :: k). Void2 a b -&gt; String
showList :: [Void2 a b] -&gt; ShowS
$cshowList :: forall k (a :: k) k (b :: k). [Void2 a b] -&gt; ShowS
show :: Void2 a b -&gt; String
$cshow :: forall k (a :: k) k (b :: k). Void2 a b -&gt; String
showsPrec :: Int -&gt; Void2 a b -&gt; ShowS
$cshowsPrec :: forall k (a :: k) k (b :: k). Int -&gt; Void2 a b -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679406930"><span id="local-6989586621679406932"><span id="local-6989586621679406934"><span id="local-6989586621679406936"><span class="annot"><span class="annottext">ReadPrec [Void2 a b]
ReadPrec (Void2 a b)
Int -&gt; ReadS (Void2 a b)
ReadS [Void2 a b]
(Int -&gt; ReadS (Void2 a b))
-&gt; ReadS [Void2 a b]
-&gt; ReadPrec (Void2 a b)
-&gt; ReadPrec [Void2 a b]
-&gt; Read (Void2 a b)
forall a.
(Int -&gt; ReadS a)
-&gt; ReadS [a] -&gt; ReadPrec a -&gt; ReadPrec [a] -&gt; Read a
forall k (a :: k) k (b :: k). ReadPrec [Void2 a b]
forall k (a :: k) k (b :: k). ReadPrec (Void2 a b)
forall k (a :: k) k (b :: k). Int -&gt; ReadS (Void2 a b)
forall k (a :: k) k (b :: k). ReadS [Void2 a b]
readListPrec :: ReadPrec [Void2 a b]
$creadListPrec :: forall k (a :: k) k (b :: k). ReadPrec [Void2 a b]
readPrec :: ReadPrec (Void2 a b)
$creadPrec :: forall k (a :: k) k (b :: k). ReadPrec (Void2 a b)
readList :: ReadS [Void2 a b]
$creadList :: forall k (a :: k) k (b :: k). ReadS [Void2 a b]
readsPrec :: Int -&gt; ReadS (Void2 a b)
$creadsPrec :: forall k (a :: k) k (b :: k). Int -&gt; ReadS (Void2 a b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Read</span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679406926"><span id="local-6989586621679406928"><span class="annot"><span class="annottext">Void2 a b -&gt; Void2 a b -&gt; Bool
(Void2 a b -&gt; Void2 a b -&gt; Bool)
-&gt; (Void2 a b -&gt; Void2 a b -&gt; Bool) -&gt; Eq (Void2 a b)
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
forall k (a :: k) k (b :: k). Void2 a b -&gt; Void2 a b -&gt; Bool
/= :: Void2 a b -&gt; Void2 a b -&gt; Bool
$c/= :: forall k (a :: k) k (b :: k). Void2 a b -&gt; Void2 a b -&gt; Bool
== :: Void2 a b -&gt; Void2 a b -&gt; Bool
$c== :: forall k (a :: k) k (b :: k). Void2 a b -&gt; Void2 a b -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679406911"><span id="local-6989586621679406913"><span id="local-6989586621679406915"><span id="local-6989586621679406917"><span id="local-6989586621679406919"><span id="local-6989586621679406921"><span id="local-6989586621679406923"><span class="annot"><span class="annottext">Eq (Void2 a b)
Eq (Void2 a b) =&gt;
(Void2 a b -&gt; Void2 a b -&gt; Ordering)
-&gt; (Void2 a b -&gt; Void2 a b -&gt; Bool)
-&gt; (Void2 a b -&gt; Void2 a b -&gt; Bool)
-&gt; (Void2 a b -&gt; Void2 a b -&gt; Bool)
-&gt; (Void2 a b -&gt; Void2 a b -&gt; Bool)
-&gt; (Void2 a b -&gt; Void2 a b -&gt; Void2 a b)
-&gt; (Void2 a b -&gt; Void2 a b -&gt; Void2 a b)
-&gt; Ord (Void2 a b)
Void2 a b -&gt; Void2 a b -&gt; Bool
Void2 a b -&gt; Void2 a b -&gt; Ordering
Void2 a b -&gt; Void2 a b -&gt; Void2 a b
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall k (a :: k) k (b :: k). Eq (Void2 a b)
forall k (a :: k) k (b :: k). Void2 a b -&gt; Void2 a b -&gt; Bool
forall k (a :: k) k (b :: k). Void2 a b -&gt; Void2 a b -&gt; Ordering
forall k (a :: k) k (b :: k). Void2 a b -&gt; Void2 a b -&gt; Void2 a b
min :: Void2 a b -&gt; Void2 a b -&gt; Void2 a b
$cmin :: forall k (a :: k) k (b :: k). Void2 a b -&gt; Void2 a b -&gt; Void2 a b
max :: Void2 a b -&gt; Void2 a b -&gt; Void2 a b
$cmax :: forall k (a :: k) k (b :: k). Void2 a b -&gt; Void2 a b -&gt; Void2 a b
&gt;= :: Void2 a b -&gt; Void2 a b -&gt; Bool
$c&gt;= :: forall k (a :: k) k (b :: k). Void2 a b -&gt; Void2 a b -&gt; Bool
&gt; :: Void2 a b -&gt; Void2 a b -&gt; Bool
$c&gt; :: forall k (a :: k) k (b :: k). Void2 a b -&gt; Void2 a b -&gt; Bool
&lt;= :: Void2 a b -&gt; Void2 a b -&gt; Bool
$c&lt;= :: forall k (a :: k) k (b :: k). Void2 a b -&gt; Void2 a b -&gt; Bool
&lt; :: Void2 a b -&gt; Void2 a b -&gt; Bool
$c&lt; :: forall k (a :: k) k (b :: k). Void2 a b -&gt; Void2 a b -&gt; Bool
compare :: Void2 a b -&gt; Void2 a b -&gt; Ordering
$ccompare :: forall k (a :: k) k (b :: k). Void2 a b -&gt; Void2 a b -&gt; Ordering
$cp1Ord :: forall k (a :: k) k (b :: k). Eq (Void2 a b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679406907"><span id="local-6989586621679406909"><span class="annot"><span class="annottext">(a -&gt; b) -&gt; Void2 a a -&gt; Void2 a b
(forall a b. (a -&gt; b) -&gt; Void2 a a -&gt; Void2 a b)
-&gt; (forall a b. a -&gt; Void2 a b -&gt; Void2 a a) -&gt; Functor (Void2 a)
forall k (a :: k) a b. a -&gt; Void2 a b -&gt; Void2 a a
forall k (a :: k) a b. (a -&gt; b) -&gt; Void2 a a -&gt; Void2 a b
forall a b. a -&gt; Void2 a b -&gt; Void2 a a
forall a b. (a -&gt; b) -&gt; Void2 a a -&gt; Void2 a b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: a -&gt; Void2 a b -&gt; Void2 a a
$c&lt;$ :: forall k (a :: k) a b. a -&gt; Void2 a b -&gt; Void2 a a
fmap :: (a -&gt; b) -&gt; Void2 a a -&gt; Void2 a b
$cfmap :: forall k (a :: k) a b. (a -&gt; b) -&gt; Void2 a a -&gt; Void2 a b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679406873"><span id="local-6989586621679406875"><span id="local-6989586621679406877"><span id="local-6989586621679406879"><span id="local-6989586621679406881"><span id="local-6989586621679406883"><span id="local-6989586621679406885"><span id="local-6989586621679406887"><span id="local-6989586621679406889"><span id="local-6989586621679406891"><span id="local-6989586621679406893"><span id="local-6989586621679406895"><span id="local-6989586621679406897"><span id="local-6989586621679406899"><span id="local-6989586621679406901"><span id="local-6989586621679406903"><span id="local-6989586621679406905"><span class="annot"><span class="annottext">(a -&gt; m) -&gt; Void2 a a -&gt; m
(forall m. Monoid m =&gt; Void2 a m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Void2 a a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Void2 a a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Void2 a a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Void2 a a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Void2 a a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Void2 a a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; Void2 a a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; Void2 a a -&gt; a)
-&gt; (forall a. Void2 a a -&gt; [a])
-&gt; (forall a. Void2 a a -&gt; Bool)
-&gt; (forall a. Void2 a a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; Void2 a a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; Void2 a a -&gt; a)
-&gt; (forall a. Ord a =&gt; Void2 a a -&gt; a)
-&gt; (forall a. Num a =&gt; Void2 a a -&gt; a)
-&gt; (forall a. Num a =&gt; Void2 a a -&gt; a)
-&gt; Foldable (Void2 a)
forall a. Eq a =&gt; a -&gt; Void2 a a -&gt; Bool
forall a. Num a =&gt; Void2 a a -&gt; a
forall a. Ord a =&gt; Void2 a a -&gt; a
forall m. Monoid m =&gt; Void2 a m -&gt; m
forall a. Void2 a a -&gt; Bool
forall a. Void2 a a -&gt; Int
forall a. Void2 a a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; Void2 a a -&gt; a
forall k (a :: k) a. Eq a =&gt; a -&gt; Void2 a a -&gt; Bool
forall k (a :: k) a. Num a =&gt; Void2 a a -&gt; a
forall k (a :: k) a. Ord a =&gt; Void2 a a -&gt; a
forall k (a :: k) m. Monoid m =&gt; Void2 a m -&gt; m
forall k (a :: k) a. Void2 a a -&gt; Bool
forall k (a :: k) a. Void2 a a -&gt; Int
forall k (a :: k) a. Void2 a a -&gt; [a]
forall k (a :: k) a. (a -&gt; a -&gt; a) -&gt; Void2 a a -&gt; a
forall k (a :: k) m a. Monoid m =&gt; (a -&gt; m) -&gt; Void2 a a -&gt; m
forall k (a :: k) b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Void2 a a -&gt; b
forall k (a :: k) a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Void2 a a -&gt; b
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Void2 a a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Void2 a a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Void2 a a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: Void2 a a -&gt; a
$cproduct :: forall k (a :: k) a. Num a =&gt; Void2 a a -&gt; a
sum :: Void2 a a -&gt; a
$csum :: forall k (a :: k) a. Num a =&gt; Void2 a a -&gt; a
minimum :: Void2 a a -&gt; a
$cminimum :: forall k (a :: k) a. Ord a =&gt; Void2 a a -&gt; a
maximum :: Void2 a a -&gt; a
$cmaximum :: forall k (a :: k) a. Ord a =&gt; Void2 a a -&gt; a
elem :: a -&gt; Void2 a a -&gt; Bool
$celem :: forall k (a :: k) a. Eq a =&gt; a -&gt; Void2 a a -&gt; Bool
length :: Void2 a a -&gt; Int
$clength :: forall k (a :: k) a. Void2 a a -&gt; Int
null :: Void2 a a -&gt; Bool
$cnull :: forall k (a :: k) a. Void2 a a -&gt; Bool
toList :: Void2 a a -&gt; [a]
$ctoList :: forall k (a :: k) a. Void2 a a -&gt; [a]
foldl1 :: (a -&gt; a -&gt; a) -&gt; Void2 a a -&gt; a
$cfoldl1 :: forall k (a :: k) a. (a -&gt; a -&gt; a) -&gt; Void2 a a -&gt; a
foldr1 :: (a -&gt; a -&gt; a) -&gt; Void2 a a -&gt; a
$cfoldr1 :: forall k (a :: k) a. (a -&gt; a -&gt; a) -&gt; Void2 a a -&gt; a
foldl' :: (b -&gt; a -&gt; b) -&gt; b -&gt; Void2 a a -&gt; b
$cfoldl' :: forall k (a :: k) b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Void2 a a -&gt; b
foldl :: (b -&gt; a -&gt; b) -&gt; b -&gt; Void2 a a -&gt; b
$cfoldl :: forall k (a :: k) b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Void2 a a -&gt; b
foldr' :: (a -&gt; b -&gt; b) -&gt; b -&gt; Void2 a a -&gt; b
$cfoldr' :: forall k (a :: k) a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Void2 a a -&gt; b
foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; Void2 a a -&gt; b
$cfoldr :: forall k (a :: k) a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Void2 a a -&gt; b
foldMap' :: (a -&gt; m) -&gt; Void2 a a -&gt; m
$cfoldMap' :: forall k (a :: k) m a. Monoid m =&gt; (a -&gt; m) -&gt; Void2 a a -&gt; m
foldMap :: (a -&gt; m) -&gt; Void2 a a -&gt; m
$cfoldMap :: forall k (a :: k) m a. Monoid m =&gt; (a -&gt; m) -&gt; Void2 a a -&gt; m
fold :: Void2 a m -&gt; m
$cfold :: forall k (a :: k) m. Monoid m =&gt; Void2 a m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679406863"><span id="local-6989586621679406865"><span id="local-6989586621679406867"><span id="local-6989586621679406869"><span class="annot"><span class="annottext">Functor (Void2 a)
Foldable (Void2 a)
(Functor (Void2 a), Foldable (Void2 a)) =&gt;
(forall (f :: * -&gt; *) a b.
 Applicative f =&gt;
 (a -&gt; f b) -&gt; Void2 a a -&gt; f (Void2 a b))
-&gt; (forall (f :: * -&gt; *) a.
    Applicative f =&gt;
    Void2 a (f a) -&gt; f (Void2 a a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; Void2 a a -&gt; m (Void2 a b))
-&gt; (forall (m :: * -&gt; *) a.
    Monad m =&gt;
    Void2 a (m a) -&gt; m (Void2 a a))
-&gt; Traversable (Void2 a)
(a -&gt; f b) -&gt; Void2 a a -&gt; f (Void2 a b)
forall k (a :: k). Functor (Void2 a)
forall k (a :: k). Foldable (Void2 a)
forall k (a :: k) (m :: * -&gt; *) a.
Monad m =&gt;
Void2 a (m a) -&gt; m (Void2 a a)
forall k (a :: k) (f :: * -&gt; *) a.
Applicative f =&gt;
Void2 a (f a) -&gt; f (Void2 a a)
forall k (a :: k) (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Void2 a a -&gt; m (Void2 a b)
forall k (a :: k) (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Void2 a a -&gt; f (Void2 a b)
forall (t :: * -&gt; *).
(Functor t, Foldable t) =&gt;
(forall (f :: * -&gt; *) a b.
 Applicative f =&gt;
 (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a. Monad m =&gt; Void2 a (m a) -&gt; m (Void2 a a)
forall (f :: * -&gt; *) a.
Applicative f =&gt;
Void2 a (f a) -&gt; f (Void2 a a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Void2 a a -&gt; m (Void2 a b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Void2 a a -&gt; f (Void2 a b)
sequence :: Void2 a (m a) -&gt; m (Void2 a a)
$csequence :: forall k (a :: k) (m :: * -&gt; *) a.
Monad m =&gt;
Void2 a (m a) -&gt; m (Void2 a a)
mapM :: (a -&gt; m b) -&gt; Void2 a a -&gt; m (Void2 a b)
$cmapM :: forall k (a :: k) (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Void2 a a -&gt; m (Void2 a b)
sequenceA :: Void2 a (f a) -&gt; f (Void2 a a)
$csequenceA :: forall k (a :: k) (f :: * -&gt; *) a.
Applicative f =&gt;
Void2 a (f a) -&gt; f (Void2 a a)
traverse :: (a -&gt; f b) -&gt; Void2 a a -&gt; f (Void2 a b)
$ctraverse :: forall k (a :: k) (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Void2 a a -&gt; f (Void2 a b)
$cp2Traversable :: forall k (a :: k). Foldable (Void2 a)
$cp1Traversable :: forall k (a :: k). Functor (Void2 a)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">(forall x. Void2 a b -&gt; Rep (Void2 a b) x)
-&gt; (forall x. Rep (Void2 a b) x -&gt; Void2 a b)
-&gt; Generic (Void2 a b)
forall x. Rep (Void2 a b) x -&gt; Void2 a b
forall x. Void2 a b -&gt; Rep (Void2 a b) x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall k (a :: k) k (b :: k) x. Rep (Void2 a b) x -&gt; Void2 a b
forall k (a :: k) k (b :: k) x. Void2 a b -&gt; Rep (Void2 a b) x
$cto :: forall k (a :: k) k (b :: k) x. Rep (Void2 a b) x -&gt; Void2 a b
$cfrom :: forall k (a :: k) k (b :: k) x. Void2 a b -&gt; Rep (Void2 a b) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">,</span><span> </span><span id="%24tVoid2"><span id="local-6989586621679406832"><span id="local-6989586621679406834"><span id="local-6989586621679406836"><span id="local-6989586621679406838"><span id="local-6989586621679406840"><span id="local-6989586621679406842"><span id="local-6989586621679406844"><span id="local-6989586621679406846"><span id="local-6989586621679406848"><span id="local-6989586621679406850"><span id="local-6989586621679406852"><span id="local-6989586621679406854"><span id="local-6989586621679406856"><span id="local-6989586621679406858"><span class="annot"><span class="annottext">Typeable (Void2 a b)
DataType
Typeable (Void2 a b) =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; Void2 a b -&gt; c (Void2 a b))
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Void2 a b))
-&gt; (Void2 a b -&gt; Constr)
-&gt; (Void2 a b -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Void2 a b)))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e))
    -&gt; Maybe (c (Void2 a b)))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; Void2 a b -&gt; Void2 a b)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Void2 a b -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Void2 a b -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Void2 a b -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Void2 a b -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Void2 a b -&gt; m (Void2 a b))
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Void2 a b -&gt; m (Void2 a b))
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Void2 a b -&gt; m (Void2 a b))
-&gt; Data (Void2 a b)
Void2 a b -&gt; DataType
Void2 a b -&gt; Constr
(forall b. Data b =&gt; b -&gt; b) -&gt; Void2 a b -&gt; Void2 a b
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Void2 a b -&gt; c (Void2 a b)
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Void2 a b)
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Void2 a b -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Void2 a b -&gt; [u]
forall k (a :: k) k (b :: k).
(Typeable a, Typeable b, Typeable k, Typeable k) =&gt;
Typeable (Void2 a b)
forall k (a :: k) k (b :: k).
(Typeable a, Typeable b, Typeable k, Typeable k) =&gt;
Void2 a b -&gt; DataType
forall k (a :: k) k (b :: k).
(Typeable a, Typeable b, Typeable k, Typeable k) =&gt;
Void2 a b -&gt; Constr
forall k (a :: k) k (b :: k).
(Typeable a, Typeable b, Typeable k, Typeable k) =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Void2 a b -&gt; Void2 a b
forall k (a :: k) k (b :: k) u.
(Typeable a, Typeable b, Typeable k, Typeable k) =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Void2 a b -&gt; u
forall k (a :: k) k (b :: k) u.
(Typeable a, Typeable b, Typeable k, Typeable k) =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; Void2 a b -&gt; [u]
forall k (a :: k) k (b :: k) r r'.
(Typeable a, Typeable b, Typeable k, Typeable k) =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Void2 a b -&gt; r
forall k (a :: k) k (b :: k) r r'.
(Typeable a, Typeable b, Typeable k, Typeable k) =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Void2 a b -&gt; r
forall k (a :: k) k (b :: k) (m :: * -&gt; *).
(Typeable a, Typeable b, Typeable k, Typeable k, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Void2 a b -&gt; m (Void2 a b)
forall k (a :: k) k (b :: k) (m :: * -&gt; *).
(Typeable a, Typeable b, Typeable k, Typeable k, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Void2 a b -&gt; m (Void2 a b)
forall k (a :: k) k (b :: k) (c :: * -&gt; *).
(Typeable a, Typeable b, Typeable k, Typeable k) =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Void2 a b)
forall k (a :: k) k (b :: k) (c :: * -&gt; *).
(Typeable a, Typeable b, Typeable k, Typeable k) =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Void2 a b -&gt; c (Void2 a b)
forall k (a :: k) k (b :: k) (t :: * -&gt; *) (c :: * -&gt; *).
(Typeable a, Typeable b, Typeable k, Typeable k, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Void2 a b))
forall k (a :: k) k (b :: k) (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Typeable a, Typeable b, Typeable k, Typeable k, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Void2 a b))
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Void2 a b -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Void2 a b -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Void2 a b -&gt; m (Void2 a b)
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Void2 a b -&gt; m (Void2 a b)
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Void2 a b)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Void2 a b -&gt; c (Void2 a b)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Void2 a b))
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Void2 a b))
$tVoid2 :: DataType
gmapMo :: (forall d. Data d =&gt; d -&gt; m d) -&gt; Void2 a b -&gt; m (Void2 a b)
$cgmapMo :: forall k (a :: k) k (b :: k) (m :: * -&gt; *).
(Typeable a, Typeable b, Typeable k, Typeable k, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Void2 a b -&gt; m (Void2 a b)
gmapMp :: (forall d. Data d =&gt; d -&gt; m d) -&gt; Void2 a b -&gt; m (Void2 a b)
$cgmapMp :: forall k (a :: k) k (b :: k) (m :: * -&gt; *).
(Typeable a, Typeable b, Typeable k, Typeable k, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Void2 a b -&gt; m (Void2 a b)
gmapM :: (forall d. Data d =&gt; d -&gt; m d) -&gt; Void2 a b -&gt; m (Void2 a b)
$cgmapM :: forall k (a :: k) k (b :: k) (m :: * -&gt; *).
(Typeable a, Typeable b, Typeable k, Typeable k, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Void2 a b -&gt; m (Void2 a b)
gmapQi :: Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Void2 a b -&gt; u
$cgmapQi :: forall k (a :: k) k (b :: k) u.
(Typeable a, Typeable b, Typeable k, Typeable k) =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Void2 a b -&gt; u
gmapQ :: (forall d. Data d =&gt; d -&gt; u) -&gt; Void2 a b -&gt; [u]
$cgmapQ :: forall k (a :: k) k (b :: k) u.
(Typeable a, Typeable b, Typeable k, Typeable k) =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; Void2 a b -&gt; [u]
gmapQr :: (r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Void2 a b -&gt; r
$cgmapQr :: forall k (a :: k) k (b :: k) r r'.
(Typeable a, Typeable b, Typeable k, Typeable k) =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Void2 a b -&gt; r
gmapQl :: (r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Void2 a b -&gt; r
$cgmapQl :: forall k (a :: k) k (b :: k) r r'.
(Typeable a, Typeable b, Typeable k, Typeable k) =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Void2 a b -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Void2 a b -&gt; Void2 a b
$cgmapT :: forall k (a :: k) k (b :: k).
(Typeable a, Typeable b, Typeable k, Typeable k) =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Void2 a b -&gt; Void2 a b
dataCast2 :: (forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Void2 a b))
$cdataCast2 :: forall k (a :: k) k (b :: k) (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Typeable a, Typeable b, Typeable k, Typeable k, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Void2 a b))
dataCast1 :: (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Void2 a b))
$cdataCast1 :: forall k (a :: k) k (b :: k) (t :: * -&gt; *) (c :: * -&gt; *).
(Typeable a, Typeable b, Typeable k, Typeable k, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Void2 a b))
dataTypeOf :: Void2 a b -&gt; DataType
$cdataTypeOf :: forall k (a :: k) k (b :: k).
(Typeable a, Typeable b, Typeable k, Typeable k) =&gt;
Void2 a b -&gt; DataType
toConstr :: Void2 a b -&gt; Constr
$ctoConstr :: forall k (a :: k) k (b :: k).
(Typeable a, Typeable b, Typeable k, Typeable k) =&gt;
Void2 a b -&gt; Constr
gunfold :: (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Void2 a b)
$cgunfold :: forall k (a :: k) k (b :: k) (c :: * -&gt; *).
(Typeable a, Typeable b, Typeable k, Typeable k) =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Void2 a b)
gfoldl :: (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Void2 a b -&gt; c (Void2 a b)
$cgfoldl :: forall k (a :: k) k (b :: k) (c :: * -&gt; *).
(Typeable a, Typeable b, Typeable k, Typeable k) =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Void2 a b -&gt; c (Void2 a b)
$cp1Data :: forall k (a :: k) k (b :: k).
(Typeable a, Typeable b, Typeable k, Typeable k) =&gt;
Typeable (Void2 a b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-382"></span><span>
</span><span id="line-383"></span><span id="local-6989586621679406827"><span id="local-6989586621679406829"><span id="local-6989586621679406945"><span class="hs-identifier">deriveShow1</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Void2</span></span></span></span><span>
</span><span id="line-384"></span><span id="local-6989586621679406819"><span id="local-6989586621679406821"><span id="local-6989586621679406823"><span id="local-6989586621679406825"><span id="local-6989586621679406945"><span class="hs-identifier">deriveRead1</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Void2</span></span></span></span></span></span><span>
</span><span id="line-385"></span><span id="local-6989586621679406817"><span id="local-6989586621679406945"><span class="hs-identifier">deriveEq1</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Void2</span></span></span><span>
</span><span id="line-386"></span><span id="local-6989586621679406814"><span id="local-6989586621679406945"><span class="hs-identifier">deriveOrd1</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Void2</span></span></span><span>
</span><span id="line-387"></span><span>
</span><span id="line-388"></span><span id="local-6989586621679406812"><span id="local-6989586621679406813"><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679406807"><span id="local-6989586621679406809"><span class="annot"><span class="hs-identifier hs-type">Semigroup</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Void2"><span class="hs-identifier hs-type">Void2</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679406813"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679406812"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-389"></span><span>    </span><span id="local-6989586621679406806"><span class="annot"><span class="annottext">x :: Void2 a b
</span><a href="#local-6989586621679406806"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679406805"><span class="annot"><span class="annottext">&lt;&gt; :: Void2 a b -&gt; Void2 a b -&gt; Void2 a b
</span><span class="hs-operator hs-var hs-var hs-var hs-var">&lt;&gt;</span></span></span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Void2 a b
</span><a href="#local-6989586621679406806"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span></span></span><span>
</span><span id="line-390"></span><span>
</span><span id="line-391"></span><span id="local-6989586621679406804"><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679406798"><span id="local-6989586621679406800"><span class="annot"><span class="hs-identifier hs-type">Alt</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Void2"><span class="hs-identifier hs-type">Void2</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679406804"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-392"></span><span>    </span><span id="local-6989586621679406797"><span class="annot"><span class="annottext">x :: Void2 a a
</span><a href="#local-6989586621679406797"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679406796"><span class="annot"><span class="annottext">&lt;!&gt; :: Void2 a a -&gt; Void2 a a -&gt; Void2 a a
</span><a href="#local-6989586621679406796"><span class="hs-operator hs-var hs-var hs-var hs-var">&lt;!&gt;</span></a></span></span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Void2 a a -&gt; Void2 a a
forall k k (f :: k) (a :: k) (t :: k -&gt; k -&gt; *). Void2 f a -&gt; t f a
</span><a href="Control.Applicative.Step.html#absurd2"><span class="hs-identifier hs-var">absurd2</span></a></span><span> </span><span class="annot"><span class="annottext">Void2 a a
</span><a href="#local-6989586621679406797"><span class="hs-identifier hs-var">x</span></a></span></span><span>
</span><span id="line-393"></span><span>
</span><span id="line-394"></span><span id="local-6989586621679406795"><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679406791"><span class="annot"><span class="hs-identifier hs-type">Bind</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Void2"><span class="hs-identifier hs-type">Void2</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679406795"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-395"></span><span>    </span><span id="local-6989586621679406789"><span class="annot"><span class="annottext">x :: Void2 a a
</span><a href="#local-6989586621679406789"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679406788"><span class="annot"><span class="annottext">&gt;&gt;- :: Void2 a a -&gt; (a -&gt; Void2 a b) -&gt; Void2 a b
</span><span class="hs-operator hs-var hs-var hs-var hs-var">&gt;&gt;-</span></span></span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Void2 a a
</span><a href="#local-6989586621679406789"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span></span><span>
</span><span id="line-396"></span><span>
</span><span id="line-397"></span><span id="local-6989586621679406786"><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679406778"><span id="local-6989586621679406780"><span id="local-6989586621679406782"><span class="annot"><span class="hs-identifier hs-type">Apply</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Void2"><span class="hs-identifier hs-type">Void2</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679406786"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-398"></span><span>    </span><span id="local-6989586621679406776"><span class="annot"><span class="annottext">x :: Void2 a (a -&gt; b)
</span><a href="#local-6989586621679406776"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679406775"><span class="annot"><span class="annottext">&lt;.&gt; :: Void2 a (a -&gt; b) -&gt; Void2 a a -&gt; Void2 a b
</span><span class="hs-operator hs-var hs-var hs-var hs-var">&lt;.&gt;</span></span></span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Void2 a (a -&gt; b)
</span><a href="#local-6989586621679406776"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span></span><span>
</span><span id="line-399"></span><span>
</span><span id="line-400"></span><span class="hs-comment">-- | If you treat a @'Void2' f a@ as a functor combinator, then 'absurd2'</span><span>
</span><span id="line-401"></span><span class="hs-comment">-- lets you convert from a @'Void2' f a@ into a @t f a@ for any functor</span><span>
</span><span id="line-402"></span><span class="hs-comment">-- combinator @t@.</span><span>
</span><span id="line-403"></span><span id="local-6989586621679407771"><span id="local-6989586621679407772"><span id="local-6989586621679407773"><span class="annot"><a href="Control.Applicative.Step.html#absurd2"><span class="hs-identifier hs-type">absurd2</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#Void2"><span class="hs-identifier hs-type">Void2</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679407773"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679407772"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679407771"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679407773"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679407772"><span class="hs-identifier hs-type">a</span></a></span></span></span></span><span>
</span><span id="line-404"></span><span id="absurd2"><span class="annot"><span class="annottext">absurd2 :: Void2 f a -&gt; t f a
</span><a href="Control.Applicative.Step.html#absurd2"><span class="hs-identifier hs-var hs-var">absurd2</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span>
</span><span id="line-405"></span><span>
</span><span id="line-406"></span><span class="hs-comment">-- | @'Void3' a b@ is uninhabited for all @a@ and @b@.</span><span>
</span><span id="line-407"></span><span id="local-6989586621679406772"><span id="local-6989586621679406773"></span></span><span class="hs-keyword">data</span><span> </span><span id="Void3"><span class="annot"><a href="Control.Applicative.Step.html#Void3"><span class="hs-identifier hs-var">Void3</span></a></span></span><span> </span><span id="local-6989586621679406771"><span class="annot"><a href="#local-6989586621679406771"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span id="local-6989586621679406770"><span class="annot"><a href="#local-6989586621679406770"><span class="hs-identifier hs-type">b</span></a></span></span><span> </span><span id="local-6989586621679406769"><span class="annot"><a href="#local-6989586621679406769"><span class="hs-identifier hs-type">c</span></a></span></span><span>
</span><span id="line-408"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679406763"><span id="local-6989586621679406765"><span id="local-6989586621679406767"><span class="annot"><span class="annottext">Int -&gt; Void3 a b c -&gt; ShowS
[Void3 a b c] -&gt; ShowS
Void3 a b c -&gt; String
(Int -&gt; Void3 a b c -&gt; ShowS)
-&gt; (Void3 a b c -&gt; String)
-&gt; ([Void3 a b c] -&gt; ShowS)
-&gt; Show (Void3 a b c)
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
forall k (a :: k) k (b :: k) k (c :: k).
Int -&gt; Void3 a b c -&gt; ShowS
forall k (a :: k) k (b :: k) k (c :: k). [Void3 a b c] -&gt; ShowS
forall k (a :: k) k (b :: k) k (c :: k). Void3 a b c -&gt; String
showList :: [Void3 a b c] -&gt; ShowS
$cshowList :: forall k (a :: k) k (b :: k) k (c :: k). [Void3 a b c] -&gt; ShowS
show :: Void3 a b c -&gt; String
$cshow :: forall k (a :: k) k (b :: k) k (c :: k). Void3 a b c -&gt; String
showsPrec :: Int -&gt; Void3 a b c -&gt; ShowS
$cshowsPrec :: forall k (a :: k) k (b :: k) k (c :: k).
Int -&gt; Void3 a b c -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679406755"><span id="local-6989586621679406757"><span id="local-6989586621679406759"><span id="local-6989586621679406761"><span class="annot"><span class="annottext">ReadPrec [Void3 a b c]
ReadPrec (Void3 a b c)
Int -&gt; ReadS (Void3 a b c)
ReadS [Void3 a b c]
(Int -&gt; ReadS (Void3 a b c))
-&gt; ReadS [Void3 a b c]
-&gt; ReadPrec (Void3 a b c)
-&gt; ReadPrec [Void3 a b c]
-&gt; Read (Void3 a b c)
forall a.
(Int -&gt; ReadS a)
-&gt; ReadS [a] -&gt; ReadPrec a -&gt; ReadPrec [a] -&gt; Read a
forall k (a :: k) k (b :: k) k (c :: k). ReadPrec [Void3 a b c]
forall k (a :: k) k (b :: k) k (c :: k). ReadPrec (Void3 a b c)
forall k (a :: k) k (b :: k) k (c :: k). Int -&gt; ReadS (Void3 a b c)
forall k (a :: k) k (b :: k) k (c :: k). ReadS [Void3 a b c]
readListPrec :: ReadPrec [Void3 a b c]
$creadListPrec :: forall k (a :: k) k (b :: k) k (c :: k). ReadPrec [Void3 a b c]
readPrec :: ReadPrec (Void3 a b c)
$creadPrec :: forall k (a :: k) k (b :: k) k (c :: k). ReadPrec (Void3 a b c)
readList :: ReadS [Void3 a b c]
$creadList :: forall k (a :: k) k (b :: k) k (c :: k). ReadS [Void3 a b c]
readsPrec :: Int -&gt; ReadS (Void3 a b c)
$creadsPrec :: forall k (a :: k) k (b :: k) k (c :: k). Int -&gt; ReadS (Void3 a b c)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Read</span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679406751"><span id="local-6989586621679406753"><span class="annot"><span class="annottext">Void3 a b c -&gt; Void3 a b c -&gt; Bool
(Void3 a b c -&gt; Void3 a b c -&gt; Bool)
-&gt; (Void3 a b c -&gt; Void3 a b c -&gt; Bool) -&gt; Eq (Void3 a b c)
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
forall k (a :: k) k (b :: k) k (c :: k).
Void3 a b c -&gt; Void3 a b c -&gt; Bool
/= :: Void3 a b c -&gt; Void3 a b c -&gt; Bool
$c/= :: forall k (a :: k) k (b :: k) k (c :: k).
Void3 a b c -&gt; Void3 a b c -&gt; Bool
== :: Void3 a b c -&gt; Void3 a b c -&gt; Bool
$c== :: forall k (a :: k) k (b :: k) k (c :: k).
Void3 a b c -&gt; Void3 a b c -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679406736"><span id="local-6989586621679406738"><span id="local-6989586621679406740"><span id="local-6989586621679406742"><span id="local-6989586621679406744"><span id="local-6989586621679406746"><span id="local-6989586621679406748"><span class="annot"><span class="annottext">Eq (Void3 a b c)
Eq (Void3 a b c) =&gt;
(Void3 a b c -&gt; Void3 a b c -&gt; Ordering)
-&gt; (Void3 a b c -&gt; Void3 a b c -&gt; Bool)
-&gt; (Void3 a b c -&gt; Void3 a b c -&gt; Bool)
-&gt; (Void3 a b c -&gt; Void3 a b c -&gt; Bool)
-&gt; (Void3 a b c -&gt; Void3 a b c -&gt; Bool)
-&gt; (Void3 a b c -&gt; Void3 a b c -&gt; Void3 a b c)
-&gt; (Void3 a b c -&gt; Void3 a b c -&gt; Void3 a b c)
-&gt; Ord (Void3 a b c)
Void3 a b c -&gt; Void3 a b c -&gt; Bool
Void3 a b c -&gt; Void3 a b c -&gt; Ordering
Void3 a b c -&gt; Void3 a b c -&gt; Void3 a b c
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall k (a :: k) k (b :: k) k (c :: k). Eq (Void3 a b c)
forall k (a :: k) k (b :: k) k (c :: k).
Void3 a b c -&gt; Void3 a b c -&gt; Bool
forall k (a :: k) k (b :: k) k (c :: k).
Void3 a b c -&gt; Void3 a b c -&gt; Ordering
forall k (a :: k) k (b :: k) k (c :: k).
Void3 a b c -&gt; Void3 a b c -&gt; Void3 a b c
min :: Void3 a b c -&gt; Void3 a b c -&gt; Void3 a b c
$cmin :: forall k (a :: k) k (b :: k) k (c :: k).
Void3 a b c -&gt; Void3 a b c -&gt; Void3 a b c
max :: Void3 a b c -&gt; Void3 a b c -&gt; Void3 a b c
$cmax :: forall k (a :: k) k (b :: k) k (c :: k).
Void3 a b c -&gt; Void3 a b c -&gt; Void3 a b c
&gt;= :: Void3 a b c -&gt; Void3 a b c -&gt; Bool
$c&gt;= :: forall k (a :: k) k (b :: k) k (c :: k).
Void3 a b c -&gt; Void3 a b c -&gt; Bool
&gt; :: Void3 a b c -&gt; Void3 a b c -&gt; Bool
$c&gt; :: forall k (a :: k) k (b :: k) k (c :: k).
Void3 a b c -&gt; Void3 a b c -&gt; Bool
&lt;= :: Void3 a b c -&gt; Void3 a b c -&gt; Bool
$c&lt;= :: forall k (a :: k) k (b :: k) k (c :: k).
Void3 a b c -&gt; Void3 a b c -&gt; Bool
&lt; :: Void3 a b c -&gt; Void3 a b c -&gt; Bool
$c&lt; :: forall k (a :: k) k (b :: k) k (c :: k).
Void3 a b c -&gt; Void3 a b c -&gt; Bool
compare :: Void3 a b c -&gt; Void3 a b c -&gt; Ordering
$ccompare :: forall k (a :: k) k (b :: k) k (c :: k).
Void3 a b c -&gt; Void3 a b c -&gt; Ordering
$cp1Ord :: forall k (a :: k) k (b :: k) k (c :: k). Eq (Void3 a b c)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679406732"><span id="local-6989586621679406734"><span class="annot"><span class="annottext">(a -&gt; b) -&gt; Void3 a b a -&gt; Void3 a b b
(forall a b. (a -&gt; b) -&gt; Void3 a b a -&gt; Void3 a b b)
-&gt; (forall a b. a -&gt; Void3 a b b -&gt; Void3 a b a)
-&gt; Functor (Void3 a b)
forall k (a :: k) k (b :: k) a b. a -&gt; Void3 a b b -&gt; Void3 a b a
forall k (a :: k) k (b :: k) a b.
(a -&gt; b) -&gt; Void3 a b a -&gt; Void3 a b b
forall a b. a -&gt; Void3 a b b -&gt; Void3 a b a
forall a b. (a -&gt; b) -&gt; Void3 a b a -&gt; Void3 a b b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: a -&gt; Void3 a b b -&gt; Void3 a b a
$c&lt;$ :: forall k (a :: k) k (b :: k) a b. a -&gt; Void3 a b b -&gt; Void3 a b a
fmap :: (a -&gt; b) -&gt; Void3 a b a -&gt; Void3 a b b
$cfmap :: forall k (a :: k) k (b :: k) a b.
(a -&gt; b) -&gt; Void3 a b a -&gt; Void3 a b b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679406698"><span id="local-6989586621679406700"><span id="local-6989586621679406702"><span id="local-6989586621679406704"><span id="local-6989586621679406706"><span id="local-6989586621679406708"><span id="local-6989586621679406710"><span id="local-6989586621679406712"><span id="local-6989586621679406714"><span id="local-6989586621679406716"><span id="local-6989586621679406718"><span id="local-6989586621679406720"><span id="local-6989586621679406722"><span id="local-6989586621679406724"><span id="local-6989586621679406726"><span id="local-6989586621679406728"><span id="local-6989586621679406730"><span class="annot"><span class="annottext">(a -&gt; m) -&gt; Void3 a b a -&gt; m
(forall m. Monoid m =&gt; Void3 a b m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Void3 a b a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Void3 a b a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Void3 a b a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Void3 a b a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Void3 a b a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Void3 a b a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; Void3 a b a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; Void3 a b a -&gt; a)
-&gt; (forall a. Void3 a b a -&gt; [a])
-&gt; (forall a. Void3 a b a -&gt; Bool)
-&gt; (forall a. Void3 a b a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; Void3 a b a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; Void3 a b a -&gt; a)
-&gt; (forall a. Ord a =&gt; Void3 a b a -&gt; a)
-&gt; (forall a. Num a =&gt; Void3 a b a -&gt; a)
-&gt; (forall a. Num a =&gt; Void3 a b a -&gt; a)
-&gt; Foldable (Void3 a b)
forall a. Eq a =&gt; a -&gt; Void3 a b a -&gt; Bool
forall a. Num a =&gt; Void3 a b a -&gt; a
forall a. Ord a =&gt; Void3 a b a -&gt; a
forall m. Monoid m =&gt; Void3 a b m -&gt; m
forall a. Void3 a b a -&gt; Bool
forall a. Void3 a b a -&gt; Int
forall a. Void3 a b a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; Void3 a b a -&gt; a
forall k (a :: k) k (b :: k) a. Eq a =&gt; a -&gt; Void3 a b a -&gt; Bool
forall k (a :: k) k (b :: k) a. Num a =&gt; Void3 a b a -&gt; a
forall k (a :: k) k (b :: k) a. Ord a =&gt; Void3 a b a -&gt; a
forall k (a :: k) k (b :: k) m. Monoid m =&gt; Void3 a b m -&gt; m
forall k (a :: k) k (b :: k) a. Void3 a b a -&gt; Bool
forall k (a :: k) k (b :: k) a. Void3 a b a -&gt; Int
forall k (a :: k) k (b :: k) a. Void3 a b a -&gt; [a]
forall k (a :: k) k (b :: k) a. (a -&gt; a -&gt; a) -&gt; Void3 a b a -&gt; a
forall k (a :: k) k (b :: k) m a.
Monoid m =&gt;
(a -&gt; m) -&gt; Void3 a b a -&gt; m
forall k (a :: k) k (b :: k) b a.
(b -&gt; a -&gt; b) -&gt; b -&gt; Void3 a b a -&gt; b
forall k (a :: k) k (b :: k) a b.
(a -&gt; b -&gt; b) -&gt; b -&gt; Void3 a b a -&gt; b
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Void3 a b a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Void3 a b a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Void3 a b a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: Void3 a b a -&gt; a
$cproduct :: forall k (a :: k) k (b :: k) a. Num a =&gt; Void3 a b a -&gt; a
sum :: Void3 a b a -&gt; a
$csum :: forall k (a :: k) k (b :: k) a. Num a =&gt; Void3 a b a -&gt; a
minimum :: Void3 a b a -&gt; a
$cminimum :: forall k (a :: k) k (b :: k) a. Ord a =&gt; Void3 a b a -&gt; a
maximum :: Void3 a b a -&gt; a
$cmaximum :: forall k (a :: k) k (b :: k) a. Ord a =&gt; Void3 a b a -&gt; a
elem :: a -&gt; Void3 a b a -&gt; Bool
$celem :: forall k (a :: k) k (b :: k) a. Eq a =&gt; a -&gt; Void3 a b a -&gt; Bool
length :: Void3 a b a -&gt; Int
$clength :: forall k (a :: k) k (b :: k) a. Void3 a b a -&gt; Int
null :: Void3 a b a -&gt; Bool
$cnull :: forall k (a :: k) k (b :: k) a. Void3 a b a -&gt; Bool
toList :: Void3 a b a -&gt; [a]
$ctoList :: forall k (a :: k) k (b :: k) a. Void3 a b a -&gt; [a]
foldl1 :: (a -&gt; a -&gt; a) -&gt; Void3 a b a -&gt; a
$cfoldl1 :: forall k (a :: k) k (b :: k) a. (a -&gt; a -&gt; a) -&gt; Void3 a b a -&gt; a
foldr1 :: (a -&gt; a -&gt; a) -&gt; Void3 a b a -&gt; a
$cfoldr1 :: forall k (a :: k) k (b :: k) a. (a -&gt; a -&gt; a) -&gt; Void3 a b a -&gt; a
foldl' :: (b -&gt; a -&gt; b) -&gt; b -&gt; Void3 a b a -&gt; b
$cfoldl' :: forall k (a :: k) k (b :: k) b a.
(b -&gt; a -&gt; b) -&gt; b -&gt; Void3 a b a -&gt; b
foldl :: (b -&gt; a -&gt; b) -&gt; b -&gt; Void3 a b a -&gt; b
$cfoldl :: forall k (a :: k) k (b :: k) b a.
(b -&gt; a -&gt; b) -&gt; b -&gt; Void3 a b a -&gt; b
foldr' :: (a -&gt; b -&gt; b) -&gt; b -&gt; Void3 a b a -&gt; b
$cfoldr' :: forall k (a :: k) k (b :: k) a b.
(a -&gt; b -&gt; b) -&gt; b -&gt; Void3 a b a -&gt; b
foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; Void3 a b a -&gt; b
$cfoldr :: forall k (a :: k) k (b :: k) a b.
(a -&gt; b -&gt; b) -&gt; b -&gt; Void3 a b a -&gt; b
foldMap' :: (a -&gt; m) -&gt; Void3 a b a -&gt; m
$cfoldMap' :: forall k (a :: k) k (b :: k) m a.
Monoid m =&gt;
(a -&gt; m) -&gt; Void3 a b a -&gt; m
foldMap :: (a -&gt; m) -&gt; Void3 a b a -&gt; m
$cfoldMap :: forall k (a :: k) k (b :: k) m a.
Monoid m =&gt;
(a -&gt; m) -&gt; Void3 a b a -&gt; m
fold :: Void3 a b m -&gt; m
$cfold :: forall k (a :: k) k (b :: k) m. Monoid m =&gt; Void3 a b m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679406688"><span id="local-6989586621679406690"><span id="local-6989586621679406692"><span id="local-6989586621679406694"><span class="annot"><span class="annottext">Functor (Void3 a b)
Foldable (Void3 a b)
(Functor (Void3 a b), Foldable (Void3 a b)) =&gt;
(forall (f :: * -&gt; *) a b.
 Applicative f =&gt;
 (a -&gt; f b) -&gt; Void3 a b a -&gt; f (Void3 a b b))
-&gt; (forall (f :: * -&gt; *) a.
    Applicative f =&gt;
    Void3 a b (f a) -&gt; f (Void3 a b a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; Void3 a b a -&gt; m (Void3 a b b))
-&gt; (forall (m :: * -&gt; *) a.
    Monad m =&gt;
    Void3 a b (m a) -&gt; m (Void3 a b a))
-&gt; Traversable (Void3 a b)
(a -&gt; f b) -&gt; Void3 a b a -&gt; f (Void3 a b b)
forall k (a :: k) k (b :: k). Functor (Void3 a b)
forall k (a :: k) k (b :: k). Foldable (Void3 a b)
forall k (a :: k) k (b :: k) (m :: * -&gt; *) a.
Monad m =&gt;
Void3 a b (m a) -&gt; m (Void3 a b a)
forall k (a :: k) k (b :: k) (f :: * -&gt; *) a.
Applicative f =&gt;
Void3 a b (f a) -&gt; f (Void3 a b a)
forall k (a :: k) k (b :: k) (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Void3 a b a -&gt; m (Void3 a b b)
forall k (a :: k) k (b :: k) (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Void3 a b a -&gt; f (Void3 a b b)
forall (t :: * -&gt; *).
(Functor t, Foldable t) =&gt;
(forall (f :: * -&gt; *) a b.
 Applicative f =&gt;
 (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a.
Monad m =&gt;
Void3 a b (m a) -&gt; m (Void3 a b a)
forall (f :: * -&gt; *) a.
Applicative f =&gt;
Void3 a b (f a) -&gt; f (Void3 a b a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Void3 a b a -&gt; m (Void3 a b b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Void3 a b a -&gt; f (Void3 a b b)
sequence :: Void3 a b (m a) -&gt; m (Void3 a b a)
$csequence :: forall k (a :: k) k (b :: k) (m :: * -&gt; *) a.
Monad m =&gt;
Void3 a b (m a) -&gt; m (Void3 a b a)
mapM :: (a -&gt; m b) -&gt; Void3 a b a -&gt; m (Void3 a b b)
$cmapM :: forall k (a :: k) k (b :: k) (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Void3 a b a -&gt; m (Void3 a b b)
sequenceA :: Void3 a b (f a) -&gt; f (Void3 a b a)
$csequenceA :: forall k (a :: k) k (b :: k) (f :: * -&gt; *) a.
Applicative f =&gt;
Void3 a b (f a) -&gt; f (Void3 a b a)
traverse :: (a -&gt; f b) -&gt; Void3 a b a -&gt; f (Void3 a b b)
$ctraverse :: forall k (a :: k) k (b :: k) (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Void3 a b a -&gt; f (Void3 a b b)
$cp2Traversable :: forall k (a :: k) k (b :: k). Foldable (Void3 a b)
$cp1Traversable :: forall k (a :: k) k (b :: k). Functor (Void3 a b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">(forall x. Void3 a b c -&gt; Rep (Void3 a b c) x)
-&gt; (forall x. Rep (Void3 a b c) x -&gt; Void3 a b c)
-&gt; Generic (Void3 a b c)
forall x. Rep (Void3 a b c) x -&gt; Void3 a b c
forall x. Void3 a b c -&gt; Rep (Void3 a b c) x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall k (a :: k) k (b :: k) k (c :: k) x.
Rep (Void3 a b c) x -&gt; Void3 a b c
forall k (a :: k) k (b :: k) k (c :: k) x.
Void3 a b c -&gt; Rep (Void3 a b c) x
$cto :: forall k (a :: k) k (b :: k) k (c :: k) x.
Rep (Void3 a b c) x -&gt; Void3 a b c
$cfrom :: forall k (a :: k) k (b :: k) k (c :: k) x.
Void3 a b c -&gt; Rep (Void3 a b c) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">,</span><span> </span><span id="%24tVoid3"><span id="local-6989586621679406657"><span id="local-6989586621679406659"><span id="local-6989586621679406661"><span id="local-6989586621679406663"><span id="local-6989586621679406665"><span id="local-6989586621679406667"><span id="local-6989586621679406669"><span id="local-6989586621679406671"><span id="local-6989586621679406673"><span id="local-6989586621679406675"><span id="local-6989586621679406677"><span id="local-6989586621679406679"><span id="local-6989586621679406681"><span id="local-6989586621679406683"><span class="annot"><span class="annottext">Typeable (Void3 a b c)
DataType
Typeable (Void3 a b c) =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; Void3 a b c -&gt; c (Void3 a b c))
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Void3 a b c))
-&gt; (Void3 a b c -&gt; Constr)
-&gt; (Void3 a b c -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Void3 a b c)))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e))
    -&gt; Maybe (c (Void3 a b c)))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; Void3 a b c -&gt; Void3 a b c)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Void3 a b c -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Void3 a b c -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Void3 a b c -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Void3 a b c -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Void3 a b c -&gt; m (Void3 a b c))
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Void3 a b c -&gt; m (Void3 a b c))
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Void3 a b c -&gt; m (Void3 a b c))
-&gt; Data (Void3 a b c)
Void3 a b c -&gt; DataType
Void3 a b c -&gt; Constr
(forall b. Data b =&gt; b -&gt; b) -&gt; Void3 a b c -&gt; Void3 a b c
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Void3 a b c -&gt; c (Void3 a b c)
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Void3 a b c)
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Void3 a b c -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Void3 a b c -&gt; [u]
forall k (a :: k) k (b :: k) k (c :: k).
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k) =&gt;
Typeable (Void3 a b c)
forall k (a :: k) k (b :: k) k (c :: k).
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k) =&gt;
Void3 a b c -&gt; DataType
forall k (a :: k) k (b :: k) k (c :: k).
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k) =&gt;
Void3 a b c -&gt; Constr
forall k (a :: k) k (b :: k) k (c :: k).
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k) =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Void3 a b c -&gt; Void3 a b c
forall k (a :: k) k (b :: k) k (c :: k) u.
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k) =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Void3 a b c -&gt; u
forall k (a :: k) k (b :: k) k (c :: k) u.
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k) =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; Void3 a b c -&gt; [u]
forall k (a :: k) k (b :: k) k (c :: k) r r'.
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k) =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Void3 a b c -&gt; r
forall k (a :: k) k (b :: k) k (c :: k) r r'.
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k) =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Void3 a b c -&gt; r
forall k (a :: k) k (b :: k) k (c :: k) (m :: * -&gt; *).
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Void3 a b c -&gt; m (Void3 a b c)
forall k (a :: k) k (b :: k) k (c :: k) (m :: * -&gt; *).
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Void3 a b c -&gt; m (Void3 a b c)
forall k (a :: k) k (b :: k) k (c :: k) (c :: * -&gt; *).
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k) =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Void3 a b c)
forall k (a :: k) k (b :: k) k (c :: k) (c :: * -&gt; *).
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k) =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Void3 a b c -&gt; c (Void3 a b c)
forall k (a :: k) k (b :: k) k (c :: k) (t :: * -&gt; *)
       (c :: * -&gt; *).
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Void3 a b c))
forall k (a :: k) k (b :: k) k (c :: k) (t :: * -&gt; * -&gt; *)
       (c :: * -&gt; *).
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Void3 a b c))
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Void3 a b c -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Void3 a b c -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Void3 a b c -&gt; m (Void3 a b c)
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Void3 a b c -&gt; m (Void3 a b c)
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Void3 a b c)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Void3 a b c -&gt; c (Void3 a b c)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Void3 a b c))
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Void3 a b c))
$tVoid3 :: DataType
gmapMo :: (forall d. Data d =&gt; d -&gt; m d) -&gt; Void3 a b c -&gt; m (Void3 a b c)
$cgmapMo :: forall k (a :: k) k (b :: k) k (c :: k) (m :: * -&gt; *).
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Void3 a b c -&gt; m (Void3 a b c)
gmapMp :: (forall d. Data d =&gt; d -&gt; m d) -&gt; Void3 a b c -&gt; m (Void3 a b c)
$cgmapMp :: forall k (a :: k) k (b :: k) k (c :: k) (m :: * -&gt; *).
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Void3 a b c -&gt; m (Void3 a b c)
gmapM :: (forall d. Data d =&gt; d -&gt; m d) -&gt; Void3 a b c -&gt; m (Void3 a b c)
$cgmapM :: forall k (a :: k) k (b :: k) k (c :: k) (m :: * -&gt; *).
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Void3 a b c -&gt; m (Void3 a b c)
gmapQi :: Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Void3 a b c -&gt; u
$cgmapQi :: forall k (a :: k) k (b :: k) k (c :: k) u.
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k) =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Void3 a b c -&gt; u
gmapQ :: (forall d. Data d =&gt; d -&gt; u) -&gt; Void3 a b c -&gt; [u]
$cgmapQ :: forall k (a :: k) k (b :: k) k (c :: k) u.
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k) =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; Void3 a b c -&gt; [u]
gmapQr :: (r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Void3 a b c -&gt; r
$cgmapQr :: forall k (a :: k) k (b :: k) k (c :: k) r r'.
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k) =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Void3 a b c -&gt; r
gmapQl :: (r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Void3 a b c -&gt; r
$cgmapQl :: forall k (a :: k) k (b :: k) k (c :: k) r r'.
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k) =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Void3 a b c -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Void3 a b c -&gt; Void3 a b c
$cgmapT :: forall k (a :: k) k (b :: k) k (c :: k).
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k) =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Void3 a b c -&gt; Void3 a b c
dataCast2 :: (forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Void3 a b c))
$cdataCast2 :: forall k (a :: k) k (b :: k) k (c :: k) (t :: * -&gt; * -&gt; *)
       (c :: * -&gt; *).
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Void3 a b c))
dataCast1 :: (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Void3 a b c))
$cdataCast1 :: forall k (a :: k) k (b :: k) k (c :: k) (t :: * -&gt; *)
       (c :: * -&gt; *).
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Void3 a b c))
dataTypeOf :: Void3 a b c -&gt; DataType
$cdataTypeOf :: forall k (a :: k) k (b :: k) k (c :: k).
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k) =&gt;
Void3 a b c -&gt; DataType
toConstr :: Void3 a b c -&gt; Constr
$ctoConstr :: forall k (a :: k) k (b :: k) k (c :: k).
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k) =&gt;
Void3 a b c -&gt; Constr
gunfold :: (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Void3 a b c)
$cgunfold :: forall k (a :: k) k (b :: k) k (c :: k) (c :: * -&gt; *).
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k) =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Void3 a b c)
gfoldl :: (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Void3 a b c -&gt; c (Void3 a b c)
$cgfoldl :: forall k (a :: k) k (b :: k) k (c :: k) (c :: * -&gt; *).
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k) =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Void3 a b c -&gt; c (Void3 a b c)
$cp1Data :: forall k (a :: k) k (b :: k) k (c :: k).
(Typeable a, Typeable b, Typeable c, Typeable k, Typeable k,
 Typeable k) =&gt;
Typeable (Void3 a b c)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-409"></span><span>
</span><span id="line-410"></span><span id="local-6989586621679406652"><span id="local-6989586621679406654"><span id="local-6989586621679406770"><span id="local-6989586621679406771"><span class="hs-identifier">deriveShow1</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Void3</span></span></span></span></span><span>
</span><span id="line-411"></span><span id="local-6989586621679406644"><span id="local-6989586621679406646"><span id="local-6989586621679406648"><span id="local-6989586621679406650"><span id="local-6989586621679406770"><span id="local-6989586621679406771"><span class="hs-identifier">deriveRead1</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Void3</span></span></span></span></span></span></span><span>
</span><span id="line-412"></span><span id="local-6989586621679406642"><span id="local-6989586621679406770"><span id="local-6989586621679406771"><span class="hs-identifier">deriveEq1</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Void3</span></span></span></span><span>
</span><span id="line-413"></span><span id="local-6989586621679406639"><span id="local-6989586621679406770"><span id="local-6989586621679406771"><span class="hs-identifier">deriveOrd1</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Void3</span></span></span></span><span>
</span><span id="line-414"></span><span>
</span><span id="line-415"></span><span id="local-6989586621679406636"><span id="local-6989586621679406637"><span id="local-6989586621679406638"><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679406631"><span id="local-6989586621679406633"><span class="annot"><span class="hs-identifier hs-type">Semigroup</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Void3"><span class="hs-identifier hs-type">Void3</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679406638"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679406637"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679406636"><span class="hs-identifier hs-type">c</span></a></span><span class="hs-special">)</span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-416"></span><span>    </span><span id="local-6989586621679406630"><span class="annot"><span class="annottext">x :: Void3 a b c
</span><a href="#local-6989586621679406630"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679406629"><span class="annot"><span class="annottext">&lt;&gt; :: Void3 a b c -&gt; Void3 a b c -&gt; Void3 a b c
</span><span class="hs-operator hs-var hs-var hs-var hs-var">&lt;&gt;</span></span></span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Void3 a b c
</span><a href="#local-6989586621679406630"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span></span></span></span><span>
</span><span id="line-417"></span><span>
</span><span id="line-418"></span><span id="local-6989586621679406627"><span id="local-6989586621679406628"><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679406621"><span id="local-6989586621679406623"><span class="annot"><span class="hs-identifier hs-type">Alt</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Void3"><span class="hs-identifier hs-type">Void3</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679406628"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679406627"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-419"></span><span>    </span><span id="local-6989586621679406620"><span class="annot"><span class="annottext">x :: Void3 a b a
</span><a href="#local-6989586621679406620"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679406619"><span class="annot"><span class="annottext">&lt;!&gt; :: Void3 a b a -&gt; Void3 a b a -&gt; Void3 a b a
</span><a href="#local-6989586621679406619"><span class="hs-operator hs-var hs-var hs-var hs-var">&lt;!&gt;</span></a></span></span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Void3 a b a -&gt; Void3 a b a
forall k k k (f :: k) (g :: k) (a :: k) (t :: k -&gt; k -&gt; k -&gt; *).
Void3 f g a -&gt; t f g a
</span><a href="Control.Applicative.Step.html#absurd3"><span class="hs-identifier hs-var">absurd3</span></a></span><span> </span><span class="annot"><span class="annottext">Void3 a b a
</span><a href="#local-6989586621679406620"><span class="hs-identifier hs-var">x</span></a></span></span></span><span>
</span><span id="line-420"></span><span>
</span><span id="line-421"></span><span id="local-6989586621679406617"><span id="local-6989586621679406618"><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679406613"><span class="annot"><span class="hs-identifier hs-type">Bind</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Void3"><span class="hs-identifier hs-type">Void3</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679406618"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679406617"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-422"></span><span>    </span><span id="local-6989586621679406612"><span class="annot"><span class="annottext">x :: Void3 a b a
</span><a href="#local-6989586621679406612"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679406611"><span class="annot"><span class="annottext">&gt;&gt;- :: Void3 a b a -&gt; (a -&gt; Void3 a b b) -&gt; Void3 a b b
</span><a href="#local-6989586621679406611"><span class="hs-operator hs-var hs-var hs-var hs-var">&gt;&gt;-</span></a></span></span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Void3 a b a
</span><a href="#local-6989586621679406612"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span></span></span><span>
</span><span id="line-423"></span><span>
</span><span id="line-424"></span><span id="local-6989586621679406609"><span id="local-6989586621679406610"><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679406601"><span id="local-6989586621679406603"><span id="local-6989586621679406605"><span class="annot"><span class="hs-identifier hs-type">Apply</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.Step.html#Void3"><span class="hs-identifier hs-type">Void3</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679406610"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679406609"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-425"></span><span>    </span><span id="local-6989586621679406600"><span class="annot"><span class="annottext">x :: Void3 a b (a -&gt; b)
</span><a href="#local-6989586621679406600"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679406599"><span class="annot"><span class="annottext">&lt;.&gt; :: Void3 a b (a -&gt; b) -&gt; Void3 a b a -&gt; Void3 a b b
</span><a href="#local-6989586621679406599"><span class="hs-operator hs-var hs-var hs-var hs-var">&lt;.&gt;</span></a></span></span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Void3 a b (a -&gt; b)
</span><a href="#local-6989586621679406600"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span></span></span><span>
</span><span id="line-426"></span><span>
</span><span id="line-427"></span><span class="hs-comment">-- | If you treat a @'Void3' f a@ as a binary functor combinator, then</span><span>
</span><span id="line-428"></span><span class="hs-comment">-- 'absurd3' lets you convert from a @'Void3' f a@ into a @t f a@ for any</span><span>
</span><span id="line-429"></span><span class="hs-comment">-- functor combinator @t@.</span><span>
</span><span id="line-430"></span><span id="local-6989586621679407585"><span id="local-6989586621679407586"><span id="local-6989586621679407587"><span id="local-6989586621679407588"><span class="annot"><a href="Control.Applicative.Step.html#absurd3"><span class="hs-identifier hs-type">absurd3</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Control.Applicative.Step.html#Void3"><span class="hs-identifier hs-type">Void3</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679407588"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679407587"><span class="hs-identifier hs-type">g</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679407586"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679407585"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679407588"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679407587"><span class="hs-identifier hs-type">g</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679407586"><span class="hs-identifier hs-type">a</span></a></span></span></span></span></span><span>
</span><span id="line-431"></span><span id="absurd3"><span class="annot"><span class="annottext">absurd3 :: Void3 f g a -&gt; t f g a
</span><a href="Control.Applicative.Step.html#absurd3"><span class="hs-identifier hs-var hs-var">absurd3</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span>
</span><span id="line-432"></span></pre></body></html>