-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/mstksg/functor-combinators#readme</a>
@package functor-combinators
@version 0.1.0.0


-- | This module provides functor combinators that are wrappers over lists
--   or maybes of <tt>f a</tt>s, especially for their <a>Interpret</a>
--   instances.
--   
--   Each one transforms a functor into some product of itself. For
--   example, <tt><a>NonEmptyF</a> f</tt> represents <tt>f <a>:*:</a>
--   f</tt>, or <tt>f :*: f :*: f</tt>, or <tt>f :*: f :*: f :*: f</tt>,
--   etc.
module Control.Applicative.ListF

-- | A list of <tt>f a</tt>s. Can be used to describe a product of many
--   different values of type <tt>f a</tt>.
--   
--   This is the Free <a>Plus</a>.
newtype ListF f a
ListF :: [f a] -> ListF f a
[runListF] :: ListF f a -> [f a]

-- | Map a function over the inside of a <a>ListF</a>.
mapListF :: ([f a] -> [g b]) -> ListF f a -> ListF g b

-- | A non-empty list of <tt>f a</tt>s. Can be used to describe a product
--   between many different possible values of type <tt>f a</tt>.
--   
--   Essentially:
--   
--   <pre>
--   <a>NonEmptyF</a> f
--       ~ f                          -- one f
--     <a>:+:</a> (f <a>:*:</a> f)              -- two f's
--     :+: (f :*: f :*: f)            -- three f's
--     :+: (f :*: f :*: f :*: f)      -- four f's
--     :+: ...                        -- etc.
--   </pre>
--   
--   This is the Free <a>Plus</a>.
newtype NonEmptyF f a
NonEmptyF :: NonEmpty (f a) -> NonEmptyF f a
[runNonEmptyF] :: NonEmptyF f a -> NonEmpty (f a)

-- | Map a function over the inside of a <a>NonEmptyF</a>.
mapNonEmptyF :: (NonEmpty (f a) -> NonEmpty (g b)) -> NonEmptyF f a -> NonEmptyF g b

-- | Convert a <a>NonEmptyF</a> into a <a>ListF</a> with at least one item.
toListF :: NonEmptyF f ~> ListF f

-- | Convert a <a>ListF</a> either a <a>NonEmptyF</a>, or a <a>Proxy</a> in
--   the case that the list was empty.
fromListF :: ListF f ~> (Proxy :+: NonEmptyF f)

-- | Treat a <tt><a>NonEmptyF</a> f</tt> as a product between an <tt>f</tt>
--   and a <tt><a>ListF</a> f</tt>.
--   
--   <a>nonEmptyProd</a> is the record accessor.
pattern ProdNonEmpty :: (f :*: ListF f) a -> NonEmptyF f a
nonEmptyProd :: () => NonEmptyF f a -> (f :*: ListF f) a

-- | A maybe <tt>f a</tt>.
--   
--   Can be useful for describing a "an <tt>f a</tt> that may or may not be
--   there".
--   
--   This is the free structure for a "fail"-like typeclass that only has
--   <tt>zero :: f a</tt>.
newtype MaybeF f a
MaybeF :: Maybe (f a) -> MaybeF f a
[runMaybeF] :: MaybeF f a -> Maybe (f a)

-- | Map a function over the inside of a <a>MaybeF</a>.
mapMaybeF :: (Maybe (f a) -> Maybe (g b)) -> MaybeF f a -> MaybeF g b

-- | Convert a <a>ListF</a> into a <a>MaybeF</a> containing the first <tt>f
--   a</tt> in the list, if it exists.
listToMaybeF :: ListF f ~> MaybeF f

-- | Convert a <a>MaybeF</a> into a <a>ListF</a> with zero or one items.
maybeToListF :: MaybeF f ~> ListF f
instance Data.Functor.Classes.Ord1 f => Data.Functor.Classes.Ord1 (Control.Applicative.ListF.MaybeF f)
instance GHC.Base.Applicative f => GHC.Base.Applicative (Control.Applicative.ListF.MaybeF f)
instance GHC.Base.Functor f => Data.Functor.Alt.Alt (Control.Applicative.ListF.MaybeF f)
instance GHC.Base.Functor f => Data.Functor.Plus.Plus (Control.Applicative.ListF.MaybeF f)
instance GHC.Base.Applicative f => GHC.Base.Alternative (Control.Applicative.ListF.MaybeF f)
instance GHC.Base.Semigroup (Control.Applicative.ListF.MaybeF f a)
instance GHC.Base.Monoid (Control.Applicative.ListF.MaybeF f a)
instance Data.Functor.Classes.Eq1 f => Data.Functor.Classes.Eq1 (Control.Applicative.ListF.MaybeF f)
instance Data.Functor.Classes.Read1 f => Data.Functor.Classes.Read1 (Control.Applicative.ListF.MaybeF f)
instance Data.Functor.Classes.Show1 f => Data.Functor.Classes.Show1 (Control.Applicative.ListF.MaybeF f)
instance (Data.Typeable.Internal.Typeable f, Data.Typeable.Internal.Typeable a, Data.Data.Data (f a)) => Data.Data.Data (Control.Applicative.ListF.MaybeF f a)
instance GHC.Generics.Generic (Control.Applicative.ListF.MaybeF f a)
instance Data.Traversable.Traversable f => Data.Traversable.Traversable (Control.Applicative.ListF.MaybeF f)
instance Data.Foldable.Foldable f => Data.Foldable.Foldable (Control.Applicative.ListF.MaybeF f)
instance GHC.Base.Functor f => GHC.Base.Functor (Control.Applicative.ListF.MaybeF f)
instance GHC.Classes.Ord (f a) => GHC.Classes.Ord (Control.Applicative.ListF.MaybeF f a)
instance GHC.Classes.Eq (f a) => GHC.Classes.Eq (Control.Applicative.ListF.MaybeF f a)
instance GHC.Read.Read (f a) => GHC.Read.Read (Control.Applicative.ListF.MaybeF f a)
instance GHC.Show.Show (f a) => GHC.Show.Show (Control.Applicative.ListF.MaybeF f a)
instance Data.Functor.Classes.Ord1 f => Data.Functor.Classes.Ord1 (Control.Applicative.ListF.NonEmptyF f)
instance GHC.Base.Applicative f => GHC.Base.Applicative (Control.Applicative.ListF.NonEmptyF f)
instance GHC.Base.Functor f => Data.Functor.Alt.Alt (Control.Applicative.ListF.NonEmptyF f)
instance GHC.Base.Semigroup (Control.Applicative.ListF.NonEmptyF f a)
instance Data.Functor.Classes.Eq1 f => Data.Functor.Classes.Eq1 (Control.Applicative.ListF.NonEmptyF f)
instance Data.Functor.Classes.Read1 f => Data.Functor.Classes.Read1 (Control.Applicative.ListF.NonEmptyF f)
instance Data.Functor.Classes.Show1 f => Data.Functor.Classes.Show1 (Control.Applicative.ListF.NonEmptyF f)
instance (Data.Typeable.Internal.Typeable f, Data.Typeable.Internal.Typeable a, Data.Data.Data (f a)) => Data.Data.Data (Control.Applicative.ListF.NonEmptyF f a)
instance GHC.Generics.Generic (Control.Applicative.ListF.NonEmptyF f a)
instance Data.Traversable.Traversable f => Data.Traversable.Traversable (Control.Applicative.ListF.NonEmptyF f)
instance Data.Foldable.Foldable f => Data.Foldable.Foldable (Control.Applicative.ListF.NonEmptyF f)
instance GHC.Base.Functor f => GHC.Base.Functor (Control.Applicative.ListF.NonEmptyF f)
instance GHC.Classes.Ord (f a) => GHC.Classes.Ord (Control.Applicative.ListF.NonEmptyF f a)
instance GHC.Classes.Eq (f a) => GHC.Classes.Eq (Control.Applicative.ListF.NonEmptyF f a)
instance GHC.Read.Read (f a) => GHC.Read.Read (Control.Applicative.ListF.NonEmptyF f a)
instance GHC.Show.Show (f a) => GHC.Show.Show (Control.Applicative.ListF.NonEmptyF f a)
instance Data.Functor.Classes.Ord1 f => Data.Functor.Classes.Ord1 (Control.Applicative.ListF.ListF f)
instance GHC.Base.Applicative f => GHC.Base.Applicative (Control.Applicative.ListF.ListF f)
instance GHC.Base.Functor f => Data.Functor.Alt.Alt (Control.Applicative.ListF.ListF f)
instance GHC.Base.Functor f => Data.Functor.Plus.Plus (Control.Applicative.ListF.ListF f)
instance GHC.Base.Applicative f => GHC.Base.Alternative (Control.Applicative.ListF.ListF f)
instance GHC.Base.Semigroup (Control.Applicative.ListF.ListF f a)
instance GHC.Base.Monoid (Control.Applicative.ListF.ListF f a)
instance Data.Functor.Classes.Eq1 f => Data.Functor.Classes.Eq1 (Control.Applicative.ListF.ListF f)
instance Data.Functor.Classes.Read1 f => Data.Functor.Classes.Read1 (Control.Applicative.ListF.ListF f)
instance Data.Functor.Classes.Show1 f => Data.Functor.Classes.Show1 (Control.Applicative.ListF.ListF f)
instance (Data.Typeable.Internal.Typeable f, Data.Typeable.Internal.Typeable a, Data.Data.Data (f a)) => Data.Data.Data (Control.Applicative.ListF.ListF f a)
instance GHC.Generics.Generic (Control.Applicative.ListF.ListF f a)
instance Data.Traversable.Traversable f => Data.Traversable.Traversable (Control.Applicative.ListF.ListF f)
instance Data.Foldable.Foldable f => Data.Foldable.Foldable (Control.Applicative.ListF.ListF f)
instance GHC.Base.Functor f => GHC.Base.Functor (Control.Applicative.ListF.ListF f)
instance GHC.Classes.Ord (f a) => GHC.Classes.Ord (Control.Applicative.ListF.ListF f a)
instance GHC.Classes.Eq (f a) => GHC.Classes.Eq (Control.Applicative.ListF.ListF f a)
instance GHC.Read.Read (f a) => GHC.Read.Read (Control.Applicative.ListF.ListF f a)
instance GHC.Show.Show (f a) => GHC.Show.Show (Control.Applicative.ListF.ListF f a)


-- | This module provides functor combinators that are the fixed points of
--   applications of <a>:+:</a> and <a>TheseT</a>. They are useful for
--   their <a>Interpret</a> instances, along with their relationship to the
--   <a>Monoidal</a> insatnces of <a>:+:</a> and <a>TheseT</a>.
module Control.Applicative.Step

-- | An <tt>f a</tt>, along with a <a>Natural</a> index.
--   
--   <pre>
--   Step f a ~ (<a>Natural</a>, f a)
--   Step f   ~ ((,) <a>Natural</a>) <a>:.:</a> f       -- functor composition
--   </pre>
--   
--   It is the fixed point of applications of <a>:+:</a> (functor sums).
--   
--   Intuitively, in an infinite <tt>f :+: f :+: f :+: f ...</tt>, you have
--   exactly one <tt>f</tt> <i>somewhere</i>. A <tt><a>Step</a> f a</tt>
--   has that <tt>f</tt>, with a <a>Natural</a> giving you "where" the
--   <tt>f</tt> is in the long chain.
--   
--   <a>interpret</a>ing it requires no constraint on the target context.
data Step f a
Step :: Natural -> f a -> Step f a
[stepPos] :: Step f a -> Natural
[stepVal] :: Step f a -> f a

-- | A non-empty map of <a>Natural</a> to <tt>f a</tt>. Basically, contains
--   multiple <tt>f a</tt>s, each at a given <a>Natural</a> index.
--   
--   <pre>
--   Steps f a ~ <a>Map</a> <a>Natural</a> (f a)
--   Steps f   ~ <a>Map</a> <a>Natural</a> <a>:.:</a> f       -- functor composition
--   </pre>
--   
--   It is the fixed point of applications of <a>TheseT</a>.
--   
--   Intuitively, in an infinite <tt>f `TheseT` f `TheseT` f `TheseT` f
--   ...</tt>, each of those infinite positions may have an <tt>f</tt> in
--   them. However, because of the at-least-one nature of <a>TheseT</a>, we
--   know we have at least one f at one position <i>somewhere</i>.
--   
--   A <tt><a>Steps</a> f a</tt> has potentially many <tt>f</tt>s, each
--   stored at a different <a>Natural</a> position, with the guaruntee that
--   at least one <tt>f</tt> exists.
--   
--   <a>interpret</a>ing it requires at least an <a>Alt</a> instance in the
--   target context, since we have to handle potentially more than one
--   <tt>f</tt>. However, we don't fully need <a>Plus</a>, since we know we
--   always have at least one <tt>f</tt>.
newtype Steps f a
Steps :: NEMap Natural (f a) -> Steps f a
[getSteps] :: Steps f a -> NEMap Natural (f a)

-- | The identity functor of <a>:+:</a> (and also <a>TheseT</a>)
data VoidT a

-- | We have a natural transformation between <a>VoidT</a> and any other
--   functor <tt>f</tt> with no constraints.
absurdT :: VoidT a -> f a
instance Data.Functor.Classes.Ord1 f => Data.Functor.Classes.Ord1 (Control.Applicative.Step.Steps f)
instance Data.Semigroup.Foldable.Class.Foldable1 f => Data.Semigroup.Foldable.Class.Foldable1 (Control.Applicative.Step.Steps f)
instance Data.Semigroup.Traversable.Class.Traversable1 f => Data.Semigroup.Traversable.Class.Traversable1 (Control.Applicative.Step.Steps f)
instance GHC.Base.Functor f => Data.Functor.Alt.Alt (Control.Applicative.Step.Steps f)
instance Data.Functor.Classes.Eq1 f => Data.Functor.Classes.Eq1 (Control.Applicative.Step.Steps f)
instance Data.Functor.Classes.Read1 f => Data.Functor.Classes.Read1 (Control.Applicative.Step.Steps f)
instance Data.Functor.Classes.Show1 f => Data.Functor.Classes.Show1 (Control.Applicative.Step.Steps f)
instance (Data.Typeable.Internal.Typeable f, Data.Typeable.Internal.Typeable a, Data.Data.Data (f a)) => Data.Data.Data (Control.Applicative.Step.Steps f a)
instance GHC.Generics.Generic (Control.Applicative.Step.Steps f a)
instance Data.Traversable.Traversable f => Data.Traversable.Traversable (Control.Applicative.Step.Steps f)
instance Data.Foldable.Foldable f => Data.Foldable.Foldable (Control.Applicative.Step.Steps f)
instance GHC.Base.Functor f => GHC.Base.Functor (Control.Applicative.Step.Steps f)
instance GHC.Classes.Ord (f a) => GHC.Classes.Ord (Control.Applicative.Step.Steps f a)
instance GHC.Classes.Eq (f a) => GHC.Classes.Eq (Control.Applicative.Step.Steps f a)
instance GHC.Read.Read (f a) => GHC.Read.Read (Control.Applicative.Step.Steps f a)
instance GHC.Show.Show (f a) => GHC.Show.Show (Control.Applicative.Step.Steps f a)
instance Data.Functor.Classes.Ord1 Control.Applicative.Step.VoidT
instance Data.Functor.Classes.Eq1 Control.Applicative.Step.VoidT
instance Data.Functor.Classes.Read1 Control.Applicative.Step.VoidT
instance Data.Functor.Classes.Show1 Control.Applicative.Step.VoidT
instance Data.Data.Data a => Data.Data.Data (Control.Applicative.Step.VoidT a)
instance GHC.Generics.Generic (Control.Applicative.Step.VoidT a)
instance Data.Traversable.Traversable Control.Applicative.Step.VoidT
instance Data.Foldable.Foldable Control.Applicative.Step.VoidT
instance GHC.Base.Functor Control.Applicative.Step.VoidT
instance GHC.Classes.Ord (Control.Applicative.Step.VoidT a)
instance GHC.Classes.Eq (Control.Applicative.Step.VoidT a)
instance GHC.Read.Read (Control.Applicative.Step.VoidT a)
instance GHC.Show.Show (Control.Applicative.Step.VoidT a)
instance Data.Functor.Classes.Ord1 f => Data.Functor.Classes.Ord1 (Control.Applicative.Step.Step f)
instance GHC.Base.Applicative f => GHC.Base.Applicative (Control.Applicative.Step.Step f)
instance Data.Semigroup.Foldable.Class.Foldable1 f => Data.Semigroup.Foldable.Class.Foldable1 (Control.Applicative.Step.Step f)
instance Data.Semigroup.Traversable.Class.Traversable1 f => Data.Semigroup.Traversable.Class.Traversable1 (Control.Applicative.Step.Step f)
instance Data.Functor.Classes.Eq1 f => Data.Functor.Classes.Eq1 (Control.Applicative.Step.Step f)
instance Data.Functor.Classes.Read1 f => Data.Functor.Classes.Read1 (Control.Applicative.Step.Step f)
instance Data.Functor.Classes.Show1 f => Data.Functor.Classes.Show1 (Control.Applicative.Step.Step f)
instance (Data.Typeable.Internal.Typeable f, Data.Typeable.Internal.Typeable a, Data.Data.Data (f a)) => Data.Data.Data (Control.Applicative.Step.Step f a)
instance GHC.Generics.Generic (Control.Applicative.Step.Step f a)
instance Data.Traversable.Traversable f => Data.Traversable.Traversable (Control.Applicative.Step.Step f)
instance Data.Foldable.Foldable f => Data.Foldable.Foldable (Control.Applicative.Step.Step f)
instance GHC.Base.Functor f => GHC.Base.Functor (Control.Applicative.Step.Step f)
instance GHC.Classes.Ord (f a) => GHC.Classes.Ord (Control.Applicative.Step.Step f a)
instance GHC.Classes.Eq (f a) => GHC.Classes.Eq (Control.Applicative.Step.Step f a)
instance GHC.Read.Read (f a) => GHC.Read.Read (Control.Applicative.Step.Step f a)
instance GHC.Show.Show (f a) => GHC.Show.Show (Control.Applicative.Step.Step f a)


-- | The church-encoded <a>Freer</a> Monad. Basically provides the free
--   monad in a way that is compatible with <a>HFunctor</a> and
--   <a>Interpret</a>, and <a>:.:</a> or <a>Compose</a> in a way that is
--   compatible with <a>HBifunctor</a> and <a>Tensor</a> and
--   <a>Monoidal</a>.
module Control.Monad.Freer.Church

-- | A <tt><a>Free</a> f</tt> is <tt>f</tt> enhanced with "sequential
--   binding" capabilities. It allows you to sequence multiple <tt>f</tt>s
--   one after the other, and also to determine "what <tt>f</tt> to
--   sequence" based on the result of the computation so far.
--   
--   Essentially, you can think of this as "giving <tt>f</tt> a
--   <a>Monad</a> instance", with all that that entails (<a>return</a>,
--   <a>&gt;&gt;=</a>, etc.).
--   
--   Lift <tt>f</tt> into it with <tt><a>inject</a> :: f a -&gt; Free f
--   a</tt>. When you finally want to "use" it, you can interpret it into
--   any monadic context:
--   
--   <pre>
--   <a>interpret</a>
--       :: <a>Monad</a> g
--       =&gt; (forall x. f x -&gt; g x)
--       -&gt; <a>Free</a> f a
--       -&gt; g a
--   </pre>
--   
--   Under the hood, this is the Church-encoded Freer monad. It's
--   <a>Free</a>, or <a>F</a>, but in a way that is compatible with
--   <a>HFunctor</a> and <a>Interpret</a>.
newtype Free f a
Free :: (forall r. (a -> r) -> (forall s. f s -> (s -> r) -> r) -> r) -> Free f a
[runFree] :: Free f a -> forall r. (a -> r) -> (forall s. f s -> (s -> r) -> r) -> r

-- | Convert a <tt><a>Free</a> f</tt> into any instance of
--   <tt><a>MonadFree</a> f</tt>.
reFree :: (MonadFree f m, Functor f) => Free f a -> m a

-- | Functor composition. <tt><a>Comp</a> f g a</tt> is equivalent to <tt>f
--   (g a)</tt>, and the <a>Comp</a> pattern synonym is a way of getting
--   the <tt>f (g a)</tt> in a <tt><a>Comp</a> f g a</tt>.
--   
--   For example, <tt><a>Maybe</a> (<a>IO</a> <a>Bool</a>)</tt> is
--   <tt><a>Comp</a> <a>Maybe</a> <a>IO</a> <a>Bool</a></tt>.
--   
--   This is mostly useful for its typeclass instances: in particular,
--   <a>Functor</a>, <a>Applicative</a>, <a>HBifunctor</a>, and
--   <a>Monoidal</a>.
--   
--   This is essentially a version of <a>:.:</a> and <a>Compose</a> that
--   allows for an <a>HBifunctor</a> instance.
--   
--   It is slightly less performant. Using <tt><a>comp</a> .
--   <a>unComp</a></tt> every once in a while will concretize a <a>Comp</a>
--   value (if you have <tt><a>Functor</a> f</tt>) and remove some
--   indirection if you have a lot of chained operations.
--   
--   The "free monoid" over <a>Comp</a> is <a>Free</a>.
data Comp f g a
(:>>=) :: f x -> (x -> g a) -> Comp f g a

-- | Pattern match on and construct a <tt><a>Comp</a> f g a</tt> as if it
--   were <tt>f (g a)</tt>.
pattern Comp :: Functor f => f (g a) -> Comp f g a

-- | "Smart constructor" for <a>Comp</a> that doesn't require
--   <tt><a>Functor</a> f</tt>.
comp :: f (g a) -> Comp f g a
instance GHC.Base.Functor g => GHC.Base.Functor (Control.Monad.Freer.Church.Comp f g)
instance (GHC.Base.Applicative f, GHC.Base.Applicative g) => GHC.Base.Applicative (Control.Monad.Freer.Church.Comp f g)
instance (Data.Foldable.Foldable f, Data.Foldable.Foldable g) => Data.Foldable.Foldable (Control.Monad.Freer.Church.Comp f g)
instance (Data.Traversable.Traversable f, Data.Traversable.Traversable g) => Data.Traversable.Traversable (Control.Monad.Freer.Church.Comp f g)
instance (GHC.Base.Alternative f, GHC.Base.Alternative g) => GHC.Base.Alternative (Control.Monad.Freer.Church.Comp f g)
instance (GHC.Base.Functor f, Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g) => Data.Functor.Classes.Show1 (Control.Monad.Freer.Church.Comp f g)
instance (GHC.Base.Functor f, Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g, GHC.Show.Show a) => GHC.Show.Show (Control.Monad.Freer.Church.Comp f g a)
instance (GHC.Base.Functor f, Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) => Data.Functor.Classes.Read1 (Control.Monad.Freer.Church.Comp f g)
instance (GHC.Base.Functor f, Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g, GHC.Read.Read a) => GHC.Read.Read (Control.Monad.Freer.Church.Comp f g a)
instance (GHC.Base.Functor f, Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g) => Data.Functor.Classes.Eq1 (Control.Monad.Freer.Church.Comp f g)
instance (GHC.Base.Functor f, Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g) => Data.Functor.Classes.Ord1 (Control.Monad.Freer.Church.Comp f g)
instance (GHC.Base.Functor f, Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g, GHC.Classes.Eq a) => GHC.Classes.Eq (Control.Monad.Freer.Church.Comp f g a)
instance (GHC.Base.Functor f, Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g, GHC.Classes.Ord a) => GHC.Classes.Ord (Control.Monad.Freer.Church.Comp f g a)
instance GHC.Base.Functor (Control.Monad.Freer.Church.Free f)
instance GHC.Base.Applicative (Control.Monad.Freer.Church.Free f)
instance GHC.Base.Monad (Control.Monad.Freer.Church.Free f)
instance Control.Monad.Free.Class.MonadFree f (Control.Monad.Freer.Church.Free f)
instance Data.Foldable.Foldable f => Data.Foldable.Foldable (Control.Monad.Freer.Church.Free f)
instance Data.Traversable.Traversable f => Data.Traversable.Traversable (Control.Monad.Freer.Church.Free f)
instance (GHC.Base.Functor f, Data.Functor.Classes.Eq1 f) => Data.Functor.Classes.Eq1 (Control.Monad.Freer.Church.Free f)
instance (GHC.Base.Functor f, Data.Functor.Classes.Ord1 f) => Data.Functor.Classes.Ord1 (Control.Monad.Freer.Church.Free f)
instance (GHC.Base.Functor f, Data.Functor.Classes.Eq1 f, GHC.Classes.Eq a) => GHC.Classes.Eq (Control.Monad.Freer.Church.Free f a)
instance (GHC.Base.Functor f, Data.Functor.Classes.Ord1 f, GHC.Classes.Ord a) => GHC.Classes.Ord (Control.Monad.Freer.Church.Free f a)

module Data.Functor.HFunctor

-- | An <a>HFunctor</a> can be thought of a unary "functor transformer" ---
--   a basic functor combinator. It takes a functor as input and returns a
--   functor as output.
--   
--   It "enhances" a functor with extra structure (sort of like how a monad
--   transformer enhances a <a>Monad</a> with extra structure).
--   
--   As a uniform inteface, we can "swap the underlying functor" (also
--   sometimes called "hoisting"). This is what <a>hmap</a> does: it lets
--   us swap out the <tt>f</tt> in a <tt>t f</tt> for a <tt>t g</tt>.
--   
--   For example, the free monad <a>Free</a> takes a <a>Functor</a> and
--   returns a new <a>Functor</a>. In the process, it provides a monadic
--   structure over <tt>f</tt>. <a>hmap</a> lets us turn a <tt><a>Free</a>
--   f</tt> into a <tt><a>Free</a> g</tt>: a monad built over <tt>f</tt>
--   can be turned into a monad built over <tt>g</tt>.
--   
--   For the ability to move in and out of the enhanced functor, see
--   <tt>Interpret</tt>.
class HFunctor t

-- | If we can turn an <tt>f</tt> into a <tt>g</tt>, then we can turn a
--   <tt>t f</tt> into a <tt>t g</tt>.
--   
--   It must be the case that
--   
--   <pre>
--   <a>hmap</a> <a>id</a> == id
--   </pre>
--   
--   Essentially, <tt><tt>t</tt> f</tt> adds some "extra structure" to
--   <tt>f</tt>. <a>hmap</a> must swap out the functor, <i>without
--   affecting the added structure</i>.
--   
--   For example, <tt><a>ListF</a> f a</tt> is essentially a list of <tt>f
--   a</tt>s. If we <a>hmap</a> to swap out the <tt>f a</tt>s for <tt>g
--   a</tt>s, then we must ensure that the "added structure" (here, the
--   number of items in the list) remains the same. So, <a>hmap</a> must
--   preserve the number of items in the list.
--   
--   The law <tt><a>hmap</a> <a>id</a> == id</tt> is a way of formalizing
--   this informal property.
hmap :: HFunctor t => (f ~> g) -> t f ~> t g

-- | An <a>Interpret</a> lets us move in and out of the "enhanced"
--   <a>Functor</a>.
--   
--   For example, <tt><a>Free</a> f</tt> is <tt>f</tt> enhanced with
--   monadic structure. We get:
--   
--   <pre>
--   <a>inject</a>    :: f a -&gt; <a>Free</a> f a
--   <a>interpret</a> :: <a>Monad</a> m =&gt; (forall x. f x -&gt; m x) -&gt; <a>Free</a> f a -&gt; m a
--   </pre>
--   
--   <a>inject</a> will let us use our <tt>f</tt> inside the enhanced
--   <tt><a>Free</a> f</tt>. <a>interpret</a> will let us "extract" the
--   <tt>f</tt> from a <tt><a>Free</a> f</tt> if we can give an
--   <i>interpreting function</i> that interprets <tt>f</tt> into some
--   target <a>Monad</a>.
--   
--   The type family <a>C</a> tells us the typeclass constraint of the
--   "target" functor. For <a>Free</a>, it is <a>Monad</a>, but for other
--   <a>Interpret</a> instances, we might have other constraints.
--   
--   We enforce that:
--   
--   <pre>
--   <a>interpret</a> id . <a>inject</a> == id
--   </pre>
--   
--   That is, if we lift a value into our structure, then immediately
--   interpret it out as itself, it should lave the value unchanged.
class HFunctor t => Interpret t where {
    
    -- | The constraint on the target context of <a>interpret</a>.
    type family C t :: (Type -> Type) -> Constraint;
}

-- | Lift an <tt>f</tt> into the enhanced <tt>t f</tt> structure. Analogous
--   to <a>lift</a> from <a>MonadTrans</a>.
inject :: Interpret t => f ~> t f

-- | Remove the <tt>f</tt> out of the enhanced <tt>t f</tt> structure,
--   provided that <tt>f</tt> satisfies the necessary constraints. If it
--   doesn't, it needs to be properly <a>interpret</a>ed out.
retract :: (Interpret t, C t f) => t f ~> f

-- | Given an "interpeting function" from <tt>f</tt> to <tt>g</tt>,
--   interpret the <tt>f</tt> out of the <tt>t f</tt> into a final context
--   <tt>g</tt>.
interpret :: (Interpret t, C t g) => (f ~> g) -> t f ~> g

-- | A convenient flipped version of <a>interpret</a>.
interpretFor :: (Interpret t, C t g) => t f a -> (f ~> g) -> g a

-- | Useful wrapper over <a>retract</a> to allow you to directly extract an
--   <tt>a</tt> from a <tt>t f a</tt>, if <tt>f</tt> is a valid retraction
--   from <tt>t</tt>, and <tt>f</tt> is an instance of <a>Copointed</a>.
--   
--   Useful <tt>f</tt>s include <tt>Identity</tt> or related newtype
--   wrappers from base:
--   
--   <pre>
--   <a>extractI</a>
--       :: (<a>Interpret</a> t, <a>C</a> t <tt>Identity</tt>)
--       =&gt; t <tt>Identity</tt> a
--       -&gt; a
--   </pre>
extractI :: (Interpret t, C t f, Copointed f) => t f a -> a

-- | Useful wrapper over <a>interpret</a> to allow you to directly extract
--   a value <tt>b</tt> out of the <tt>t f a</tt>, if you can convert <tt>f
--   x</tt> into <tt>b</tt>.
--   
--   Note that depending on the constraints on the interpretation of
--   <tt>t</tt>, you may have extra constraints on <tt>b</tt>.
--   
--   <ul>
--   <li>If <tt><a>C</a> t</tt> is <a>Unconstrained</a>, there are no
--   constraints on <tt>b</tt></li>
--   <li>If <tt><a>C</a> t</tt> is <a>Apply</a>, <tt>b</tt> needs to be an
--   instance of <a>Semigroup</a></li>
--   <li>If <tt><a>C</a> t</tt> is <a>Applicative</a>, <tt>b</tt> needs to
--   be an instance of <a>Monoid</a></li>
--   </ul>
--   
--   For some constraints (like <a>Monad</a>), this will not be usable.
--   
--   <pre>
--   -- get the length of the <tt>Map String</tt> in the <a>Step</a>.
--   <a>collectI</a> length
--        :: Step (Map String) Bool
--        -&gt; [Int]
--   </pre>
getI :: (Interpret t, C t (Const b)) => (forall x. f x -> b) -> t f a -> b

-- | Useful wrapper over <a>getI</a> to allow you to collect a <tt>b</tt>
--   from all instances of <tt>f</tt> inside a <tt>t f a</tt>.
--   
--   This will work if <tt><a>C</a> t</tt> is <a>Unconstrained</a>,
--   <a>Apply</a>, or <a>Applicative</a>.
--   
--   <pre>
--   -- get the lengths of all <tt>Map String</tt>s in the <a>Ap</a>.
--   <a>collectI</a> length
--        :: Ap (Map String) Bool
--        -&gt; [Int]
--   </pre>
collectI :: (Interpret t, C t (Const [b])) => (forall x. f x -> b) -> t f a -> [b]
class (c a, d a) => AndC c d a
instance forall k (c :: k -> GHC.Types.Constraint) (a :: k) (d :: k -> GHC.Types.Constraint). (c a, d a) => Data.Functor.HFunctor.AndC c d a
instance (Data.Functor.HFunctor.Interpret s, Data.Functor.HFunctor.Interpret t) => Data.Functor.HFunctor.Interpret (Control.Monad.Trans.Compose.ComposeT s t)
instance Data.Functor.HFunctor.Interpret Data.Functor.Coyoneda.Coyoneda
instance Data.Functor.HFunctor.Interpret Control.Applicative.Free.Ap
instance Data.Functor.HFunctor.Interpret Control.Applicative.ListF.ListF
instance Data.Functor.HFunctor.Interpret Control.Applicative.ListF.NonEmptyF
instance Data.Functor.HFunctor.Interpret Control.Applicative.ListF.MaybeF
instance Data.Functor.HFunctor.Interpret Control.Applicative.Step.Step
instance Data.Functor.HFunctor.Interpret Control.Applicative.Step.Steps
instance Data.Functor.HFunctor.Interpret Control.Alternative.Free.Alt
instance Data.Functor.HFunctor.Interpret Control.Monad.Freer.Church.Free
instance Data.Functor.HFunctor.Interpret Control.Applicative.Free.Final.Ap
instance Data.Functor.HFunctor.Interpret Control.Applicative.Free.Fast.Ap
instance Data.Functor.HFunctor.Interpret Control.Monad.Trans.Identity.IdentityT
instance Data.Functor.HFunctor.Interpret Control.Applicative.Lift.Lift
instance Data.Functor.HFunctor.Interpret Data.Functor.Bind.Class.MaybeApply
instance Data.Functor.HFunctor.Interpret Control.Applicative.Backwards.Backwards
instance Data.Functor.HFunctor.Interpret Data.Functor.Bind.Class.WrappedApplicative
instance Data.Functor.HFunctor.Interpret (Control.Monad.Trans.Reader.ReaderT r)
instance Data.Functor.HFunctor.Interpret Data.Functor.Reverse.Reverse

module Data.Functor.HFunctor.Final

-- | A simple way to inject/reject into any eventual typeclass.
--   
--   In a way, this is the "ultimate" <a>Interpret</a> instance. You can
--   use this to inject an <tt>f</tt> into a free structure of any
--   typeclass. If you want <tt>f</tt> to have a <a>Monad</a> instance, for
--   example, just use
--   
--   <pre>
--   <a>inject</a> :: f a -&gt; <a>Final</a> <a>Monad</a> f a
--   </pre>
--   
--   When you want to eventually interpret out the data, use:
--   
--   <pre>
--   <a>interpret</a> :: (f <a>~&gt;</a> g) -&gt; <a>Final</a> c f a -&gt; g a
--   </pre>
--   
--   Essentially, <tt><a>Final</a> c</tt> is the "free c". <tt><a>Final</a>
--   <a>Monad</a></tt> is the free <a>Monad</a>, etc.
--   
--   Note that this doesn't have instances for <i>all</i> the typeclasses
--   you could lift things into; you probably have to define your own if
--   you want to use <tt><a>Final</a> c</tt> as an <i>instance</i> of
--   <tt>c</tt> (using <a>liftFinal0</a>, <a>liftFinal1</a>,
--   <a>liftFinal2</a> for help).
newtype Final c f a
Final :: (forall g. c g => (forall x. f x -> g x) -> g a) -> Final c f a
[runFinal] :: Final c f a -> forall g. c g => (forall x. f x -> g x) -> g a

-- | <a>Concretize</a> a <a>Final</a>.
fromFinal :: (Interpret t, c (t f)) => Final c f ~> t f

-- | <a>Finalize</a> an <a>Interpret</a> instance.
--   
--   <pre>
--   toFinal :: <a>Coyoneda</a> f <a>~&gt;</a> <a>Final</a> <a>Functor</a> f
--   toFinal :: <a>Ap</a> f <a>~&gt;</a> <a>Final</a> <a>Applicative</a> f
--   toFinal :: <a>Alt</a> f <a>~&gt;</a> <a>Final</a> <a>Alternative</a> f
--   toFinal :: <a>Free</a> f <a>~&gt;</a> <a>Final</a> <a>Monad</a> f
--   toFinal :: <a>Lift</a> f <a>~&gt;</a> <a>Final</a> <a>Pointed</a> f
--   toFinal :: <a>ListF</a> f <a>~&gt;</a> <a>Final</a> <a>Plus</a> f
--   </pre>
--   
--   Note that the instance of <tt>c</tt> for <tt><a>Final</a> c</tt> must
--   be defined.
--   
--   This operation can potentially <i>forget</i> structure in <tt>t</tt>.
--   For example, we have:
--   
--   <pre>
--   <a>toFinal</a> :: <tt>Steps</tt> f ~&gt; <a>Final</a> <a>Alt</a> f
--   </pre>
--   
--   In this process, we lose the "positional" structure of <tt>Steps</tt>.
--   
--   In the case where <a>toFinal</a> doesn't lose any information, this
--   will form an isomorphism with <a>fromFinal</a>, and <tt>t</tt> is
--   known as the "Free <tt>c</tt>". For such a situation, <tt>t</tt> will
--   have a <a>FreeOf</a> instance.
toFinal :: (Interpret t, C t (Final c f)) => t f ~> Final c f

-- | A typeclass associating a free structure with the typeclass it is free
--   on.
--   
--   This essentially lists instances of <a>Interpret</a> where a "trip"
--   through <a>Final</a> will leave it unchanged.
--   
--   <pre>
--   <a>fromFree</a> . <a>toFree</a> == id
--   <a>toFree</a> . <a>fromFree</a> == id
--   </pre>
--   
--   This can be useful because <a>Final</a> doesn't have a concrete
--   structure that you can pattern match on and inspect, but <tt>t</tt>
--   might. This lets you work on a concrete structure if you desire.
class Interpret t => FreeOf c t | t -> c
fromFree :: FreeOf c t => t f ~> Final c f
toFree :: (FreeOf c t, Functor f) => Final c f ~> t f
fromFree :: (FreeOf c t, C t (Final c f)) => t f ~> Final c f
toFree :: (FreeOf c t, c (t f)) => Final c f ~> t f
hoistFinalC :: (forall g x. (c g => g x) -> d g => g x) -> Final c f a -> Final d f a

-- | Lift an action into a <a>Final</a>.
liftFinal0 :: (forall g. c g => g a) -> Final c f a

-- | Map the action in a <a>Final</a>.
liftFinal1 :: (forall g. c g => g a -> g b) -> Final c f a -> Final c f b

-- | Merge two <a>Final</a> actions.
liftFinal2 :: (forall g. c g => g a -> g b -> g d) -> Final c f a -> Final c f b -> Final c f d
instance Data.Functor.HFunctor.Final.FreeOf GHC.Base.Functor Data.Functor.Coyoneda.Coyoneda
instance Data.Functor.HFunctor.Final.FreeOf GHC.Base.Applicative Control.Applicative.Free.Ap
instance Data.Functor.HFunctor.Final.FreeOf GHC.Base.Applicative Control.Applicative.Free.Fast.Ap
instance Data.Functor.HFunctor.Final.FreeOf GHC.Base.Alternative Control.Alternative.Free.Alt
instance Data.Functor.HFunctor.Final.FreeOf GHC.Base.Monad Control.Monad.Freer.Church.Free
instance Data.Functor.HFunctor.Final.FreeOf Data.Pointed.Pointed Control.Applicative.Lift.Lift
instance Data.Functor.HFunctor.Final.FreeOf Data.Pointed.Pointed Data.Functor.Bind.Class.MaybeApply
instance Data.Functor.HFunctor.Final.FreeOf Data.Functor.Alt.Alt Control.Applicative.ListF.NonEmptyF
instance Data.Functor.HFunctor.Final.FreeOf Data.Functor.Plus.Plus Control.Applicative.ListF.ListF
instance Data.Functor.HFunctor.Final.FreeOf Data.Constraint.Trivial.Unconstrained Control.Monad.Trans.Identity.IdentityT
instance GHC.Base.Functor (Data.Functor.HFunctor.Final.Final GHC.Base.Functor f)
instance GHC.Base.Functor (Data.Functor.HFunctor.Final.Final Data.Functor.Bind.Class.Apply f)
instance Data.Functor.Bind.Class.Apply (Data.Functor.HFunctor.Final.Final Data.Functor.Bind.Class.Apply f)
instance GHC.Base.Functor (Data.Functor.HFunctor.Final.Final GHC.Base.Applicative f)
instance Data.Functor.Bind.Class.Apply (Data.Functor.HFunctor.Final.Final GHC.Base.Applicative f)
instance GHC.Base.Applicative (Data.Functor.HFunctor.Final.Final GHC.Base.Applicative f)
instance GHC.Base.Functor (Data.Functor.HFunctor.Final.Final GHC.Base.Alternative f)
instance Data.Functor.Bind.Class.Apply (Data.Functor.HFunctor.Final.Final GHC.Base.Alternative f)
instance GHC.Base.Applicative (Data.Functor.HFunctor.Final.Final GHC.Base.Alternative f)
instance GHC.Base.Alternative (Data.Functor.HFunctor.Final.Final GHC.Base.Alternative f)
instance GHC.Base.Functor (Data.Functor.HFunctor.Final.Final GHC.Base.Monad f)
instance Data.Functor.Bind.Class.Apply (Data.Functor.HFunctor.Final.Final GHC.Base.Monad f)
instance GHC.Base.Applicative (Data.Functor.HFunctor.Final.Final GHC.Base.Monad f)
instance GHC.Base.Monad (Data.Functor.HFunctor.Final.Final GHC.Base.Monad f)
instance GHC.Base.Functor (Data.Functor.HFunctor.Final.Final GHC.Base.MonadPlus f)
instance GHC.Base.Applicative (Data.Functor.HFunctor.Final.Final GHC.Base.MonadPlus f)
instance GHC.Base.Monad (Data.Functor.HFunctor.Final.Final GHC.Base.MonadPlus f)
instance GHC.Base.Alternative (Data.Functor.HFunctor.Final.Final GHC.Base.MonadPlus f)
instance GHC.Base.MonadPlus (Data.Functor.HFunctor.Final.Final GHC.Base.MonadPlus f)
instance Data.Pointed.Pointed (Data.Functor.HFunctor.Final.Final Data.Pointed.Pointed f)
instance GHC.Base.Functor (Data.Functor.HFunctor.Final.Final (Control.Monad.Reader.Class.MonadReader r) f)
instance GHC.Base.Applicative (Data.Functor.HFunctor.Final.Final (Control.Monad.Reader.Class.MonadReader r) f)
instance Data.Functor.Bind.Class.Apply (Data.Functor.HFunctor.Final.Final (Control.Monad.Reader.Class.MonadReader r) f)
instance GHC.Base.Monad (Data.Functor.HFunctor.Final.Final (Control.Monad.Reader.Class.MonadReader r) f)
instance Control.Monad.Reader.Class.MonadReader r (Data.Functor.HFunctor.Final.Final (Control.Monad.Reader.Class.MonadReader r) f)
instance GHC.Base.Functor (Data.Functor.HFunctor.Final.Final Data.Functor.Alt.Alt f)
instance Data.Functor.Alt.Alt (Data.Functor.HFunctor.Final.Final Data.Functor.Alt.Alt f)
instance GHC.Base.Functor (Data.Functor.HFunctor.Final.Final Data.Functor.Plus.Plus f)
instance Data.Functor.Alt.Alt (Data.Functor.HFunctor.Final.Final Data.Functor.Plus.Plus f)
instance Data.Functor.Plus.Plus (Data.Functor.HFunctor.Final.Final Data.Functor.Plus.Plus f)
instance Data.Functor.HFunctor.Internal.HFunctor (Data.Functor.HFunctor.Final.Final c)
instance Data.Functor.HFunctor.Interpret (Data.Functor.HFunctor.Final.Final c)

module Data.Functor.Apply.Free

-- | One or more <tt>f</tt>s convolved with itself.
--   
--   Essentially:
--   
--   <pre>
--   <a>Ap1</a> f
--       ~ f                            -- one f
--     <a>:+:</a> (f `<tt>Day'</tt> f)          -- two f's
--     :+: (f `Day` f `Day` f)           -- three f's
--     :+: (f `Day` f `Day` f `Day` f)  -- four f's
--     :+: ...                          -- etc.
--   </pre>
--   
--   This is the free <a>Apply</a> --- Basically a "non-empty" <a>Ap</a>.
--   
--   The construction here is based on <a>Ap</a>, similar to now
--   <a>NonEmpty</a> is built on list.
data Ap1 :: (Type -> Type) -> Type -> Type
[Ap1] :: f a -> Ap f (a -> b) -> Ap1 f b

-- | An <a>Ap1</a> is a "non-empty" <a>Ap</a>; this function "forgets" the
--   non-empty property and turns it back into a normal <a>Ap</a>.
toAp :: Ap1 f ~> Ap f

-- | Convert an <a>Ap</a> into an <a>Ap1</a> if possible. If the <a>Ap</a>
--   was "empty", return the <a>Pure</a> value instead.
fromAp :: Ap f ~> (Identity :+: Ap1 f)

-- | Embed an <tt>f</tt> into <a>Ap1</a>.
liftAp1 :: f ~> Ap1 f

-- | Extract the <tt>f</tt> out of the <a>Ap1</a>.
--   
--   <pre>
--   <a>retractAp1</a> . <a>liftAp1</a> == id
--   </pre>
retractAp1 :: Apply f => Ap1 f ~> f

-- | Interpret an <tt><a>Ap</a> f</tt> into some <a>Apply</a> context
--   <tt>g</tt>.
runAp1 :: Apply g => (f ~> g) -> Ap1 f ~> g

-- | An <tt><a>Ap1</a> f</tt> is just a <tt><a>Day</a> f (<a>Ap</a>
--   f)</tt>. This brings provides the forward trip of the isomorphism.
ap1Day :: Ap1 f ~> Day f (Ap f)

-- | An <tt><a>Ap1</a> f</tt> is just a <tt><a>Day</a> f (<a>Ap</a>
--   f)</tt>. This brings provides the return trip of the isomorphism.
dayAp1 :: Functor f => Day f (Ap f) ~> Ap1 f
instance GHC.Base.Functor (Data.Functor.Apply.Free.Ap1 f)
instance Data.Functor.Bind.Class.Apply (Data.Functor.Apply.Free.Ap1 f)
instance Data.Functor.HFunctor.Internal.HFunctor Data.Functor.Apply.Free.Ap1
instance Data.Functor.HFunctor.Interpret Data.Functor.Apply.Free.Ap1


-- | This module provides tools for working with binary functor
--   combinators.
--   
--   <a>Data.Functor.HFunctor</a> deals with <i>single</i> functor
--   combinators (transforming a single functor). This module provides
--   tools for working with combinators that combine two functors
--   "together".
--   
--   The binary analog of <a>HFunctor</a> is <a>HBifunctor</a>: we can map
--   a structure-transforming function over both of the transformed
--   functors.
--   
--   The binary analog of <a>Interpret</a> is <a>Monoidal</a> (and
--   <a>Tensor</a>). If your combinator is an instance of <a>Monoidal</a>,
--   it means that you can "squish" both arguments together into an
--   <a>Interpret</a>. For example:
--   
--   <pre>
--   <a>toTM</a> :: (f <a>:*:</a> f) a -&gt; <a>ListF</a> f a
--   <a>toTM</a> :: <a>Comp</a> f f a -&gt; <a>Free</a> f a
--   <a>toTM</a> :: <a>Day</a> f f a -&gt; <a>Ap</a> f a
--   </pre>
module Data.Functor.Tensor

-- | A <a>HBifunctor</a> is like an <a>HFunctor</a>, but it enhances
--   <i>two</i> different functors instead of just one.
--   
--   Usually, it enhaces them "together" in some sort of combining way.
--   
--   This typeclass provides a uniform instance for "swapping out" or
--   "hoisting" the enhanced functors. We can hoist the first one with
--   <a>hleft</a>, the second one with <a>hright</a>, or both at the same
--   time with <a>hbimap</a>.
--   
--   For example, the <tt>f :*: g</tt> type gives us "both <tt>f</tt> and
--   <tt>g</tt>":
--   
--   <pre>
--   data (f <a>:*:</a> g) a = f a :*: g a
--   </pre>
--   
--   It combines both <tt>f</tt> and <tt>g</tt> into a unified structure
--   --- here, it does it by providing both <tt>f</tt> and <tt>g</tt>.
--   
--   The single law is:
--   
--   <pre>
--   <a>hbimap</a> <a>id</a> id == id
--   </pre>
--   
--   This ensures that <a>hleft</a>, <a>hright</a>, and <a>hbimap</a> do
--   not affect the structure that <tt>t</tt> adds on top of the underlying
--   functors.
class HBifunctor t

-- | Swap out the first transformed functor.
hleft :: HBifunctor t => (f ~> j) -> t f g ~> t j g

-- | Swap out the second transformed functor.
hright :: HBifunctor t => (g ~> k) -> t f g ~> t f k

-- | Swap out both transformed functors at the same time.
hbimap :: HBifunctor t => (f ~> j) -> (g ~> k) -> t f g ~> t j k

-- | A <a>HBifunctor</a> can be a <a>Tensor</a> if:
--   
--   <ol>
--   <li>There is some identity <tt>i</tt> where <tt>t i f</tt> is
--   equivalent to just <tt>f</tt>. That is, "enhancing" <tt>f</tt> with
--   <tt>t i</tt> does nothing.</li>
--   <li><tt>t</tt> is associative: <tt>f <tt>t</tt> (g <tt>t</tt> h)</tt>
--   is equivalent to <tt>(f <tt>t</tt> g) <tt>t</tt> h)</tt>.</li>
--   </ol>
--   
--   The methods in this class provide us useful ways of navigating a
--   <tt><a>Tensor</a> t</tt> with respect to this property.
--   
--   Realistically, there won't be any <a>Tensor</a> instances that are not
--   also <a>Monoidal</a> instances. The two classes are separated only to
--   help organize functionality into cleaner sub-divisions.
class HBifunctor t => Tensor t where {
    
    -- | The identity of <tt><a>Tensor</a> t</tt>. If you "combine" <tt>f</tt>
    --   with the identity, it leaves <tt>f</tt> unchanged.
    --   
    --   For example, the identity of <a>:*:</a> is <a>Proxy</a>. This is
    --   because
    --   
    --   <pre>
    --   (<a>Proxy</a> :*: f) a
    --   </pre>
    --   
    --   is equivalent to just
    --   
    --   <pre>
    --   f a
    --   </pre>
    --   
    --   <a>:*:</a>-ing <tt>f</tt> with <a>Proxy</a> gives you no additional
    --   structure.
    type family I t :: Type -> Type;
}
intro1 :: Tensor t => f ~> t f (I t)
intro2 :: Tensor t => g ~> t (I t) g
elim1 :: (Tensor t, Functor f) => t f (I t) ~> f
elim2 :: (Tensor t, Functor g) => t (I t) g ~> g
assoc :: (Tensor t, Functor f, Functor g, Functor h) => t f (t g h) ~> t (t f g) h
disassoc :: (Tensor t, Functor f, Functor g, Functor h) => t (t f g) h ~> t f (t g h)

-- | For some tensors <tt>t</tt>, you can represt the act of repeatedly
--   combining the same functor an arbitrary amount of times:
--   
--   <pre>
--   t f f                    -- 2 times
--   t f (t f f)              -- 3 times
--   t f (t f (t f f))        -- 4 times
--   t f (t f (t f (t f f)))  -- 5 times
--   </pre>
--   
--   Sometimes, we have a type that can <i>describe</i> this repeated
--   combination. For example, <tt><a>ListF</a> f</tt> is the type that
--   contains <tt>f</tt> <a>:*:</a>d with itself many number of times, and
--   <tt><a>Ap</a></tt> is the type that contains <tt>f</tt> <a>Day</a>d
--   with itself many number of times.
--   
--   <pre>
--   <a>ListF</a> [x, y]       == x <a>:*:</a> y
--   <a>ListF</a> [x, y, z]    == x <a>:*:</a> y <a>:*:</a> z
--   <a>ListF</a> [x, y, z, q] == x <a>:*:</a> y <a>:*:</a> z <a>:*:</a> q
--   </pre>
--   
--   This is convenient because it allows you to represent repeated
--   applications of <tt>t</tt> as a single data type.
--   
--   For example, <tt><a>Day</a> f f</tt> can be interpreted as "two
--   sequenced <tt>f</tt>s", allowing you to specify "I want exactly two
--   sequenced <tt>f</tt>s". If you want to specify "I want 0, 1, or many
--   <tt>f</tt>s sequenced after each other", then you can use
--   <tt><a>Ap</a> f</tt>.
--   
--   And, <tt>f <a>:*:</a> f</tt> can be interpreted as "a free selection
--   of two <tt>f</tt>s", allowing you to specify "I have to <tt>f</tt>s
--   that I can use". If you want to specify "I want 0, 1, or many
--   different <tt>f</tt>s that I can use", you can use <tt><a>ListF</a>
--   f</tt>.
--   
--   The <a>Monoidal</a> class unifies different such patterns. The
--   associated type <a>TM</a> is the "repeated aplications of <tt>t</tt>"
--   type.
--   
--   See documentation of <a>Data.Functor.Tensor</a> for information on how
--   to define instances of this typeclass.
class (Tensor t, Interpret (TM t)) => Monoidal t where {
    type family TM t :: (Type -> Type) -> Type -> Type;
}

-- | If <tt><a>TM</a> t f</tt> represents multiple applications of <tt>t
--   f</tt> with itself, then <tt>nilTM</tt> gives us "zero applications of
--   <tt>f</tt>".
--   
--   Note that <tt>t</tt> cannot be inferred from the type of <a>nilTM</a>,
--   so this function must always be called with -XTypeApplications:
--   
--   <pre>
--   <a>nilTM</a> @<a>Day</a> :: <a>Identity</a> <a>~&gt;</a> <a>Ap</a> f
--   <a>nilTM</a> @<a>Comp</a> :: <a>Identity</a> <a>~&gt;</a> <a>Free</a> f
--   <a>nilTM</a> @(<a>:*:</a>) :: <a>Proxy</a> <a>~&gt;</a> <a>ListF</a> f
--   </pre>
--   
--   Together with <a>consTM</a>, forms an inverse with <a>unconsTM</a>.
nilTM :: Monoidal t => I t ~> TM t f

-- | Prepend an application of <tt>t f</tt> to the front of a <tt><a>TM</a>
--   t f</tt>.
--   
--   Together with <a>nilTM</a>, forms an inverse with <a>unconsTM</a>.
consTM :: Monoidal t => t f (TM t f) ~> TM t f

-- | If a <tt><a>TM</a> t f</tt> represents multiple applications of <tt>t
--   f</tt> to itself, <a>unconsTM</a> lets us break it up into two
--   possibilities:
--   
--   <ol>
--   <li>The <tt><a>TM</a> t f</tt> had no applications of <tt>f</tt></li>
--   <li>The <tt><a>TM</a> t f</tt> had at least one application of
--   <tt>f</tt>; we return the "first" <tt>f</tt> applied to the rest of
--   the <tt>f</tt>s.</li>
--   </ol>
--   
--   Should form an inverse with <a>reconsTM</a>:
--   
--   <pre>
--   <a>reconsTM</a> . <a>unconsTM</a> == id
--   <a>unconsTM</a> . <a>reconsTM</a> == id
--   </pre>
--   
--   where <a>reconsTM</a> is <a>nilTM</a> on the left side of the
--   <a>:+:</a>, and <a>consTM</a> on the right side of the <a>:+:</a>.
unconsTM :: Monoidal t => TM t f ~> (I t :+: t f (TM t f))

-- | If a <tt><a>TM</a> t f</tt> represents multiple applications of <tt>t
--   f</tt> to itself, then we can also "append" two <tt><a>TM</a> t
--   f</tt>s applied to themselves into one giant <tt><a>TM</a> t f</tt>
--   containing all of the <tt>t f</tt>s.
appendTM :: Monoidal t => t (TM t f) (TM t f) ~> TM t f

-- | Convert a linked list of <tt>t f</tt>s applied to themselves (stored
--   in the <a>F</a> type) into <tt><a>TM</a> t f</tt>, the data type
--   representing multiple applications of <tt>t f</tt> to itself.
--   
--   <tt><a>F</a> i (<a>I</a> t)</tt> can be thought of as a "universal"
--   representation of multiple-applications-to-self, and <tt><a>TM</a>
--   t</tt> can be thought of as a tailor-made represenation for your
--   specific <tt><a>Tensor</a> t</tt>.
--   
--   <pre>
--   <a>fromF</a> . <a>toF</a> == id
--   <a>toF</a> . <a>fromF</a> == id
--   </pre>
--   
--   <a>fromF</a>, <a>toF</a>, and <a>appendF</a> are a way to completely
--   define a <a>Monoidal</a> instance; all other methods can be inferred
--   from them. In some cases, it can be easier to define these instead of
--   the other ones.
fromF :: Monoidal t => F t (I t) f ~> TM t f

-- | The inverse of <a>fromF</a>: convert a <tt><a>TM</a> t f</tt> into a
--   linked list of <tt>t f</tt>s applied to themselves. See <a>fromF</a>
--   for more information.
--   
--   <a>fromF</a>, <a>toF</a>, and <a>appendF</a> are a way to completely
--   define a <a>Monoidal</a> instance; all other methods can be inferred
--   from them. In some cases, it can be easier to define these instead of
--   the other ones.
toF :: Monoidal t => TM t f ~> F t (I t) f

-- | Append two linked lists of <tt>t f</tt> applied to itself together.
--   
--   <a>fromF</a>, <a>toF</a>, and <a>appendF</a> are a way to completely
--   define a <a>Monoidal</a> instance; all other methods can be inferred
--   from them. In some cases, it can be easier to define these instead of
--   the other ones.
appendF :: Monoidal t => t (F t (I t) f) (F t (I t) f) ~> F t (I t) f

-- | A version of <a>retract</a> that works for a <a>Tensor</a>. It
--   retracts <i>both</i> <tt>f</tt>s into a single <tt>f</tt>.
retractT :: (Monoidal t, C (TM t) f) => t f f ~> f

-- | A version of <a>interpret</a> that works for a <a>Tensor</a>. It takes
--   two interpreting functions, and interprets both joined functors one
--   after the other into <tt>h</tt>.
interpretT :: (Monoidal t, C (TM t) h) => (f ~> h) -> (g ~> h) -> t f g ~> h

-- | If we have an instance of <tt>t</tt>, we can generate an <tt>f</tt>
--   based on how it interacts with <tt>t</tt>.
--   
--   Specialized (and simplified), this type is:
--   
--   <pre>
--   <a>pureT</a> @<a>Day</a>   :: <a>Applicative</a> f =&gt; a -&gt; f a  -- <a>pure</a>
--   <a>pureT</a> @<a>Comp</a>  :: <a>Monad</a> f =&gt; a -&gt; f a    -- <a>return</a>
--   <a>pureT</a> @(<a>:*:</a>) :: <a>Plus</a> f =&gt; f a          -- <a>zero</a>
--   </pre>
pureT :: (Monoidal t, C (TM t) f) => I t ~> f

-- | Embed a direct application of <tt>f</tt> to itself into a
--   <tt><a>TM</a> t f</tt>.
toTM :: Monoidal t => t f f ~> TM t f

-- | A useful construction that works like a "linked list" of <tt>t f</tt>
--   applied to itself multiple times. That is, it contains <tt>t f f</tt>,
--   <tt>t f (t f f)</tt>, <tt>t f (t f (t f f))</tt>, etc.
--   
--   If <tt>t</tt> is <a>Monoidal</a>, then it means we can "collapse" this
--   linked list into some final type <tt><a>TM</a> t</tt> (<a>fromF</a>),
--   and also extract it back into a linked list (<a>toF</a>).
data F t i f a
Done :: i a -> F t i f a
More :: t f (F t i f) a -> F t i f a

-- | Infix alias for <a>getT</a>
(!$!) :: (Monoidal t, C (TM t) (Const b)) => (forall x. f x -> b) -> (forall x. g x -> b) -> t f g a -> b
infixr 5 !$!

-- | Convenient wrapper over <a>intro1</a> that lets us introduce an
--   arbitrary functor <tt>g</tt> to the right of an <tt>f</tt>.
inL :: forall t f g a. (Monoidal t, C (TM t) g) => f a -> t f g a

-- | Convenient wrapper over <a>intro2</a> that lets us introduce an
--   arbitrary functor <tt>f</tt> to the right of a <tt>g</tt>.
inR :: forall t f g a. (Monoidal t, C (TM t) f) => g a -> t f g a

-- | The inverse of <a>unconsTM</a>. Calls <a>nilTM</a> on the left (nil)
--   branch, and <a>consTM</a> on the right (cons) branch.
reconsTM :: forall t f. Monoidal t => (I t :+: t f (TM t f)) ~> TM t f

-- | Useful wrapper over <a>retractT</a> to allow you to directly extract
--   an <tt>a</tt> from a <tt>t f f a</tt>, if <tt>f</tt> is a valid
--   retraction from <tt>t</tt>, and <tt>f</tt> is an instance of
--   <a>Copointed</a>.
--   
--   Useful <tt>f</tt>s include <a>Identity</a> or related newtype wrappers
--   from base:
--   
--   <pre>
--   <a>extractT</a>
--       :: (<a>Monoidal</a> t, <a>C</a> (<a>TM</a> t) <a>Identity</a>)
--       =&gt; t <a>Identity</a> <a>Identity</a> a
--       -&gt; a
--   </pre>
extractT :: (Monoidal t, C (TM t) f, Copointed f) => t f f a -> a

-- | Useful wrapper over <a>interpret</a> to allow you to directly extract
--   a value <tt>b</tt> out of the <tt>t f a</tt>, if you can convert <tt>f
--   x</tt> into <tt>b</tt>.
--   
--   Note that depending on the constraints on the interpretation of
--   <tt>t</tt>, you may have extra constraints on <tt>b</tt>.
--   
--   <ul>
--   <li>If <tt><a>C</a> (<a>TM</a> t)</tt> is <tt>Unconstrained</tt>,
--   there are no constraints on <tt>b</tt></li>
--   <li>If <tt><a>C</a> (<a>TM</a> t)</tt> is <a>Apply</a>, <tt>b</tt>
--   needs to be an instance of <a>Semigroup</a></li>
--   <li>If <tt><a>C</a> (<a>TM</a> t)</tt> is <a>Applicative</a>,
--   <tt>b</tt> needs to be an instance of <a>Monoid</a></li>
--   </ul>
--   
--   For some constraints (like <a>Monad</a>), this will not be usable.
--   
--   <pre>
--   -- Return the length of either the list, or the Map, depending on which
--   --   one s in the <a>+</a>
--   length !*! length
--       :: ([] :+: Map Int) Char
--       -&gt; Int
--   
--   -- Return the length of both the list and the map, added together
--   (Sum . length) !*! (Sum . length)
--       :: Day [] (Map Int) Char
--       -&gt; Sum Int
--   </pre>
getT :: (Monoidal t, C (TM t) (Const b)) => (forall x. f x -> b) -> (forall x. g x -> b) -> t f g a -> b

-- | Infix alias for <a>interpretT</a>
(!*!) :: (Monoidal t, C (TM t) h) => (f ~> h) -> (g ~> h) -> t f g ~> h
infixr 5 !*!

-- | Useful wrapper over <a>getT</a> to allow you to collect a <tt>b</tt>
--   from all instances of <tt>f</tt> and <tt>g</tt> inside a <tt>t f g
--   a</tt>.
--   
--   This will work if <tt><a>C</a> t</tt> is <tt>Unconstrained</tt>,
--   <a>Apply</a>, or <a>Applicative</a>.
collectT :: (Monoidal t, C (TM t) (Const [b])) => (forall x. f x -> b) -> (forall x. g x -> b) -> t f g a -> [b]

-- | If we have <tt><a>Tensor</a> t</tt>, we can make a singleton <a>F</a>.
--   
--   We can also <a>retract</a> and <a>interpret</a> an <a>F</a> using its
--   <a>Interpret</a> instance.
injectF :: forall t f. Tensor t => f ~> F t (I t) f

-- | Useful newtype to allow us to derive an <a>HFunctor</a> instance from
--   any instance of <a>HBifunctor</a>, using -XDerivingVia.
--   
--   For example, because we have <tt>instance <a>HBifunctor</a>
--   <a>Day</a></tt>, we can write:
--   
--   <pre>
--   deriving via (<a>WrappedHBifunctor</a> <a>Day</a> f) instance <a>HFunctor</a> (<a>Day</a> f)
--   </pre>
--   
--   to give us an automatic <a>HFunctor</a> instance and save us some
--   work.
newtype WrappedHBifunctor t (f :: Type -> Type) (g :: Type -> Type) a
WrapHBifunctor :: t f g a -> WrappedHBifunctor t a
[unwrapHBifunctor] :: WrappedHBifunctor t a -> t f g a

-- | Form an <a>HFunctor</a> by applying the same input twice to an
--   <a>HBifunctor</a>.
data JoinT t f a
JoinT :: t f f a -> JoinT t f a
[runJoinT] :: JoinT t f a -> t f f a

-- | Form an <a>HBifunctor</a> by wrapping another <a>HBifunctor</a> in a
--   <a>HFunctor</a>.
newtype TannenT t p f g a
TannenT :: t (p f g) a -> TannenT t p f g a
[runTannenT] :: TannenT t p f g a -> t (p f g) a

-- | Form an <a>HBifunctor</a> over two <a>HFunctor</a>s.
newtype BiffT p s t f g a
BiffT :: p (s f) (t g) a -> BiffT p s t f g a
[runBiffT] :: BiffT p s t f g a -> p (s f) (t g) a
instance forall k1 k2 (i :: k2 -> *) (a :: k2) (t :: k1 -> (k2 -> *) -> k2 -> *) (f :: k1). (GHC.Show.Show (i a), GHC.Show.Show (t f (Data.Functor.Tensor.F t i f) a)) => GHC.Show.Show (Data.Functor.Tensor.F t i f a)
instance forall k1 k2 (i :: k2 -> *) (a :: k2) (t :: k1 -> (k2 -> *) -> k2 -> *) (f :: k1). (GHC.Read.Read (i a), GHC.Read.Read (t f (Data.Functor.Tensor.F t i f) a)) => GHC.Read.Read (Data.Functor.Tensor.F t i f a)
instance forall k (t :: k -> k -> * -> *) (f :: k). GHC.Base.Functor (t f f) => GHC.Base.Functor (Data.Functor.Tensor.JoinT t f)
instance forall k1 k2 k3 (t :: k3 -> * -> *) (p :: k1 -> k2 -> k3) (f :: k1) (g :: k2). GHC.Base.Functor (t (p f g)) => GHC.Base.Functor (Data.Functor.Tensor.TannenT t p f g)
instance (Data.Functor.HFunctor.Internal.HFunctor t, Data.Functor.HFunctor.Internal.HBifunctor p) => Data.Functor.HFunctor.Internal.HFunctor (Data.Functor.Tensor.TannenT t p f)
instance forall k1 k2 k3 k4 (p :: k3 -> k4 -> * -> *) (s :: k2 -> k3) (f :: k2) (t :: k1 -> k4) (g :: k1). GHC.Base.Functor (p (s f) (t g)) => GHC.Base.Functor (Data.Functor.Tensor.BiffT p s t f g)
instance (Data.Functor.HFunctor.Internal.HBifunctor p, Data.Functor.HFunctor.Internal.HFunctor s, Data.Functor.HFunctor.Internal.HFunctor t) => Data.Functor.HFunctor.Internal.HFunctor (Data.Functor.Tensor.BiffT p s t f)
instance (Data.Functor.HFunctor.Internal.HBifunctor p, Data.Functor.HFunctor.Internal.HFunctor s, Data.Functor.HFunctor.Internal.HFunctor t) => Data.Functor.HFunctor.Internal.HBifunctor (Data.Functor.Tensor.BiffT p s t)
instance (Data.Functor.HFunctor.Internal.HFunctor t, Data.Functor.HFunctor.Internal.HBifunctor p) => Data.Functor.HFunctor.Internal.HBifunctor (Data.Functor.Tensor.TannenT t p)
instance Data.Functor.HFunctor.Internal.HBifunctor t => Data.Functor.HFunctor.Internal.HFunctor (Data.Functor.Tensor.JoinT t)
instance (Data.Functor.Tensor.Monoidal t, i Data.Type.Equality.~ Data.Functor.Tensor.I t) => Data.Functor.HFunctor.Interpret (Data.Functor.Tensor.F t i)
instance Data.Functor.Tensor.Monoidal (GHC.Generics.:*:)
instance Data.Functor.Tensor.Monoidal Data.Functor.Day.Day
instance Data.Functor.Tensor.Monoidal (GHC.Generics.:+:)
instance Data.Functor.Tensor.Monoidal Control.Monad.Freer.Church.Comp
instance forall k (i :: * -> *) (t :: k -> (* -> *) -> * -> *) (f :: k). (GHC.Base.Functor i, GHC.Base.Functor (t f (Data.Functor.Tensor.F t i f))) => GHC.Base.Functor (Data.Functor.Tensor.F t i f)
instance Data.Functor.HFunctor.Internal.HBifunctor t => Data.Functor.HFunctor.Internal.HFunctor (Data.Functor.Tensor.F t i)
instance Data.Functor.Tensor.Tensor (GHC.Generics.:*:)
instance Data.Functor.Tensor.Tensor Data.Functor.Day.Day
instance Data.Functor.Tensor.Tensor (GHC.Generics.:+:)
instance Data.Functor.Tensor.Tensor Control.Monad.Freer.Church.Comp

module Data.Functor.Combinator

-- | A natural transformation from <tt>f</tt> to <tt>g</tt>.
type (~>) (f :: k -> Type) (g :: k -> Type) = forall (x :: k). () => f x -> g x
infixr 0 ~>

-- | An <a>HFunctor</a> can be thought of a unary "functor transformer" ---
--   a basic functor combinator. It takes a functor as input and returns a
--   functor as output.
--   
--   It "enhances" a functor with extra structure (sort of like how a monad
--   transformer enhances a <a>Monad</a> with extra structure).
--   
--   As a uniform inteface, we can "swap the underlying functor" (also
--   sometimes called "hoisting"). This is what <a>hmap</a> does: it lets
--   us swap out the <tt>f</tt> in a <tt>t f</tt> for a <tt>t g</tt>.
--   
--   For example, the free monad <a>Free</a> takes a <a>Functor</a> and
--   returns a new <a>Functor</a>. In the process, it provides a monadic
--   structure over <tt>f</tt>. <a>hmap</a> lets us turn a <tt><a>Free</a>
--   f</tt> into a <tt><a>Free</a> g</tt>: a monad built over <tt>f</tt>
--   can be turned into a monad built over <tt>g</tt>.
--   
--   For the ability to move in and out of the enhanced functor, see
--   <tt>Interpret</tt>.
class HFunctor t

-- | If we can turn an <tt>f</tt> into a <tt>g</tt>, then we can turn a
--   <tt>t f</tt> into a <tt>t g</tt>.
--   
--   It must be the case that
--   
--   <pre>
--   <a>hmap</a> <a>id</a> == id
--   </pre>
--   
--   Essentially, <tt><tt>t</tt> f</tt> adds some "extra structure" to
--   <tt>f</tt>. <a>hmap</a> must swap out the functor, <i>without
--   affecting the added structure</i>.
--   
--   For example, <tt><a>ListF</a> f a</tt> is essentially a list of <tt>f
--   a</tt>s. If we <a>hmap</a> to swap out the <tt>f a</tt>s for <tt>g
--   a</tt>s, then we must ensure that the "added structure" (here, the
--   number of items in the list) remains the same. So, <a>hmap</a> must
--   preserve the number of items in the list.
--   
--   The law <tt><a>hmap</a> <a>id</a> == id</tt> is a way of formalizing
--   this informal property.
hmap :: HFunctor t => (f ~> g) -> t f ~> t g

-- | An <a>Interpret</a> lets us move in and out of the "enhanced"
--   <a>Functor</a>.
--   
--   For example, <tt><a>Free</a> f</tt> is <tt>f</tt> enhanced with
--   monadic structure. We get:
--   
--   <pre>
--   <a>inject</a>    :: f a -&gt; <a>Free</a> f a
--   <a>interpret</a> :: <a>Monad</a> m =&gt; (forall x. f x -&gt; m x) -&gt; <a>Free</a> f a -&gt; m a
--   </pre>
--   
--   <a>inject</a> will let us use our <tt>f</tt> inside the enhanced
--   <tt><a>Free</a> f</tt>. <a>interpret</a> will let us "extract" the
--   <tt>f</tt> from a <tt><a>Free</a> f</tt> if we can give an
--   <i>interpreting function</i> that interprets <tt>f</tt> into some
--   target <a>Monad</a>.
--   
--   The type family <a>C</a> tells us the typeclass constraint of the
--   "target" functor. For <a>Free</a>, it is <a>Monad</a>, but for other
--   <a>Interpret</a> instances, we might have other constraints.
--   
--   We enforce that:
--   
--   <pre>
--   <a>interpret</a> id . <a>inject</a> == id
--   </pre>
--   
--   That is, if we lift a value into our structure, then immediately
--   interpret it out as itself, it should lave the value unchanged.
class HFunctor t => Interpret t where {
    
    -- | The constraint on the target context of <a>interpret</a>.
    type family C t :: (Type -> Type) -> Constraint;
}

-- | Lift an <tt>f</tt> into the enhanced <tt>t f</tt> structure. Analogous
--   to <a>lift</a> from <a>MonadTrans</a>.
inject :: Interpret t => f ~> t f

-- | Remove the <tt>f</tt> out of the enhanced <tt>t f</tt> structure,
--   provided that <tt>f</tt> satisfies the necessary constraints. If it
--   doesn't, it needs to be properly <a>interpret</a>ed out.
retract :: (Interpret t, C t f) => t f ~> f

-- | Given an "interpeting function" from <tt>f</tt> to <tt>g</tt>,
--   interpret the <tt>f</tt> out of the <tt>t f</tt> into a final context
--   <tt>g</tt>.
interpret :: (Interpret t, C t g) => (f ~> g) -> t f ~> g

-- | A convenient flipped version of <a>interpret</a>.
interpretFor :: (Interpret t, C t g) => t f a -> (f ~> g) -> g a

-- | Useful wrapper over <a>retract</a> to allow you to directly extract an
--   <tt>a</tt> from a <tt>t f a</tt>, if <tt>f</tt> is a valid retraction
--   from <tt>t</tt>, and <tt>f</tt> is an instance of <a>Copointed</a>.
--   
--   Useful <tt>f</tt>s include <tt>Identity</tt> or related newtype
--   wrappers from base:
--   
--   <pre>
--   <a>extractI</a>
--       :: (<a>Interpret</a> t, <a>C</a> t <tt>Identity</tt>)
--       =&gt; t <tt>Identity</tt> a
--       -&gt; a
--   </pre>
extractI :: (Interpret t, C t f, Copointed f) => t f a -> a

-- | Useful wrapper over <a>interpret</a> to allow you to directly extract
--   a value <tt>b</tt> out of the <tt>t f a</tt>, if you can convert <tt>f
--   x</tt> into <tt>b</tt>.
--   
--   Note that depending on the constraints on the interpretation of
--   <tt>t</tt>, you may have extra constraints on <tt>b</tt>.
--   
--   <ul>
--   <li>If <tt><a>C</a> t</tt> is <a>Unconstrained</a>, there are no
--   constraints on <tt>b</tt></li>
--   <li>If <tt><a>C</a> t</tt> is <a>Apply</a>, <tt>b</tt> needs to be an
--   instance of <a>Semigroup</a></li>
--   <li>If <tt><a>C</a> t</tt> is <a>Applicative</a>, <tt>b</tt> needs to
--   be an instance of <a>Monoid</a></li>
--   </ul>
--   
--   For some constraints (like <a>Monad</a>), this will not be usable.
--   
--   <pre>
--   -- get the length of the <tt>Map String</tt> in the <a>Step</a>.
--   <a>collectI</a> length
--        :: Step (Map String) Bool
--        -&gt; [Int]
--   </pre>
getI :: (Interpret t, C t (Const b)) => (forall x. f x -> b) -> t f a -> b

-- | Useful wrapper over <a>getI</a> to allow you to collect a <tt>b</tt>
--   from all instances of <tt>f</tt> inside a <tt>t f a</tt>.
--   
--   This will work if <tt><a>C</a> t</tt> is <a>Unconstrained</a>,
--   <a>Apply</a>, or <a>Applicative</a>.
--   
--   <pre>
--   -- get the lengths of all <tt>Map String</tt>s in the <a>Ap</a>.
--   <a>collectI</a> length
--        :: Ap (Map String) Bool
--        -&gt; [Int]
--   </pre>
collectI :: (Interpret t, C t (Const [b])) => (forall x. f x -> b) -> t f a -> [b]

-- | A <a>HBifunctor</a> is like an <a>HFunctor</a>, but it enhances
--   <i>two</i> different functors instead of just one.
--   
--   Usually, it enhaces them "together" in some sort of combining way.
--   
--   This typeclass provides a uniform instance for "swapping out" or
--   "hoisting" the enhanced functors. We can hoist the first one with
--   <a>hleft</a>, the second one with <a>hright</a>, or both at the same
--   time with <a>hbimap</a>.
--   
--   For example, the <tt>f :*: g</tt> type gives us "both <tt>f</tt> and
--   <tt>g</tt>":
--   
--   <pre>
--   data (f <a>:*:</a> g) a = f a :*: g a
--   </pre>
--   
--   It combines both <tt>f</tt> and <tt>g</tt> into a unified structure
--   --- here, it does it by providing both <tt>f</tt> and <tt>g</tt>.
--   
--   The single law is:
--   
--   <pre>
--   <a>hbimap</a> <a>id</a> id == id
--   </pre>
--   
--   This ensures that <a>hleft</a>, <a>hright</a>, and <a>hbimap</a> do
--   not affect the structure that <tt>t</tt> adds on top of the underlying
--   functors.
class HBifunctor t

-- | Swap out the first transformed functor.
hleft :: HBifunctor t => (f ~> j) -> t f g ~> t j g

-- | Swap out the second transformed functor.
hright :: HBifunctor t => (g ~> k) -> t f g ~> t f k

-- | Swap out both transformed functors at the same time.
hbimap :: HBifunctor t => (f ~> j) -> (g ~> k) -> t f g ~> t j k

-- | A <a>HBifunctor</a> can be a <a>Tensor</a> if:
--   
--   <ol>
--   <li>There is some identity <tt>i</tt> where <tt>t i f</tt> is
--   equivalent to just <tt>f</tt>. That is, "enhancing" <tt>f</tt> with
--   <tt>t i</tt> does nothing.</li>
--   <li><tt>t</tt> is associative: <tt>f <tt>t</tt> (g <tt>t</tt> h)</tt>
--   is equivalent to <tt>(f <tt>t</tt> g) <tt>t</tt> h)</tt>.</li>
--   </ol>
--   
--   The methods in this class provide us useful ways of navigating a
--   <tt><a>Tensor</a> t</tt> with respect to this property.
--   
--   Realistically, there won't be any <a>Tensor</a> instances that are not
--   also <a>Monoidal</a> instances. The two classes are separated only to
--   help organize functionality into cleaner sub-divisions.
class HBifunctor t => Tensor t where {
    
    -- | The identity of <tt><a>Tensor</a> t</tt>. If you "combine" <tt>f</tt>
    --   with the identity, it leaves <tt>f</tt> unchanged.
    --   
    --   For example, the identity of <a>:*:</a> is <a>Proxy</a>. This is
    --   because
    --   
    --   <pre>
    --   (<a>Proxy</a> :*: f) a
    --   </pre>
    --   
    --   is equivalent to just
    --   
    --   <pre>
    --   f a
    --   </pre>
    --   
    --   <a>:*:</a>-ing <tt>f</tt> with <a>Proxy</a> gives you no additional
    --   structure.
    type family I t :: Type -> Type;
}

-- | For some tensors <tt>t</tt>, you can represt the act of repeatedly
--   combining the same functor an arbitrary amount of times:
--   
--   <pre>
--   t f f                    -- 2 times
--   t f (t f f)              -- 3 times
--   t f (t f (t f f))        -- 4 times
--   t f (t f (t f (t f f)))  -- 5 times
--   </pre>
--   
--   Sometimes, we have a type that can <i>describe</i> this repeated
--   combination. For example, <tt><a>ListF</a> f</tt> is the type that
--   contains <tt>f</tt> <a>:*:</a>d with itself many number of times, and
--   <tt><a>Ap</a></tt> is the type that contains <tt>f</tt> <a>Day</a>d
--   with itself many number of times.
--   
--   <pre>
--   <a>ListF</a> [x, y]       == x <a>:*:</a> y
--   <a>ListF</a> [x, y, z]    == x <a>:*:</a> y <a>:*:</a> z
--   <a>ListF</a> [x, y, z, q] == x <a>:*:</a> y <a>:*:</a> z <a>:*:</a> q
--   </pre>
--   
--   This is convenient because it allows you to represent repeated
--   applications of <tt>t</tt> as a single data type.
--   
--   For example, <tt><a>Day</a> f f</tt> can be interpreted as "two
--   sequenced <tt>f</tt>s", allowing you to specify "I want exactly two
--   sequenced <tt>f</tt>s". If you want to specify "I want 0, 1, or many
--   <tt>f</tt>s sequenced after each other", then you can use
--   <tt><a>Ap</a> f</tt>.
--   
--   And, <tt>f <a>:*:</a> f</tt> can be interpreted as "a free selection
--   of two <tt>f</tt>s", allowing you to specify "I have to <tt>f</tt>s
--   that I can use". If you want to specify "I want 0, 1, or many
--   different <tt>f</tt>s that I can use", you can use <tt><a>ListF</a>
--   f</tt>.
--   
--   The <a>Monoidal</a> class unifies different such patterns. The
--   associated type <a>TM</a> is the "repeated aplications of <tt>t</tt>"
--   type.
--   
--   See documentation of <a>Data.Functor.Tensor</a> for information on how
--   to define instances of this typeclass.
class (Tensor t, Interpret (TM t)) => Monoidal t where {
    type family TM t :: (Type -> Type) -> Type -> Type;
}

-- | A version of <a>retract</a> that works for a <a>Tensor</a>. It
--   retracts <i>both</i> <tt>f</tt>s into a single <tt>f</tt>.
retractT :: (Monoidal t, C (TM t) f) => t f f ~> f

-- | A version of <a>interpret</a> that works for a <a>Tensor</a>. It takes
--   two interpreting functions, and interprets both joined functors one
--   after the other into <tt>h</tt>.
interpretT :: (Monoidal t, C (TM t) h) => (f ~> h) -> (g ~> h) -> t f g ~> h

-- | If we have an instance of <tt>t</tt>, we can generate an <tt>f</tt>
--   based on how it interacts with <tt>t</tt>.
--   
--   Specialized (and simplified), this type is:
--   
--   <pre>
--   <a>pureT</a> @<a>Day</a>   :: <a>Applicative</a> f =&gt; a -&gt; f a  -- <a>pure</a>
--   <a>pureT</a> @<a>Comp</a>  :: <a>Monad</a> f =&gt; a -&gt; f a    -- <a>return</a>
--   <a>pureT</a> @(<a>:*:</a>) :: <a>Plus</a> f =&gt; f a          -- <a>zero</a>
--   </pre>
pureT :: (Monoidal t, C (TM t) f) => I t ~> f

-- | Embed a direct application of <tt>f</tt> to itself into a
--   <tt><a>TM</a> t f</tt>.
toTM :: Monoidal t => t f f ~> TM t f

-- | Convenient wrapper over <a>intro1</a> that lets us introduce an
--   arbitrary functor <tt>g</tt> to the right of an <tt>f</tt>.
inL :: forall t f g a. (Monoidal t, C (TM t) g) => f a -> t f g a

-- | Convenient wrapper over <a>intro2</a> that lets us introduce an
--   arbitrary functor <tt>f</tt> to the right of a <tt>g</tt>.
inR :: forall t f g a. (Monoidal t, C (TM t) f) => g a -> t f g a

-- | Infix alias for <a>getT</a>
(!$!) :: (Monoidal t, C (TM t) (Const b)) => (forall x. f x -> b) -> (forall x. g x -> b) -> t f g a -> b
infixr 5 !$!

-- | Useful wrapper over <a>retractT</a> to allow you to directly extract
--   an <tt>a</tt> from a <tt>t f f a</tt>, if <tt>f</tt> is a valid
--   retraction from <tt>t</tt>, and <tt>f</tt> is an instance of
--   <a>Copointed</a>.
--   
--   Useful <tt>f</tt>s include <a>Identity</a> or related newtype wrappers
--   from base:
--   
--   <pre>
--   <a>extractT</a>
--       :: (<a>Monoidal</a> t, <a>C</a> (<a>TM</a> t) <a>Identity</a>)
--       =&gt; t <a>Identity</a> <a>Identity</a> a
--       -&gt; a
--   </pre>
extractT :: (Monoidal t, C (TM t) f, Copointed f) => t f f a -> a

-- | Useful wrapper over <a>interpret</a> to allow you to directly extract
--   a value <tt>b</tt> out of the <tt>t f a</tt>, if you can convert <tt>f
--   x</tt> into <tt>b</tt>.
--   
--   Note that depending on the constraints on the interpretation of
--   <tt>t</tt>, you may have extra constraints on <tt>b</tt>.
--   
--   <ul>
--   <li>If <tt><a>C</a> (<a>TM</a> t)</tt> is <tt>Unconstrained</tt>,
--   there are no constraints on <tt>b</tt></li>
--   <li>If <tt><a>C</a> (<a>TM</a> t)</tt> is <a>Apply</a>, <tt>b</tt>
--   needs to be an instance of <a>Semigroup</a></li>
--   <li>If <tt><a>C</a> (<a>TM</a> t)</tt> is <a>Applicative</a>,
--   <tt>b</tt> needs to be an instance of <a>Monoid</a></li>
--   </ul>
--   
--   For some constraints (like <a>Monad</a>), this will not be usable.
--   
--   <pre>
--   -- Return the length of either the list, or the Map, depending on which
--   --   one s in the <a>+</a>
--   length !*! length
--       :: ([] :+: Map Int) Char
--       -&gt; Int
--   
--   -- Return the length of both the list and the map, added together
--   (Sum . length) !*! (Sum . length)
--       :: Day [] (Map Int) Char
--       -&gt; Sum Int
--   </pre>
getT :: (Monoidal t, C (TM t) (Const b)) => (forall x. f x -> b) -> (forall x. g x -> b) -> t f g a -> b

-- | Infix alias for <a>interpretT</a>
(!*!) :: (Monoidal t, C (TM t) h) => (f ~> h) -> (g ~> h) -> t f g ~> h
infixr 5 !*!

-- | Useful wrapper over <a>getT</a> to allow you to collect a <tt>b</tt>
--   from all instances of <tt>f</tt> and <tt>g</tt> inside a <tt>t f g
--   a</tt>.
--   
--   This will work if <tt><a>C</a> t</tt> is <tt>Unconstrained</tt>,
--   <a>Apply</a>, or <a>Applicative</a>.
collectT :: (Monoidal t, C (TM t) (Const [b])) => (forall x. f x -> b) -> (forall x. g x -> b) -> t f g a -> [b]

-- | A covariant <a>Functor</a> suitable for Yoneda reduction
data Coyoneda (f :: Type -> Type) a
[Coyoneda] :: forall (f :: Type -> Type) a b. () => (b -> a) -> f b -> Coyoneda f a

-- | A list of <tt>f a</tt>s. Can be used to describe a product of many
--   different values of type <tt>f a</tt>.
--   
--   This is the Free <a>Plus</a>.
newtype ListF f a
ListF :: [f a] -> ListF f a
[runListF] :: ListF f a -> [f a]

-- | A non-empty list of <tt>f a</tt>s. Can be used to describe a product
--   between many different possible values of type <tt>f a</tt>.
--   
--   Essentially:
--   
--   <pre>
--   <a>NonEmptyF</a> f
--       ~ f                          -- one f
--     <a>:+:</a> (f <a>:*:</a> f)              -- two f's
--     :+: (f :*: f :*: f)            -- three f's
--     :+: (f :*: f :*: f :*: f)      -- four f's
--     :+: ...                        -- etc.
--   </pre>
--   
--   This is the Free <a>Plus</a>.
newtype NonEmptyF f a
NonEmptyF :: NonEmpty (f a) -> NonEmptyF f a
[runNonEmptyF] :: NonEmptyF f a -> NonEmpty (f a)

-- | A maybe <tt>f a</tt>.
--   
--   Can be useful for describing a "an <tt>f a</tt> that may or may not be
--   there".
--   
--   This is the free structure for a "fail"-like typeclass that only has
--   <tt>zero :: f a</tt>.
newtype MaybeF f a
MaybeF :: Maybe (f a) -> MaybeF f a
[runMaybeF] :: MaybeF f a -> Maybe (f a)

-- | The free <a>Applicative</a> for a <a>Functor</a> <tt>f</tt>.
data Ap (f :: Type -> Type) a

-- | One or more <tt>f</tt>s convolved with itself.
--   
--   Essentially:
--   
--   <pre>
--   <a>Ap1</a> f
--       ~ f                            -- one f
--     <a>:+:</a> (f `<tt>Day'</tt> f)          -- two f's
--     :+: (f `Day` f `Day` f)           -- three f's
--     :+: (f `Day` f `Day` f `Day` f)  -- four f's
--     :+: ...                          -- etc.
--   </pre>
--   
--   This is the free <a>Apply</a> --- Basically a "non-empty" <a>Ap</a>.
--   
--   The construction here is based on <a>Ap</a>, similar to now
--   <a>NonEmpty</a> is built on list.
data Ap1 :: (Type -> Type) -> Type -> Type
data Alt (f :: Type -> Type) a

-- | A <tt><a>Free</a> f</tt> is <tt>f</tt> enhanced with "sequential
--   binding" capabilities. It allows you to sequence multiple <tt>f</tt>s
--   one after the other, and also to determine "what <tt>f</tt> to
--   sequence" based on the result of the computation so far.
--   
--   Essentially, you can think of this as "giving <tt>f</tt> a
--   <a>Monad</a> instance", with all that that entails (<a>return</a>,
--   <a>&gt;&gt;=</a>, etc.).
--   
--   Lift <tt>f</tt> into it with <tt><a>inject</a> :: f a -&gt; Free f
--   a</tt>. When you finally want to "use" it, you can interpret it into
--   any monadic context:
--   
--   <pre>
--   <a>interpret</a>
--       :: <a>Monad</a> g
--       =&gt; (forall x. f x -&gt; g x)
--       -&gt; <a>Free</a> f a
--       -&gt; g a
--   </pre>
--   
--   Under the hood, this is the Church-encoded Freer monad. It's
--   <a>Free</a>, or <a>F</a>, but in a way that is compatible with
--   <a>HFunctor</a> and <a>Interpret</a>.
data Free f a

-- | An <tt>f a</tt>, along with a <a>Natural</a> index.
--   
--   <pre>
--   Step f a ~ (<a>Natural</a>, f a)
--   Step f   ~ ((,) <a>Natural</a>) <a>:.:</a> f       -- functor composition
--   </pre>
--   
--   It is the fixed point of applications of <a>:+:</a> (functor sums).
--   
--   Intuitively, in an infinite <tt>f :+: f :+: f :+: f ...</tt>, you have
--   exactly one <tt>f</tt> <i>somewhere</i>. A <tt><a>Step</a> f a</tt>
--   has that <tt>f</tt>, with a <a>Natural</a> giving you "where" the
--   <tt>f</tt> is in the long chain.
--   
--   <a>interpret</a>ing it requires no constraint on the target context.
data Step f a
Step :: Natural -> f a -> Step f a
[stepPos] :: Step f a -> Natural
[stepVal] :: Step f a -> f a

-- | A non-empty map of <a>Natural</a> to <tt>f a</tt>. Basically, contains
--   multiple <tt>f a</tt>s, each at a given <a>Natural</a> index.
--   
--   <pre>
--   Steps f a ~ <a>Map</a> <a>Natural</a> (f a)
--   Steps f   ~ <a>Map</a> <a>Natural</a> <a>:.:</a> f       -- functor composition
--   </pre>
--   
--   It is the fixed point of applications of <a>TheseT</a>.
--   
--   Intuitively, in an infinite <tt>f `TheseT` f `TheseT` f `TheseT` f
--   ...</tt>, each of those infinite positions may have an <tt>f</tt> in
--   them. However, because of the at-least-one nature of <a>TheseT</a>, we
--   know we have at least one f at one position <i>somewhere</i>.
--   
--   A <tt><a>Steps</a> f a</tt> has potentially many <tt>f</tt>s, each
--   stored at a different <a>Natural</a> position, with the guaruntee that
--   at least one <tt>f</tt> exists.
--   
--   <a>interpret</a>ing it requires at least an <a>Alt</a> instance in the
--   target context, since we have to handle potentially more than one
--   <tt>f</tt>. However, we don't fully need <a>Plus</a>, since we know we
--   always have at least one <tt>f</tt>.
newtype Steps f a
Steps :: NEMap Natural (f a) -> Steps f a
[getSteps] :: Steps f a -> NEMap Natural (f a)

-- | The Day convolution of two covariant functors.
data Day (f :: Type -> Type) (g :: Type -> Type) a
[Day] :: forall (f :: Type -> Type) (g :: Type -> Type) a b c. () => f b -> g c -> (b -> c -> a) -> Day f g a

-- | Products: encode multiple arguments to constructors
data (:*:) (f :: k -> Type) (g :: k -> Type) (p :: k) :: forall k. () => k -> Type -> k -> Type -> k -> Type
(:*:) :: f p -> g p -> (:*:)
infixr 6 :*:
infixr 6 :*:

-- | Sums: encode choice between constructors
data (:+:) (f :: k -> Type) (g :: k -> Type) (p :: k) :: forall k. () => k -> Type -> k -> Type -> k -> Type
L1 :: f p -> (:+:)
R1 :: g p -> (:+:)
infixr 5 :+:

-- | A <tt>These f g a</tt> has either an <tt>f a</tt>, a <tt>g a</tt>, or
--   both.
--   
--   This is re-defined here from the <i>these</i> package, to avoid the
--   high dependency footprint.
data These1 f g a
This1 :: f a -> These1 f g a
That1 :: g a -> These1 f g a
These1 :: f a -> g a -> These1 f g a

-- | Functor composition. <tt><a>Comp</a> f g a</tt> is equivalent to <tt>f
--   (g a)</tt>, and the <a>Comp</a> pattern synonym is a way of getting
--   the <tt>f (g a)</tt> in a <tt><a>Comp</a> f g a</tt>.
--   
--   For example, <tt><a>Maybe</a> (<a>IO</a> <a>Bool</a>)</tt> is
--   <tt><a>Comp</a> <a>Maybe</a> <a>IO</a> <a>Bool</a></tt>.
--   
--   This is mostly useful for its typeclass instances: in particular,
--   <a>Functor</a>, <a>Applicative</a>, <a>HBifunctor</a>, and
--   <a>Monoidal</a>.
--   
--   This is essentially a version of <a>:.:</a> and <a>Compose</a> that
--   allows for an <a>HBifunctor</a> instance.
--   
--   It is slightly less performant. Using <tt><a>comp</a> .
--   <a>unComp</a></tt> every once in a while will concretize a <a>Comp</a>
--   value (if you have <tt><a>Functor</a> f</tt>) and remove some
--   indirection if you have a lot of chained operations.
--   
--   The "free monoid" over <a>Comp</a> is <a>Free</a>.
data Comp f g a

-- | Pattern match on and construct a <tt><a>Comp</a> f g a</tt> as if it
--   were <tt>f (g a)</tt>.
pattern Comp :: Functor f => f (g a) -> Comp f g a

-- | A simple way to inject/reject into any eventual typeclass.
--   
--   In a way, this is the "ultimate" <a>Interpret</a> instance. You can
--   use this to inject an <tt>f</tt> into a free structure of any
--   typeclass. If you want <tt>f</tt> to have a <a>Monad</a> instance, for
--   example, just use
--   
--   <pre>
--   <a>inject</a> :: f a -&gt; <a>Final</a> <a>Monad</a> f a
--   </pre>
--   
--   When you want to eventually interpret out the data, use:
--   
--   <pre>
--   <a>interpret</a> :: (f <a>~&gt;</a> g) -&gt; <a>Final</a> c f a -&gt; g a
--   </pre>
--   
--   Essentially, <tt><a>Final</a> c</tt> is the "free c". <tt><a>Final</a>
--   <a>Monad</a></tt> is the free <a>Monad</a>, etc.
--   
--   Note that this doesn't have instances for <i>all</i> the typeclasses
--   you could lift things into; you probably have to define your own if
--   you want to use <tt><a>Final</a> c</tt> as an <i>instance</i> of
--   <tt>c</tt> (using <a>liftFinal0</a>, <a>liftFinal1</a>,
--   <a>liftFinal2</a> for help).
newtype Final c f a
Final :: (forall g. c g => (forall x. f x -> g x) -> g a) -> Final c f a
[runFinal] :: Final c f a -> forall g. c g => (forall x. f x -> g x) -> g a

-- | A typeclass associating a free structure with the typeclass it is free
--   on.
--   
--   This essentially lists instances of <a>Interpret</a> where a "trip"
--   through <a>Final</a> will leave it unchanged.
--   
--   <pre>
--   <a>fromFree</a> . <a>toFree</a> == id
--   <a>toFree</a> . <a>fromFree</a> == id
--   </pre>
--   
--   This can be useful because <a>Final</a> doesn't have a concrete
--   structure that you can pattern match on and inspect, but <tt>t</tt>
--   might. This lets you work on a concrete structure if you desire.
class Interpret t => FreeOf c t | t -> c
fromFree :: FreeOf c t => t f ~> Final c f
toFree :: (FreeOf c t, Functor f) => Final c f ~> t f
fromFree :: (FreeOf c t, C t (Final c f)) => t f ~> Final c f
toFree :: (FreeOf c t, c (t f)) => Final c f ~> t f
