-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/mstksg/functor-combinators#readme</a>
@package functor-combinators
@version 0.1.0.0

module Control.Applicative.ListF

-- | A list of <tt>f a</tt>s.
--   
--   This is the Free <a>Plus</a>.
newtype ListF f a
ListF :: [f a] -> ListF f a
[runListF] :: ListF f a -> [f a]

-- | A non-empty list of <tt>f a</tt>s.
--   
--   This is the Free <a>Plus</a>.
newtype NonEmptyF f a
NonEmptyF :: NonEmpty (f a) -> NonEmptyF f a
[runNonEmptyF] :: NonEmptyF f a -> NonEmpty (f a)
instance GHC.Base.Functor f => GHC.Base.Functor (Control.Applicative.ListF.NonEmptyF f)
instance GHC.Classes.Ord (f a) => GHC.Classes.Ord (Control.Applicative.ListF.NonEmptyF f a)
instance GHC.Classes.Eq (f a) => GHC.Classes.Eq (Control.Applicative.ListF.NonEmptyF f a)
instance GHC.Show.Show (f a) => GHC.Show.Show (Control.Applicative.ListF.NonEmptyF f a)
instance GHC.Base.Functor f => GHC.Base.Functor (Control.Applicative.ListF.ListF f)
instance GHC.Classes.Ord (f a) => GHC.Classes.Ord (Control.Applicative.ListF.ListF f a)
instance GHC.Classes.Eq (f a) => GHC.Classes.Eq (Control.Applicative.ListF.ListF f a)
instance GHC.Show.Show (f a) => GHC.Show.Show (Control.Applicative.ListF.ListF f a)
instance GHC.Base.Applicative f => GHC.Base.Applicative (Control.Applicative.ListF.NonEmptyF f)
instance GHC.Base.Functor f => Data.Functor.Alt.Alt (Control.Applicative.ListF.NonEmptyF f)
instance GHC.Base.Applicative f => GHC.Base.Applicative (Control.Applicative.ListF.ListF f)
instance GHC.Base.Functor f => Data.Functor.Alt.Alt (Control.Applicative.ListF.ListF f)
instance GHC.Base.Functor f => Data.Functor.Plus.Plus (Control.Applicative.ListF.ListF f)

module Control.Applicative.Step

-- | The fixed point of applications of <tt>:+:</tt> (functor sums).
--   
--   Intuitively, in an infinite <tt>f <tt>:+:</tt> f <tt>:+:</tt> f
--   <tt>:+:</tt> f ...</tt>, you have exactly one <tt>f</tt>
--   <i>somewhere</i>. A <tt><a>Step</a> f a</tt> has that <tt>f</tt>, with
--   a <a>Natural</a> giving you "where" the <tt>f</tt> is in the long
--   chain.
--   
--   <tt>interpret</tt>ing it requires no constraint on the target context.
data Step f a
Step :: Natural -> f a -> Step f a
[stepPos] :: Step f a -> Natural
[stepVal] :: Step f a -> f a

-- | The fixed point of applications of <tt>TheseT</tt>.
--   
--   Intuitively, in an infinite <tt>f <tt>TheseT</tt> f <tt>TheseT</tt> f
--   <tt>TheseT</tt> f ...</tt>, each of those infinite positions may have
--   an <tt>f</tt> in them. However, because of the at-least-one nature of
--   <tt>TheseT</tt>, we know we have at least one f at one position
--   <i>somewhere</i>.
--   
--   A <tt><a>Steps</a> f a</tt> has potentially many <tt>f</tt>s, each
--   stored at a different <a>Natural</a> position, with the guaruntee that
--   at least one <tt>f</tt> exists.
--   
--   <tt>interpret</tt>ing it requires at least an <a>Alt</a> instance in
--   the target context, since we have to handle potentially more than one
--   <tt>f</tt>. However, we don't fully need <tt>Plus</tt>, since we know
--   we always have at least one <tt>f</tt>.
newtype Steps f a
Steps :: NEMap Natural (f a) -> Steps f a
[getSteps] :: Steps f a -> NEMap Natural (f a)

-- | The identity functor of <tt>:+:</tt> (and also <tt>TheseT</tt>)
data VoidT a

-- | We have a natural transformation between <a>VoidT</a> and any other
--   functor <tt>f</tt> with no constraints.
absurdT :: VoidT a -> f a
instance Data.Traversable.Traversable f => Data.Traversable.Traversable (Control.Applicative.Step.Steps f)
instance Data.Foldable.Foldable f => Data.Foldable.Foldable (Control.Applicative.Step.Steps f)
instance GHC.Base.Functor f => GHC.Base.Functor (Control.Applicative.Step.Steps f)
instance GHC.Classes.Ord (f a) => GHC.Classes.Ord (Control.Applicative.Step.Steps f a)
instance GHC.Classes.Eq (f a) => GHC.Classes.Eq (Control.Applicative.Step.Steps f a)
instance GHC.Show.Show (f a) => GHC.Show.Show (Control.Applicative.Step.Steps f a)
instance GHC.Base.Functor Control.Applicative.Step.VoidT
instance GHC.Classes.Ord (Control.Applicative.Step.VoidT a)
instance GHC.Classes.Eq (Control.Applicative.Step.VoidT a)
instance GHC.Show.Show (Control.Applicative.Step.VoidT a)
instance Data.Traversable.Traversable f => Data.Traversable.Traversable (Control.Applicative.Step.Step f)
instance Data.Foldable.Foldable f => Data.Foldable.Foldable (Control.Applicative.Step.Step f)
instance GHC.Base.Functor f => GHC.Base.Functor (Control.Applicative.Step.Step f)
instance GHC.Classes.Ord (f a) => GHC.Classes.Ord (Control.Applicative.Step.Step f a)
instance GHC.Classes.Eq (f a) => GHC.Classes.Eq (Control.Applicative.Step.Step f a)
instance GHC.Show.Show (f a) => GHC.Show.Show (Control.Applicative.Step.Step f a)
instance Data.Semigroup.Foldable.Class.Foldable1 f => Data.Semigroup.Foldable.Class.Foldable1 (Control.Applicative.Step.Steps f)
instance Data.Semigroup.Traversable.Class.Traversable1 f => Data.Semigroup.Traversable.Class.Traversable1 (Control.Applicative.Step.Steps f)
instance GHC.Base.Functor f => Data.Functor.Alt.Alt (Control.Applicative.Step.Steps f)
instance GHC.Base.Applicative f => GHC.Base.Applicative (Control.Applicative.Step.Step f)
instance Data.Semigroup.Foldable.Class.Foldable1 f => Data.Semigroup.Foldable.Class.Foldable1 (Control.Applicative.Step.Step f)
instance Data.Semigroup.Traversable.Class.Traversable1 f => Data.Semigroup.Traversable.Class.Traversable1 (Control.Applicative.Step.Step f)

module Control.Monad.Freer.Church

-- | Church-encoded Freer monad
newtype Free f a
Free :: (forall r. (a -> r) -> (forall s. f s -> (s -> r) -> r) -> r) -> Free f a
[runFree] :: Free f a -> forall r. (a -> r) -> (forall s. f s -> (s -> r) -> r) -> r
instance GHC.Base.Functor (Control.Monad.Freer.Church.Free f)
instance GHC.Base.Applicative (Control.Monad.Freer.Church.Free f)
instance GHC.Base.Monad (Control.Monad.Freer.Church.Free f)
instance Control.Monad.Free.Class.MonadFree f (Control.Monad.Freer.Church.Free f)

module Data.Functor.HFunctor

-- | An <a>HFunctor</a> can be thought of a unary "functor transformer" ---
--   a basic functor combinator. It takes a functor as input and returns a
--   functor as output.
--   
--   It "enhances" a functor with extra structure (sort of like how a monad
--   transformer enhances a <a>Monad</a> with extra structure).
--   
--   As a uniform inteface, we can "swap the underlying functor" (also
--   sometimes called "hoisting"). This is what <a>hmap</a> does: it lets
--   us swap out the <tt>f</tt> in a <tt>t f</tt> for a <tt>t g</tt>.
--   
--   For example, the free monad <a>Free</a> takes a <a>Functor</a> and
--   returns a new <a>Functor</a>. In the process, it provides a monadic
--   structure over <tt>f</tt>. <a>hmap</a> lets us turn a <tt><a>Free</a>
--   f</tt> into a <tt><a>Free</a> g</tt>: a monad built over <tt>f</tt>
--   can be turned into a monad built over <tt>g</tt>.
--   
--   For the ability to move in and out of the enhanced functor, see
--   <tt>Interpret</tt>.
class HFunctor t

-- | If we can turn an <tt>f</tt> into a <tt>g</tt>, then we can turn a
--   <tt>t f</tt> into a <tt>t g</tt>.
--   
--   It must be the case that
--   
--   <pre>
--   <a>hmap</a> <a>id</a> == id
--   </pre>
--   
--   Essentially, <tt><tt>t</tt> f</tt> adds some "extra structure" to
--   <tt>f</tt>. <a>hmap</a> must swap out the functor, <i>without
--   affecting the added structure</i>.
--   
--   For example, <tt><a>ListF</a> f a</tt> is essentially a list of <tt>f
--   a</tt>s. If we <a>hmap</a> to swap out the <tt>f a</tt>s for <tt>g
--   a</tt>s, then we must ensure that the "added structure" (here, the
--   number of items in the list) remains the same. So, <a>hmap</a> must
--   preserve the number of items in the list.
--   
--   The law <tt><a>hmap</a> <a>id</a> == id</tt> is a way of formalizing
--   this informal property.
hmap :: HFunctor t => (f ~> g) -> t f ~> t g

-- | An <a>Interpret</a> lets us move in and out of the "enhanced"
--   <a>Functor</a>.
--   
--   For example, <tt><a>Free</a> f</tt> is <tt>f</tt> enhanced with
--   monadic structure. We get:
--   
--   <pre>
--   <a>inject</a>    :: f a -&gt; <a>Free</a> f a
--   <a>interpret</a> :: <a>Monad</a> m =&gt; (forall x. f x -&gt; m x) -&gt; <a>Free</a> f a -&gt; m a
--   </pre>
--   
--   <a>inject</a> will let us use our <tt>f</tt> inside the enhanced
--   <tt><a>Free</a> f</tt>. <a>interpret</a> will let us "extract" the
--   <tt>f</tt> from a <tt><a>Free</a> f</tt> if we can give an
--   <i>interpreting function</i> that interprets <tt>f</tt> into some
--   target <a>Monad</a>.
--   
--   The type family <a>C</a> tells us the typeclass constraint of the
--   "target" functor. For <a>Free</a>, it is <a>Monad</a>, but for other
--   <a>Interpret</a> instances, we might have other constraints.
--   
--   We enforce that:
--   
--   <pre>
--   <a>interpret</a> id . <a>inject</a> == id
--   </pre>
--   
--   That is, if we lift a value into our structure, then immediately
--   interpret it out as itself, it should lave the value unchanged.
class HFunctor t => Interpret t where {
    
    -- | The constraint on the target context of <a>interpret</a>.
    type family C t :: (Type -> Type) -> Constraint;
}

-- | Lift an <tt>f</tt> into the enhanced <tt>t f</tt> structure. Analogous
--   to <a>lift</a> from <a>MonadTrans</a>.
inject :: Interpret t => f ~> t f

-- | Remove the <tt>f</tt> out of the enhanced <tt>t f</tt> structure,
--   provided that <tt>f</tt> satisfies the necessary constraints. If it
--   doesn't, it needs to be properly <a>interpret</a>ed out.
retract :: (Interpret t, C t f) => t f ~> f

-- | Given an "interpeting function" from <tt>f</tt> to <tt>g</tt>,
--   interpret the <tt>f</tt> out of the <tt>t f</tt> into a final context
--   <tt>g</tt>.
interpret :: (Interpret t, C t g) => (f ~> g) -> t f ~> g
class Trivial c
class (c a, d a) => AndC c d a
instance forall k (c :: k -> GHC.Types.Constraint) (a :: k) (d :: k -> GHC.Types.Constraint). (c a, d a) => Data.Functor.HFunctor.AndC c d a
instance (Data.Functor.HFunctor.Interpret s, Data.Functor.HFunctor.Interpret t) => Data.Functor.HFunctor.Interpret (Control.Monad.Trans.Compose.ComposeT s t)
instance Data.Functor.HFunctor.Interpret Control.Applicative.Step.Step
instance forall k (c :: k). Data.Functor.HFunctor.Trivial c
instance Data.Functor.HFunctor.Interpret Control.Monad.Trans.Identity.IdentityT
instance Data.Functor.HFunctor.Interpret Control.Applicative.Backwards.Backwards
instance Data.Functor.HFunctor.Interpret Data.Functor.Reverse.Reverse
instance Data.Functor.HFunctor.Interpret Data.Functor.Coyoneda.Coyoneda
instance Data.Functor.HFunctor.Interpret Control.Applicative.Free.Ap
instance Data.Functor.HFunctor.Interpret Control.Applicative.ListF.ListF
instance Data.Functor.HFunctor.Interpret Control.Applicative.ListF.NonEmptyF
instance Data.Functor.HFunctor.Interpret Control.Applicative.Step.Steps
instance Data.Functor.HFunctor.Interpret Control.Alternative.Free.Alt
instance Data.Functor.HFunctor.Interpret Control.Monad.Freer.Church.Free
instance Data.Functor.HFunctor.Interpret Control.Applicative.Free.Final.Ap
instance Data.Functor.HFunctor.Interpret Control.Applicative.Free.Fast.Ap
instance Data.Functor.HFunctor.Interpret Control.Applicative.Lift.Lift
instance Data.Functor.HFunctor.Interpret (Control.Monad.Trans.Reader.ReaderT r)

module Data.Functor.HFunctor.Final

-- | A simple way to inject/reject into any eventual typeclass.
--   Essentially, <tt><a>Final</a> c</tt> is the "free c". <tt><a>Final</a>
--   <a>Monad</a></tt> is the free <a>Monad</a>, etc.
--   
--   Useful for lifting a functor <tt>f</tt> into arbitrary structure given
--   by a typeclass.
--   
--   Note that this doesn't have instances for all the typeclasses; you
--   probably have to define your own if you want to use <tt><a>Final</a>
--   c</tt> as an <i>instance</i> of <tt>c</tt> (using <a>liftFinal0</a>,
--   <a>liftFinal1</a>, <a>liftFinal2</a> for help). This is mostly meant
--   to be usable as a final <a>Interpret</a>, with
--   
--   <pre>
--   <a>inject</a>    :: f a -&gt; <a>Final</a> c f a
--   <a>interpret</a> :: (f <a>~&gt;</a> g) -&gt; <a>Final</a> c f a -&gt; g a
--   </pre>
newtype Final c f a
Final :: (forall g. c g => (forall x. f x -> g x) -> g a) -> Final c f a
[runFinal] :: Final c f a -> forall g. c g => (forall x. f x -> g x) -> g a

-- | <a>Concretize</a> a <a>Final</a>.
fromFinal :: (Interpret t, c (t f)) => Final c f ~> t f

-- | <a>Finalize</a> an <a>Interpret</a> instance.
--   
--   <pre>
--   toFinal :: <tt>Coyoneda</tt> f <a>~&gt;</a> <a>Final</a> <a>Functor</a> f
--   toFinal :: <tt>Ap</tt> f <a>~&gt;</a> <a>Final</a> <a>Applicative</a> f
--   toFinal :: <a>Alt</a> f <a>~&gt;</a> <a>Final</a> <a>Alternative</a> f
--   toFinal :: <a>Free</a> f <a>~&gt;</a> <a>Final</a> <a>Monad</a> f
--   toFinal :: <tt>Lift</tt> f <a>~&gt;</a> <a>Final</a> <a>Pointed</a> f
--   toFinal :: <tt>ListF</tt> f <a>~&gt;</a> <a>Final</a> <a>Plus</a> f
--   </pre>
--   
--   Note that the instance of <tt>c</tt> for <tt><a>Final</a> c</tt> must
--   be defined.
--   
--   Should form an isomorphism with <a>fromFinal</a>
toFinal :: (Interpret t, C t (Final c f)) => t f ~> Final c f
hoistFinalC :: (forall g x. (c g => g x) -> d g => g x) -> Final c f a -> Final d f a

-- | Lift an action into a <a>Final</a>.
liftFinal0 :: (forall g. c g => g a) -> Final c f a

-- | Map the action in a <a>Final</a>.
liftFinal1 :: (forall g. c g => g a -> g b) -> Final c f a -> Final c f b

-- | Merge two <a>Final</a> actions.
liftFinal2 :: (forall g. c g => g a -> g b -> g d) -> Final c f a -> Final c f b -> Final c f d
instance GHC.Base.Functor (Data.Functor.HFunctor.Final.Final GHC.Base.Functor f)
instance GHC.Base.Functor (Data.Functor.HFunctor.Final.Final Data.Functor.Bind.Class.Apply f)
instance Data.Functor.Bind.Class.Apply (Data.Functor.HFunctor.Final.Final Data.Functor.Bind.Class.Apply f)
instance GHC.Base.Functor (Data.Functor.HFunctor.Final.Final GHC.Base.Applicative f)
instance Data.Functor.Bind.Class.Apply (Data.Functor.HFunctor.Final.Final GHC.Base.Applicative f)
instance GHC.Base.Applicative (Data.Functor.HFunctor.Final.Final GHC.Base.Applicative f)
instance GHC.Base.Functor (Data.Functor.HFunctor.Final.Final GHC.Base.Alternative f)
instance Data.Functor.Bind.Class.Apply (Data.Functor.HFunctor.Final.Final GHC.Base.Alternative f)
instance GHC.Base.Applicative (Data.Functor.HFunctor.Final.Final GHC.Base.Alternative f)
instance GHC.Base.Alternative (Data.Functor.HFunctor.Final.Final GHC.Base.Alternative f)
instance GHC.Base.Functor (Data.Functor.HFunctor.Final.Final GHC.Base.Monad f)
instance Data.Functor.Bind.Class.Apply (Data.Functor.HFunctor.Final.Final GHC.Base.Monad f)
instance GHC.Base.Applicative (Data.Functor.HFunctor.Final.Final GHC.Base.Monad f)
instance GHC.Base.Monad (Data.Functor.HFunctor.Final.Final GHC.Base.Monad f)
instance GHC.Base.Functor (Data.Functor.HFunctor.Final.Final GHC.Base.MonadPlus f)
instance GHC.Base.Applicative (Data.Functor.HFunctor.Final.Final GHC.Base.MonadPlus f)
instance GHC.Base.Monad (Data.Functor.HFunctor.Final.Final GHC.Base.MonadPlus f)
instance GHC.Base.Alternative (Data.Functor.HFunctor.Final.Final GHC.Base.MonadPlus f)
instance GHC.Base.MonadPlus (Data.Functor.HFunctor.Final.Final GHC.Base.MonadPlus f)
instance Data.Pointed.Pointed (Data.Functor.HFunctor.Final.Final Data.Pointed.Pointed f)
instance GHC.Base.Functor (Data.Functor.HFunctor.Final.Final (Control.Monad.Reader.Class.MonadReader r) f)
instance GHC.Base.Applicative (Data.Functor.HFunctor.Final.Final (Control.Monad.Reader.Class.MonadReader r) f)
instance Data.Functor.Bind.Class.Apply (Data.Functor.HFunctor.Final.Final (Control.Monad.Reader.Class.MonadReader r) f)
instance GHC.Base.Monad (Data.Functor.HFunctor.Final.Final (Control.Monad.Reader.Class.MonadReader r) f)
instance Control.Monad.Reader.Class.MonadReader r (Data.Functor.HFunctor.Final.Final (Control.Monad.Reader.Class.MonadReader r) f)
instance GHC.Base.Functor (Data.Functor.HFunctor.Final.Final Data.Functor.Alt.Alt f)
instance Data.Functor.Alt.Alt (Data.Functor.HFunctor.Final.Final Data.Functor.Alt.Alt f)
instance GHC.Base.Functor (Data.Functor.HFunctor.Final.Final Data.Functor.Plus.Plus f)
instance Data.Functor.Alt.Alt (Data.Functor.HFunctor.Final.Final Data.Functor.Plus.Plus f)
instance Data.Functor.Plus.Plus (Data.Functor.HFunctor.Final.Final Data.Functor.Plus.Plus f)
instance Data.Functor.HFunctor.Internal.HFunctor (Data.Functor.HFunctor.Final.Final c)
instance Data.Functor.HFunctor.Interpret (Data.Functor.HFunctor.Final.Final c)

module Data.Functor.Apply.Free

-- | The free <a>Apply</a>. Basically a "non-empty" <a>Ap</a>.
--   
--   The construction here is based on <a>Ap</a>, similar to now
--   <a>NonEmpty</a> is built on list.
data Ap1 :: (Type -> Type) -> Type -> Type
[Ap1] :: f a -> Ap f (a -> b) -> Ap1 f b

-- | An <a>Ap1</a> is a "non-empty" <a>Ap</a>; this function "forgets" the
--   non-empty property and turns it back into a normal <a>Ap</a>.
toAp :: Ap1 f ~> Ap f

-- | Embed an <tt>f</tt> into <a>Ap1</a>.
liftAp1 :: f ~> Ap1 f

-- | Extract the <tt>f</tt> out of the <a>Ap1</a>.
--   
--   <pre>
--   <a>retractAp1</a> . <a>liftAp1</a> == id
--   </pre>
retractAp1 :: Apply f => Ap1 f ~> f

-- | Interpret an <tt><a>Ap</a> f</tt> into some <a>Apply</a> context
--   <tt>g</tt>.
runAp1 :: Apply g => (f ~> g) -> Ap1 f ~> g
instance GHC.Base.Functor (Data.Functor.Apply.Free.Ap1 f)
instance Data.Functor.Bind.Class.Apply (Data.Functor.Apply.Free.Ap1 f)
instance Data.Functor.HFunctor.Internal.HFunctor Data.Functor.Apply.Free.Ap1
instance Data.Functor.HFunctor.Interpret Data.Functor.Apply.Free.Ap1


-- | There are two ways to write a <a>Monoidal</a> instance:
--   
--   <ol>
--   <li>Define <a>nilTM</a>, <a>consTM</a>, <a>unconsTM</a>, and
--   <a>appendTM</a>. These allow you to manipulate <tt><a>TM</a> t</tt> as
--   if it were a "list" of <tt>f</tt>s appended together with
--   <tt>t</tt>.</li>
--   <li>Define <a>fromF</a>, <a>toF</a>, and <a>appendF</a>. <a>F</a> is a
--   special data type that literally represents a linked list of
--   <tt>f</tt>s appended together with <tt>t</tt>. The default definitions
--   of <a>nilTM</a>, <a>consTM</a>, etc. then work on this
--   representation.</li>
--   </ol>
--   
--   Additionally, this class contains <a>retractT</a>, <a>interpretT</a>,
--   <a>pureT</a>, and <a>toTM</a>. These are useful functions of using
--   <tt>t</tt> as an interpreter combinator. They can all be derived from
--   other methods, but they are provided as a part of the typeclass to
--   allow implementors to provide more efficient versions.
module Data.Functor.Tensor

-- | A <a>HBifunctor</a> is like an <a>HFunctor</a>, but it enhances
--   <i>two</i> different functors instead of just one.
--   
--   Usually, it enhaces them "together" in some sort of combining way.
--   
--   This typeclass provides a uniform instance for "swapping out" or
--   "hoisting" the enhanced functors. We can hoist the first one with
--   <a>hleft</a>, the second one with <a>hright</a>, or both at the same
--   time with <a>hbimap</a>.
--   
--   For example, the <tt>f :*: g</tt> type gives us "both <tt>f</tt> and
--   <tt>g</tt>":
--   
--   <pre>
--   data (f <a>:*:</a> g) a = f a :*: g a
--   </pre>
--   
--   It combines both <tt>f</tt> and <tt>g</tt> into a unified structure
--   --- here, it does it by providing both <tt>f</tt> and <tt>g</tt>.
--   
--   The single law is:
--   
--   <pre>
--   <a>hbimap</a> <a>id</a> id == id
--   </pre>
--   
--   This ensures that <a>hleft</a>, <a>hright</a>, and <a>hbimap</a> do
--   not affect the structure that <tt>t</tt> adds on top of the underlying
--   functors.
class HBifunctor t

-- | Swap out the first transformed functor.
hleft :: HBifunctor t => (f ~> j) -> t f g ~> t j g

-- | Swap out the second transformed functor.
hright :: HBifunctor t => (g ~> k) -> t f g ~> t f k

-- | Swap out both transformed functors at the same time.
hbimap :: HBifunctor t => (f ~> j) -> (g ~> k) -> t f g ~> t j k

-- | A <a>HBifunctor</a> can be a <a>Tensor</a> if:
--   
--   <ol>
--   <li>There is some identity <tt>i</tt> where <tt>t i f</tt> is
--   equivalent to just <tt>f</tt>. That is, "enhancing" <tt>f</tt> with
--   <tt>t i</tt> does nothing.</li>
--   <li><tt>t</tt> is associative: <tt>f <tt>t</tt> (g <tt>t</tt> h)</tt>
--   is equivalent to @(f <tt>t</tt> g) <tt>t</tt> h).</li>
--   </ol>
--   
--   The methods in this class provide us useful ways of navigating a
--   <tt><a>Tensor</a> t</tt> with respect to this property.
class HBifunctor t => Tensor t where {
    
    -- | The identity of <tt><a>Tensor</a> t</tt>. If you "combine" <tt>f</tt>
    --   with the identity, it leaves <tt>f</tt> unchanged.
    --   
    --   For example, the identity of <a>:*:</a> is <a>Proxy</a>. This is
    --   because
    --   
    --   <pre>
    --   (<a>Proxy</a> :*: f) a
    --   </pre>
    --   
    --   is equivalent to just
    --   
    --   <pre>
    --   f a
    --   </pre>
    --   
    --   <a>:*:</a>-ing <tt>f</tt> with <a>Proxy</a> gives you no additional
    --   structure.
    type family I t :: Type -> Type;
}
intro1 :: Tensor t => f ~> t f (I t)
intro2 :: (Tensor t, Functor g) => g ~> t (I t) g
elim1 :: (Tensor t, Functor f) => t f (I t) ~> f
elim2 :: (Tensor t, Functor g) => t (I t) g ~> g
assoc :: (Tensor t, Functor f, Functor g, Functor h) => t f (t g h) ~> t (t f g) h
disassoc :: (Tensor t, Functor f, Functor g, Functor h) => t (t f g) h ~> t f (t g h)

-- | The inverse of <a>unconsTM</a>. Calls <a>nilTM</a> on the left (nil)
--   branch, and <a>consTM</a> on the right (cons) branch.
reconsTM :: forall t f. Monoidal t => (I t :+: t f (TM t f)) ~> TM t f

-- | For some tensors <tt>t</tt>, you can represt the act of repeatedly
--   combining the same functor an arbitrary amount of times:
--   
--   <pre>
--   t f f                    -- 2 times
--   t f (t f f)              -- 3 times
--   t f (t f (t f f))        -- 4 times
--   t f (t f (t f (t f f)))  -- 5 times
--   </pre>
--   
--   Sometimes, we have a type that can <i>describe</i> this repeated
--   combination. For example, <tt><a>ListF</a> f</tt> is the type that
--   contains <tt>f</tt> <a>:*:</a>d with itself many number of times, and
--   <tt><a>Ap</a></tt> is the type that contains <tt>f</tt> <a>Day</a>d
--   with itself many number of times.
--   
--   <pre>
--   <a>ListF</a> [x, y]       == x <a>:*:</a> y
--   <a>ListF</a> [x, y, z]    == x <a>:*:</a> y <a>:*:</a> z
--   <a>ListF</a> [x, y, z, q] == x <a>:*:</a> y <a>:*:</a> z <a>:*:</a> q
--   </pre>
--   
--   This is convenient because it allows you to represent repeated
--   applications of <tt>t</tt> as a single data type.
--   
--   For example, <tt><a>Day</a> f f</tt> can be interpreted as "two
--   sequenced <tt>f</tt>s", allowing you to specify "I want exactly two
--   sequenced <tt>f</tt>s". If you want to specify "I want 0, 1, or many
--   <tt>f</tt>s sequenced after each other", then you can use
--   <tt><a>Ap</a> f</tt>.
--   
--   And, <tt>f <a>:*:</a> f</tt> can be interpreted as "a free selection
--   of two <tt>f</tt>s", allowing you to specify "I have to <tt>f</tt>s
--   that I can use". If you want to specify "I want 0, 1, or many
--   different <tt>f</tt>s that I can use", you can use <tt><a>ListF</a>
--   f</tt>.
--   
--   The <a>Monoidal</a> class unifies different such patterns. The
--   associated type <a>TM</a> is the "repeated aplications of <tt>t</tt>"
--   type.
--   
--   See documentation of <a>Data.Functor.Tensor</a> for information on how
--   to define instances of this typeclass.
class (Tensor t, Interpret (TM t)) => Monoidal t where {
    type family TM t :: (Type -> Type) -> Type -> Type;
}

-- | If <tt><a>TM</a> t f</tt> represents multiple applications of <tt>t
--   f</tt> with itself, then <tt>nilTM</tt> gives us "zero applications of
--   <tt>f</tt>".
--   
--   Note that <tt>t</tt> cannot be inferred from the type of <a>nilTM</a>,
--   so this function must always be called with -XTypeApplications:
--   
--   <pre>
--   <a>nilTM</a> @<a>Day</a> :: <a>Identity</a> <a>~&gt;</a> <a>Ap</a> f
--   <a>nilTM</a> @<tt>Comp</tt> :: <a>Identity</a> <a>~&gt;</a> <tt>Free</tt> f
--   <a>nilTM</a> @(<a>:*:</a>) :: <a>Proxy</a> <a>~&gt;</a> <a>ListF</a> f
--   </pre>
--   
--   Together with <a>consTM</a>, forms an inverse with <a>unconsTM</a>.
nilTM :: Monoidal t => I t ~> TM t f

-- | Prepend an application of <tt>t f</tt> to the front of a <tt><a>TM</a>
--   t f</tt>.
--   
--   Together with <a>nilTM</a>, forms an inverse with <a>unconsTM</a>.
consTM :: Monoidal t => t f (TM t f) ~> TM t f

-- | If a <tt><a>TM</a> t f</tt> represents multiple applications of <tt>t
--   f</tt> to itself, <a>unconsTM</a> lets us break it up into two
--   possibilities:
--   
--   <ol>
--   <li>The <tt><a>TM</a> t f</tt> had no applications of <tt>f</tt></li>
--   <li>The <tt><a>TM</a> t f</tt> had at least one application of
--   <tt>f</tt>; we return the "first" <tt>f</tt> applied to the rest of
--   the <tt>f</tt>s.</li>
--   </ol>
--   
--   Should form an inverse with <a>reconsTM</a>:
--   
--   <pre>
--   <a>reconsTM</a> . <a>unconsTM</a> == id
--   <a>unconsTM</a> . <a>reconsTM</a> == id
--   </pre>
--   
--   where <a>reconsTM</a> is <a>nilTM</a> on the left side of the
--   <a>:+:</a>, and <a>consTM</a> on the right side of the <a>:+:</a>.
unconsTM :: Monoidal t => TM t f ~> (I t :+: t f (TM t f))

-- | If a <tt><a>TM</a> t f</tt> represents multiple applications of <tt>t
--   f</tt> to itself, then we can also "append" two <tt><a>TM</a> t
--   f</tt>s applied to themselves into one giant <tt><a>TM</a> t f</tt>
--   containing all of the <tt>t f</tt>s.
appendTM :: Monoidal t => t (TM t f) (TM t f) ~> TM t f

-- | Convert a linked list of <tt>t f</tt>s applied to themselves (stored
--   in the <a>F</a> type) into <tt><a>TM</a> t f</tt>, the data type
--   representing multiple applications of <tt>t f</tt> to itself.
--   
--   <tt><a>F</a> i (<a>I</a> t)</tt> can be thought of as a "universal"
--   representation of multiple-applications-to-self, and <tt><a>TM</a>
--   t</tt> can be thought of as a tailor-made represenation for your
--   specific <tt><a>Tensor</a> t</tt>.
--   
--   <pre>
--   <a>fromF</a> . <a>toF</a> == id
--   <a>toF</a> . <a>fromF</a> == id
--   </pre>
fromF :: Monoidal t => F t (I t) f ~> TM t f

-- | The inverse of <a>fromF</a>: convert a <tt><a>TM</a> t f</tt> into a
--   linked list of <tt>t f</tt>s applied to themselves. See <a>fromF</a>
--   for more information.
toF :: Monoidal t => TM t f ~> F t (I t) f

-- | Append two linked lists of <tt>t f</tt> applied to itself together.
appendF :: Monoidal t => t (F t (I t) f) (F t (I t) f) ~> F t (I t) f

-- | A version of <a>retract</a> that works for a <a>Tensor</a>. It
--   retracts <i>both</i> <tt>f</tt>s into a single <tt>f</tt>.
retractT :: (Monoidal t, C (TM t) f) => t f f ~> f

-- | A version of <a>interpret</a> that works for a <a>Tensor</a>. It takes
--   two interpreting functions, and interprets both joined functors one
--   after the other into <tt>h</tt>.
interpretT :: (Monoidal t, C (TM t) h) => (f ~> h) -> (g ~> h) -> t f g ~> h

-- | If we have an instance of <tt>t</tt>, we can generate an <tt>f</tt>
--   based on how it interacts with <tt>t</tt>.
--   
--   Specialized (and simplified), this type is:
--   
--   <pre>
--   <a>pureT</a> @<a>Day</a>   :: <a>Applicative</a> f =&gt; a -&gt; f a  -- <a>pure</a>
--   <a>pureT</a> @<tt>Comp</tt>  :: <a>Monad</a> f =&gt; a -&gt; f a    -- <a>return</a>
--   <a>pureT</a> @(<a>:*:</a>) :: <a>Plus</a> f =&gt; f a          -- <a>zero</a>
--   </pre>
pureT :: (Monoidal t, C (TM t) f) => I t ~> f

-- | Embed a direct application of <tt>f</tt> to itself into a
--   <tt><a>TM</a> t f</tt>.
toTM :: Monoidal t => t f f ~> TM t f

-- | A useful construction that works like a "linked list" of <tt>t f</tt>
--   applied to itself multiple times. That is, it contains <tt>t f f</tt>,
--   <tt>t f (t f f)</tt>, <tt>t f (t f (t f f))</tt>, etc.
--   
--   If <tt>t</tt> is <a>Monoidal</a>, then it means we can "collapse" this
--   linked list into some final type <tt><a>TM</a> t</tt> (<a>fromF</a>),
--   and also extract it back into a linked list (<a>toF</a>).
data F t i f a
Done :: i a -> F t i f a
More :: t f (F t i f) a -> F t i f a

-- | If we have <tt><a>Tensor</a> t</tt>, we can make a singleton <a>F</a>.
injectF :: forall t f. Tensor t => f ~> F t (I t) f

-- | If we have <tt><a>Monoidal</a> t</tt>, we can collapse all <tt>t
--   f</tt>s in the <a>F</a> into a single <tt>f</tt>.
retractF :: forall t f. (Monoidal t, C (TM t) f) => F t (I t) f ~> f

-- | If we have <tt><a>Monoidal</a> t</tt>, we can interpret all of the
--   <tt>f</tt>s in the <a>F</a> into a final target context <tt>g</tt>,
--   given an <tt>f</tt>-to-<tt>g</tt> interpreting function.
interpretF :: forall t f g. (Monoidal t, C (TM t) g) => (f ~> g) -> F t (I t) f ~> g

-- | Useful newtype to allow us to derive an <a>HFunctor</a> instance from
--   any instance of <a>HBifunctor</a>, using -XDerivingVia.
--   
--   For example, because we have <tt>instance <a>HBifunctor</a>
--   <a>Day</a></tt>, we can write:
--   
--   <pre>
--   deriving via (<a>WrappedHBifunctor</a> <a>Day</a> f) instance <a>HFunctor</a> (<a>Day</a> f)
--   </pre>
--   
--   to give us an automatic <a>HFunctor</a> instance and save us some
--   work.
newtype WrappedHBifunctor t (f :: Type -> Type) (g :: Type -> Type) a
WrappedHBifunctor :: t f g a -> WrappedHBifunctor t a
[unwrapHBifunctor] :: WrappedHBifunctor t a -> t f g a
data JoinT t f a
JoinT :: t f f a -> JoinT t f a
[runJoinT] :: JoinT t f a -> t f f a
data These1 f g a
This1 :: f a -> These1 f g a
That1 :: g a -> These1 f g a
These1 :: f a -> g a -> These1 f g a
instance forall k (f :: k -> *) (g :: k -> *) (a :: k). (GHC.Classes.Ord (f a), GHC.Classes.Ord (g a)) => GHC.Classes.Ord (Data.Functor.Tensor.These1 f g a)
instance forall k (f :: k -> *) (g :: k -> *) (a :: k). (GHC.Classes.Eq (f a), GHC.Classes.Eq (g a)) => GHC.Classes.Eq (Data.Functor.Tensor.These1 f g a)
instance forall k (f :: k -> *) (g :: k -> *) (a :: k). (GHC.Show.Show (f a), GHC.Show.Show (g a)) => GHC.Show.Show (Data.Functor.Tensor.These1 f g a)
instance forall k1 k2 (i :: k2 -> *) (a :: k2) (t :: k1 -> (k2 -> *) -> k2 -> *) (f :: k1). (GHC.Show.Show (i a), GHC.Show.Show (t f (Data.Functor.Tensor.F t i f) a)) => GHC.Show.Show (Data.Functor.Tensor.F t i f a)
instance forall k (t :: k -> k -> * -> *) (f :: k). GHC.Base.Functor (t f f) => GHC.Base.Functor (Data.Functor.Tensor.JoinT t f)
instance forall k (f :: k -> *) (a :: k) (g :: k -> *). (GHC.Base.Semigroup (f a), GHC.Base.Semigroup (g a)) => GHC.Base.Semigroup (Data.Functor.Tensor.These1 f g a)
instance Data.Functor.HFunctor.Internal.HBifunctor Data.Functor.Tensor.These1
instance Data.Functor.Tensor.Tensor Data.Functor.Tensor.These1
instance Data.Functor.Tensor.Monoidal Data.Functor.Tensor.These1
instance Data.Functor.HFunctor.Internal.HBifunctor t => Data.Functor.HFunctor.Internal.HFunctor (Data.Functor.Tensor.JoinT t)
instance Data.Functor.Tensor.Monoidal (GHC.Generics.:*:)
instance Data.Functor.Tensor.Monoidal Data.Functor.Day.Day
instance Data.Functor.Tensor.Monoidal (GHC.Generics.:+:)
instance forall k (i :: * -> *) (t :: k -> (* -> *) -> * -> *) (f :: k). (GHC.Base.Functor i, GHC.Base.Functor (t f (Data.Functor.Tensor.F t i f))) => GHC.Base.Functor (Data.Functor.Tensor.F t i f)
instance Data.Functor.HFunctor.Internal.HBifunctor t => Data.Functor.HFunctor.Internal.HFunctor (Data.Functor.Tensor.F t i)
instance Data.Functor.Tensor.Tensor (GHC.Generics.:*:)
instance Data.Functor.Tensor.Tensor Data.Functor.Day.Day
instance Data.Functor.Tensor.Tensor (GHC.Generics.:+:)

module Data.Functor.Tensor.Cons

-- | A lot of tensors can be factored out into a <a>Cons</a> on some
--   parameterized profunctor. For example, we have:
--   
--   <pre>
--   <a>:.:</a> = <a>Cons</a> <a>Star</a>
--   <a>Day</a> = <a>Cons</a> <a>Static</a>
--   <a>:*:</a> = <a>Cons</a> <a>ProdK</a>
--   </pre>
--   
--   In the case of <a>:.:</a>, this actually allows us to have
--   <a>HFunctor</a> and <a>Interpret</a> instances for functor
--   composition, because the representation of <a>:.:</a> normally does
--   not allow this. This gives us a proper tensor to form <a>Free</a>,
--   which makes the free monad work nicely within our system.
--   
--   In the normal case, you can just use <a>Day</a> and <a>:*:</a> instead
--   of <tt><a>DayCons</a> = <a>Cons</a> <a>Static</a></tt> and
--   <tt><a>ProdCons</a> = <a>Cons</a> <a>ProdK</a></tt>. The only one that
--   gives us extra power is <tt><a>Comp</a> = <a>Cons</a>
--   <a>Star</a></tt>.
--   
--   You can use <a>DayCons</a> and <a>ProdCons</a> as <a>Day</a> and
--   <a>:*:</a> using the provided pattern synonyms.
data Cons :: ((Type -> Type) -> Type -> Type -> Type) -> (Type -> Type) -> (Type -> Type) -> Type -> Type
pattern Comp :: Functor f => f (g a) -> Comp f g a
pattern DayCons :: Functor g => Day f g a -> DayCons f g a
pattern ProdCons :: Functor f => (f :*: g) a -> ProdCons f g a

-- | Associates each <tt><a>Tensor</a> t</tt> with its <a>Cons</a>
--   equivalent, <tt><a>Cons</a> p</tt>.
--   
--   <tt>t</tt> need not always be a legal <a>Tensor</a>.
class Monoidal (Cons p) => Uncons p t | t -> p
uncons :: (Uncons p t, Functor g) => t f g ~> Cons p f g
cons :: (Uncons p t, Functor f) => Cons p f g ~> t f g

-- | A version of <a>:.:</a> that permits <a>HBifunctor</a>, <a>Tensor</a>,
--   and <a>Monoidal</a> instances.
type Comp = Cons Star
unComp :: () => Comp f g a -> Functor f -> f (g a)
comp :: f (g a) -> Comp f g a
type DayCons = Cons Static
unDayCons :: DayCons b c ~> Day b c
data ProdK g a b
ProdK :: (a -> b) -> g b -> ProdK g a b
type ProdCons = Cons ProdK
unProdCons :: () => ProdCons f g a -> Functor f -> (f :*: g) a
prodCons :: (f :*: g) ~> ProdCons f g
instance Data.Functor.Plus.Plus (Data.Functor.Tensor.Cons.ListFCo f)
instance GHC.Base.Applicative f => GHC.Base.Applicative (Data.Functor.Tensor.Cons.ListFCo f)
instance GHC.Base.Functor (Data.Functor.Tensor.Cons.ListFCo f)
instance GHC.Base.Functor g => GHC.Base.Functor (Data.Functor.Tensor.Cons.ProdK g a)
instance Data.Functor.HFunctor.Internal.HFunctor (Data.Functor.Tensor.Cons.Cons Data.Profunctor.Types.Star f)
instance Data.Functor.HFunctor.Internal.HFunctor (Data.Functor.Tensor.Cons.Cons Data.Semigroupoid.Static.Static f)
instance Data.Functor.HFunctor.Internal.HFunctor (Data.Functor.Tensor.Cons.Cons Data.Functor.Tensor.Cons.ProdK f)
instance Data.Functor.Tensor.Cons.Uncons Data.Profunctor.Types.Star (GHC.Generics.:.:)
instance Data.Functor.Tensor.Cons.Uncons Data.Semigroupoid.Static.Static Data.Functor.Day.Day
instance Data.Functor.Tensor.Cons.Uncons Data.Functor.Tensor.Cons.ProdK (GHC.Generics.:*:)
instance Data.Functor.Alt.Alt (Data.Functor.Tensor.Cons.ListFCo f)
instance Data.Functor.HFunctor.Internal.HFunctor Data.Functor.Tensor.Cons.ListFCo
instance Data.Functor.HFunctor.Interpret Data.Functor.Tensor.Cons.ListFCo
instance Data.Functor.Tensor.Monoidal Data.Functor.Tensor.Cons.ProdCons
instance Data.Functor.HFunctor.Internal.HBifunctor Data.Functor.Tensor.Cons.ProdCons
instance Data.Functor.Tensor.Tensor Data.Functor.Tensor.Cons.ProdCons
instance GHC.Base.Functor g => Data.Profunctor.Unsafe.Profunctor (Data.Functor.Tensor.Cons.ProdK g)
instance GHC.Base.Applicative g => GHC.Base.Applicative (Data.Functor.Tensor.Cons.ProdK g a)
instance Data.Functor.HFunctor.Internal.HBifunctor Data.Functor.Tensor.Cons.DayCons
instance Data.Functor.Tensor.Tensor Data.Functor.Tensor.Cons.DayCons
instance Data.Functor.Tensor.Monoidal Data.Functor.Tensor.Cons.DayCons
instance Data.Functor.HFunctor.Internal.HBifunctor Data.Functor.Tensor.Cons.Comp
instance Data.Functor.Tensor.Tensor Data.Functor.Tensor.Cons.Comp
instance Data.Functor.Tensor.Monoidal Data.Functor.Tensor.Cons.Comp
instance (forall x. GHC.Base.Functor (p g x)) => GHC.Base.Functor (Data.Functor.Tensor.Cons.Cons p f g)

module Data.Functor.Combinator

-- | A natural transformation from <tt>f</tt> to <tt>g</tt>.
type (~>) (f :: k -> Type) (g :: k -> Type) = forall (x :: k). () => f x -> g x
infixr 0 ~>

-- | An <a>HFunctor</a> can be thought of a unary "functor transformer" ---
--   a basic functor combinator. It takes a functor as input and returns a
--   functor as output.
--   
--   It "enhances" a functor with extra structure (sort of like how a monad
--   transformer enhances a <a>Monad</a> with extra structure).
--   
--   As a uniform inteface, we can "swap the underlying functor" (also
--   sometimes called "hoisting"). This is what <a>hmap</a> does: it lets
--   us swap out the <tt>f</tt> in a <tt>t f</tt> for a <tt>t g</tt>.
--   
--   For example, the free monad <a>Free</a> takes a <a>Functor</a> and
--   returns a new <a>Functor</a>. In the process, it provides a monadic
--   structure over <tt>f</tt>. <a>hmap</a> lets us turn a <tt><a>Free</a>
--   f</tt> into a <tt><a>Free</a> g</tt>: a monad built over <tt>f</tt>
--   can be turned into a monad built over <tt>g</tt>.
--   
--   For the ability to move in and out of the enhanced functor, see
--   <tt>Interpret</tt>.
class HFunctor t

-- | If we can turn an <tt>f</tt> into a <tt>g</tt>, then we can turn a
--   <tt>t f</tt> into a <tt>t g</tt>.
--   
--   It must be the case that
--   
--   <pre>
--   <a>hmap</a> <a>id</a> == id
--   </pre>
--   
--   Essentially, <tt><tt>t</tt> f</tt> adds some "extra structure" to
--   <tt>f</tt>. <a>hmap</a> must swap out the functor, <i>without
--   affecting the added structure</i>.
--   
--   For example, <tt><a>ListF</a> f a</tt> is essentially a list of <tt>f
--   a</tt>s. If we <a>hmap</a> to swap out the <tt>f a</tt>s for <tt>g
--   a</tt>s, then we must ensure that the "added structure" (here, the
--   number of items in the list) remains the same. So, <a>hmap</a> must
--   preserve the number of items in the list.
--   
--   The law <tt><a>hmap</a> <a>id</a> == id</tt> is a way of formalizing
--   this informal property.
hmap :: HFunctor t => (f ~> g) -> t f ~> t g

-- | An <a>Interpret</a> lets us move in and out of the "enhanced"
--   <a>Functor</a>.
--   
--   For example, <tt><a>Free</a> f</tt> is <tt>f</tt> enhanced with
--   monadic structure. We get:
--   
--   <pre>
--   <a>inject</a>    :: f a -&gt; <a>Free</a> f a
--   <a>interpret</a> :: <a>Monad</a> m =&gt; (forall x. f x -&gt; m x) -&gt; <a>Free</a> f a -&gt; m a
--   </pre>
--   
--   <a>inject</a> will let us use our <tt>f</tt> inside the enhanced
--   <tt><a>Free</a> f</tt>. <a>interpret</a> will let us "extract" the
--   <tt>f</tt> from a <tt><a>Free</a> f</tt> if we can give an
--   <i>interpreting function</i> that interprets <tt>f</tt> into some
--   target <a>Monad</a>.
--   
--   The type family <a>C</a> tells us the typeclass constraint of the
--   "target" functor. For <a>Free</a>, it is <a>Monad</a>, but for other
--   <a>Interpret</a> instances, we might have other constraints.
--   
--   We enforce that:
--   
--   <pre>
--   <a>interpret</a> id . <a>inject</a> == id
--   </pre>
--   
--   That is, if we lift a value into our structure, then immediately
--   interpret it out as itself, it should lave the value unchanged.
class HFunctor t => Interpret t where {
    
    -- | The constraint on the target context of <a>interpret</a>.
    type family C t :: (Type -> Type) -> Constraint;
}

-- | Lift an <tt>f</tt> into the enhanced <tt>t f</tt> structure. Analogous
--   to <a>lift</a> from <a>MonadTrans</a>.
inject :: Interpret t => f ~> t f

-- | Remove the <tt>f</tt> out of the enhanced <tt>t f</tt> structure,
--   provided that <tt>f</tt> satisfies the necessary constraints. If it
--   doesn't, it needs to be properly <a>interpret</a>ed out.
retract :: (Interpret t, C t f) => t f ~> f

-- | Given an "interpeting function" from <tt>f</tt> to <tt>g</tt>,
--   interpret the <tt>f</tt> out of the <tt>t f</tt> into a final context
--   <tt>g</tt>.
interpret :: (Interpret t, C t g) => (f ~> g) -> t f ~> g

-- | A <a>HBifunctor</a> is like an <a>HFunctor</a>, but it enhances
--   <i>two</i> different functors instead of just one.
--   
--   Usually, it enhaces them "together" in some sort of combining way.
--   
--   This typeclass provides a uniform instance for "swapping out" or
--   "hoisting" the enhanced functors. We can hoist the first one with
--   <a>hleft</a>, the second one with <a>hright</a>, or both at the same
--   time with <a>hbimap</a>.
--   
--   For example, the <tt>f :*: g</tt> type gives us "both <tt>f</tt> and
--   <tt>g</tt>":
--   
--   <pre>
--   data (f <a>:*:</a> g) a = f a :*: g a
--   </pre>
--   
--   It combines both <tt>f</tt> and <tt>g</tt> into a unified structure
--   --- here, it does it by providing both <tt>f</tt> and <tt>g</tt>.
--   
--   The single law is:
--   
--   <pre>
--   <a>hbimap</a> <a>id</a> id == id
--   </pre>
--   
--   This ensures that <a>hleft</a>, <a>hright</a>, and <a>hbimap</a> do
--   not affect the structure that <tt>t</tt> adds on top of the underlying
--   functors.
class HBifunctor t

-- | Swap out the first transformed functor.
hleft :: HBifunctor t => (f ~> j) -> t f g ~> t j g

-- | Swap out the second transformed functor.
hright :: HBifunctor t => (g ~> k) -> t f g ~> t f k

-- | Swap out both transformed functors at the same time.
hbimap :: HBifunctor t => (f ~> j) -> (g ~> k) -> t f g ~> t j k

-- | A <a>HBifunctor</a> can be a <a>Tensor</a> if:
--   
--   <ol>
--   <li>There is some identity <tt>i</tt> where <tt>t i f</tt> is
--   equivalent to just <tt>f</tt>. That is, "enhancing" <tt>f</tt> with
--   <tt>t i</tt> does nothing.</li>
--   <li><tt>t</tt> is associative: <tt>f <tt>t</tt> (g <tt>t</tt> h)</tt>
--   is equivalent to @(f <tt>t</tt> g) <tt>t</tt> h).</li>
--   </ol>
--   
--   The methods in this class provide us useful ways of navigating a
--   <tt><a>Tensor</a> t</tt> with respect to this property.
class HBifunctor t => Tensor t where {
    
    -- | The identity of <tt><a>Tensor</a> t</tt>. If you "combine" <tt>f</tt>
    --   with the identity, it leaves <tt>f</tt> unchanged.
    --   
    --   For example, the identity of <a>:*:</a> is <a>Proxy</a>. This is
    --   because
    --   
    --   <pre>
    --   (<a>Proxy</a> :*: f) a
    --   </pre>
    --   
    --   is equivalent to just
    --   
    --   <pre>
    --   f a
    --   </pre>
    --   
    --   <a>:*:</a>-ing <tt>f</tt> with <a>Proxy</a> gives you no additional
    --   structure.
    type family I t :: Type -> Type;
}

-- | For some tensors <tt>t</tt>, you can represt the act of repeatedly
--   combining the same functor an arbitrary amount of times:
--   
--   <pre>
--   t f f                    -- 2 times
--   t f (t f f)              -- 3 times
--   t f (t f (t f f))        -- 4 times
--   t f (t f (t f (t f f)))  -- 5 times
--   </pre>
--   
--   Sometimes, we have a type that can <i>describe</i> this repeated
--   combination. For example, <tt><a>ListF</a> f</tt> is the type that
--   contains <tt>f</tt> <a>:*:</a>d with itself many number of times, and
--   <tt><a>Ap</a></tt> is the type that contains <tt>f</tt> <a>Day</a>d
--   with itself many number of times.
--   
--   <pre>
--   <a>ListF</a> [x, y]       == x <a>:*:</a> y
--   <a>ListF</a> [x, y, z]    == x <a>:*:</a> y <a>:*:</a> z
--   <a>ListF</a> [x, y, z, q] == x <a>:*:</a> y <a>:*:</a> z <a>:*:</a> q
--   </pre>
--   
--   This is convenient because it allows you to represent repeated
--   applications of <tt>t</tt> as a single data type.
--   
--   For example, <tt><a>Day</a> f f</tt> can be interpreted as "two
--   sequenced <tt>f</tt>s", allowing you to specify "I want exactly two
--   sequenced <tt>f</tt>s". If you want to specify "I want 0, 1, or many
--   <tt>f</tt>s sequenced after each other", then you can use
--   <tt><a>Ap</a> f</tt>.
--   
--   And, <tt>f <a>:*:</a> f</tt> can be interpreted as "a free selection
--   of two <tt>f</tt>s", allowing you to specify "I have to <tt>f</tt>s
--   that I can use". If you want to specify "I want 0, 1, or many
--   different <tt>f</tt>s that I can use", you can use <tt><a>ListF</a>
--   f</tt>.
--   
--   The <a>Monoidal</a> class unifies different such patterns. The
--   associated type <a>TM</a> is the "repeated aplications of <tt>t</tt>"
--   type.
--   
--   See documentation of <a>Data.Functor.Tensor</a> for information on how
--   to define instances of this typeclass.
class (Tensor t, Interpret (TM t)) => Monoidal t where {
    type family TM t :: (Type -> Type) -> Type -> Type;
}

-- | A version of <a>retract</a> that works for a <a>Tensor</a>. It
--   retracts <i>both</i> <tt>f</tt>s into a single <tt>f</tt>.
retractT :: (Monoidal t, C (TM t) f) => t f f ~> f

-- | A version of <a>interpret</a> that works for a <a>Tensor</a>. It takes
--   two interpreting functions, and interprets both joined functors one
--   after the other into <tt>h</tt>.
interpretT :: (Monoidal t, C (TM t) h) => (f ~> h) -> (g ~> h) -> t f g ~> h

-- | If we have an instance of <tt>t</tt>, we can generate an <tt>f</tt>
--   based on how it interacts with <tt>t</tt>.
--   
--   Specialized (and simplified), this type is:
--   
--   <pre>
--   <a>pureT</a> @<a>Day</a>   :: <a>Applicative</a> f =&gt; a -&gt; f a  -- <a>pure</a>
--   <a>pureT</a> @<tt>Comp</tt>  :: <a>Monad</a> f =&gt; a -&gt; f a    -- <a>return</a>
--   <a>pureT</a> @(<a>:*:</a>) :: <a>Plus</a> f =&gt; f a          -- <a>zero</a>
--   </pre>
pureT :: (Monoidal t, C (TM t) f) => I t ~> f

-- | Embed a direct application of <tt>f</tt> to itself into a
--   <tt><a>TM</a> t f</tt>.
toTM :: Monoidal t => t f f ~> TM t f

-- | A covariant <a>Functor</a> suitable for Yoneda reduction
data Coyoneda (f :: Type -> Type) a
[Coyoneda] :: forall (f :: Type -> Type) a b. () => (b -> a) -> f b -> Coyoneda f a

-- | A list of <tt>f a</tt>s.
--   
--   This is the Free <a>Plus</a>.
newtype ListF f a
ListF :: [f a] -> ListF f a
[runListF] :: ListF f a -> [f a]

-- | The free <a>Applicative</a> for a <a>Functor</a> <tt>f</tt>.
data Ap (f :: Type -> Type) a
data Alt (f :: Type -> Type) a

-- | Church-encoded Freer monad
data Free f a

-- | The fixed point of applications of <tt>:+:</tt> (functor sums).
--   
--   Intuitively, in an infinite <tt>f <tt>:+:</tt> f <tt>:+:</tt> f
--   <tt>:+:</tt> f ...</tt>, you have exactly one <tt>f</tt>
--   <i>somewhere</i>. A <tt><a>Step</a> f a</tt> has that <tt>f</tt>, with
--   a <a>Natural</a> giving you "where" the <tt>f</tt> is in the long
--   chain.
--   
--   <tt>interpret</tt>ing it requires no constraint on the target context.
data Step f a
Step :: Natural -> f a -> Step f a
[stepPos] :: Step f a -> Natural
[stepVal] :: Step f a -> f a

-- | The fixed point of applications of <tt>TheseT</tt>.
--   
--   Intuitively, in an infinite <tt>f <tt>TheseT</tt> f <tt>TheseT</tt> f
--   <tt>TheseT</tt> f ...</tt>, each of those infinite positions may have
--   an <tt>f</tt> in them. However, because of the at-least-one nature of
--   <tt>TheseT</tt>, we know we have at least one f at one position
--   <i>somewhere</i>.
--   
--   A <tt><a>Steps</a> f a</tt> has potentially many <tt>f</tt>s, each
--   stored at a different <a>Natural</a> position, with the guaruntee that
--   at least one <tt>f</tt> exists.
--   
--   <tt>interpret</tt>ing it requires at least an <a>Alt</a> instance in
--   the target context, since we have to handle potentially more than one
--   <tt>f</tt>. However, we don't fully need <tt>Plus</tt>, since we know
--   we always have at least one <tt>f</tt>.
newtype Steps f a
Steps :: NEMap Natural (f a) -> Steps f a
[getSteps] :: Steps f a -> NEMap Natural (f a)

-- | The Day convolution of two covariant functors.
data Day (f :: Type -> Type) (g :: Type -> Type) a
[Day] :: forall (f :: Type -> Type) (g :: Type -> Type) a b c. () => f b -> g c -> (b -> c -> a) -> Day f g a

-- | Products: encode multiple arguments to constructors
data (:*:) (f :: k -> Type) (g :: k -> Type) (p :: k) :: forall k. () => k -> Type -> k -> Type -> k -> Type
(:*:) :: f p -> g p -> (:*:)
infixr 6 :*:
infixr 6 :*:

-- | Sums: encode choice between constructors
data (:+:) (f :: k -> Type) (g :: k -> Type) (p :: k) :: forall k. () => k -> Type -> k -> Type -> k -> Type
L1 :: f p -> (:+:)
R1 :: g p -> (:+:)
infixr 5 :+:
data These1 f g a
This1 :: f a -> These1 f g a
That1 :: g a -> These1 f g a
These1 :: f a -> g a -> These1 f g a

-- | A version of <a>:.:</a> that permits <a>HBifunctor</a>, <a>Tensor</a>,
--   and <a>Monoidal</a> instances.
type Comp = Cons Star

-- | A simple way to inject/reject into any eventual typeclass.
--   Essentially, <tt><a>Final</a> c</tt> is the "free c". <tt><a>Final</a>
--   <a>Monad</a></tt> is the free <a>Monad</a>, etc.
--   
--   Useful for lifting a functor <tt>f</tt> into arbitrary structure given
--   by a typeclass.
--   
--   Note that this doesn't have instances for all the typeclasses; you
--   probably have to define your own if you want to use <tt><a>Final</a>
--   c</tt> as an <i>instance</i> of <tt>c</tt> (using <a>liftFinal0</a>,
--   <a>liftFinal1</a>, <a>liftFinal2</a> for help). This is mostly meant
--   to be usable as a final <a>Interpret</a>, with
--   
--   <pre>
--   <a>inject</a>    :: f a -&gt; <a>Final</a> c f a
--   <a>interpret</a> :: (f <a>~&gt;</a> g) -&gt; <a>Final</a> c f a -&gt; g a
--   </pre>
newtype Final c f a
Final :: (forall g. c g => (forall x. f x -> g x) -> g a) -> Final c f a
[runFinal] :: Final c f a -> forall g. c g => (forall x. f x -> g x) -> g a

-- | A lot of tensors can be factored out into a <a>Cons</a> on some
--   parameterized profunctor. For example, we have:
--   
--   <pre>
--   <a>:.:</a> = <a>Cons</a> <a>Star</a>
--   <a>Day</a> = <a>Cons</a> <a>Static</a>
--   <a>:*:</a> = <a>Cons</a> <a>ProdK</a>
--   </pre>
--   
--   In the case of <a>:.:</a>, this actually allows us to have
--   <a>HFunctor</a> and <a>Interpret</a> instances for functor
--   composition, because the representation of <a>:.:</a> normally does
--   not allow this. This gives us a proper tensor to form <a>Free</a>,
--   which makes the free monad work nicely within our system.
--   
--   In the normal case, you can just use <a>Day</a> and <a>:*:</a> instead
--   of <tt><a>DayCons</a> = <a>Cons</a> <a>Static</a></tt> and
--   <tt><a>ProdCons</a> = <a>Cons</a> <a>ProdK</a></tt>. The only one that
--   gives us extra power is <tt><a>Comp</a> = <a>Cons</a>
--   <a>Star</a></tt>.
--   
--   You can use <a>DayCons</a> and <a>ProdCons</a> as <a>Day</a> and
--   <a>:*:</a> using the provided pattern synonyms.
data Cons :: ((Type -> Type) -> Type -> Type -> Type) -> (Type -> Type) -> (Type -> Type) -> Type -> Type
pattern Comp :: Functor f => f (g a) -> Comp f g a
pattern DayCons :: Functor g => Day f g a -> DayCons f g a
pattern ProdCons :: Functor f => (f :*: g) a -> ProdCons f g a

-- | Associates each <tt><a>Tensor</a> t</tt> with its <a>Cons</a>
--   equivalent, <tt><a>Cons</a> p</tt>.
--   
--   <tt>t</tt> need not always be a legal <a>Tensor</a>.
class Monoidal (Cons p) => Uncons p t | t -> p
uncons :: (Uncons p t, Functor g) => t f g ~> Cons p f g
cons :: (Uncons p t, Functor f) => Cons p f g ~> t f g
