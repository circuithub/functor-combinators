-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/mstksg/functor-combinators#readme</a>
@package functor-combinators
@version 0.1.0.0

module Data.Functor.Combinator
type f ~> g = forall x. f x -> g x
infixr 0 ~>
class HFunctor t
hmap :: HFunctor t => (f ~> g) -> t f ~> t g

-- | Laws:
--   
--   <pre>
--   retract . inject == id
--   </pre>
class HFunctor t => Interpret t where {
    type family C t :: (Type -> Type) -> Constraint;
}
inject :: Interpret t => f ~> t f
retract :: (Interpret t, C t f) => t f ~> f
interpret :: (Interpret t, C t g) => (f ~> g) -> t f ~> g
class HBifunctor t
hleft :: HBifunctor t => (f ~> j) -> t f g ~> t j g
hright :: HBifunctor t => (g ~> k) -> t f g ~> t f k
hbimap :: HBifunctor t => (f ~> j) -> (g ~> k) -> t f g ~> t j k
class HBifunctor t => Tensor t where {
    type family I t :: Type -> Type;
}
intro1 :: Tensor t => f ~> t f (I t)
intro2 :: (Tensor t, Functor g) => g ~> t (I t) g
elim1 :: (Tensor t, Functor f) => t f (I t) ~> f
elim2 :: (Tensor t, Functor g) => t (I t) g ~> g
assoc :: (Tensor t, Functor f, Functor g, Functor h) => t f (t g h) ~> t (t f g) h
disassoc :: (Tensor t, Functor f, Functor g, Functor h) => t (t f g) h ~> t f (t g h)
data F t i f a
Done :: i a -> F t i f a
More :: t f (F t i f) a -> F t i f a
class (Tensor t, Interpret (TM t)) => Monoidal t where {
    type family TM t :: (Type -> Type) -> Type -> Type;
}
nilTM :: Monoidal t => I t ~> TM t f
consTM :: Monoidal t => t f (TM t f) ~> TM t f
unconsTM :: Monoidal t => TM t f ~> (I t :+: t f (TM t f))
appendTM :: Monoidal t => t (TM t f) (TM t f) ~> TM t f
fromF :: Monoidal t => F t (I t) f ~> TM t f
toF :: Monoidal t => TM t f ~> F t (I t) f
appendF :: Monoidal t => t (F t (I t) f) (F t (I t) f) ~> F t (I t) f
retractT :: (Monoidal t, C (TM t) f) => t f f ~> f
injectT :: (Monoidal t, C (TM t) f) => I t ~> f
toTM :: Monoidal t => t f f ~> TM t f
injectF :: forall t f. Tensor t => f ~> F t (I t) f
retractF :: forall t f. (Monoidal t, C (TM t) f) => F t (I t) f ~> f
interpretF :: forall t f g. (Monoidal t, C (TM t) g) => (f ~> g) -> F t (I t) f ~> g
newtype WrappedHBifunctor t (f :: Type -> Type) (g :: Type -> Type) a
WrappedHBifunctor :: t f g a -> WrappedHBifunctor t a
[unwrapHBifunctor] :: WrappedHBifunctor t a -> t f g a
data Cons :: ((Type -> Type) -> Type -> Type -> Type) -> (Type -> Type) -> (Type -> Type) -> Type -> Type
[:=>] :: f x -> p g x a -> Cons p f g a
type Comp = Cons Star
pattern Comp :: Functor f => f (g a) -> Comp f g a
unComp :: () => Comp f g a -> Functor f -> f (g a)
comp :: f (g a) -> Comp f g a
type DayCons = Cons Static
pattern DayCons :: Functor g => Day f g a -> DayCons f g a
unDayCons :: Cons Static b c d -> Day b c d

-- | Church-encoded Freer monad
newtype Free f a
Free :: (forall r. (a -> r) -> (forall s. f s -> (s -> r) -> r) -> r) -> Free f a
[runFree] :: Free f a -> forall r. (a -> r) -> (forall s. f s -> (s -> r) -> r) -> r
data Step f a
Step :: Natural -> f a -> Step f a
[stepPos] :: Step f a -> Natural
[stepVal] :: Step f a -> f a
data VoidT a
instance GHC.Base.Functor (t f g) => GHC.Base.Functor (Data.Functor.Combinator.WrappedHBifunctor t f g)
instance GHC.Base.Functor f => GHC.Base.Functor (Data.Functor.Combinator.Step f)
instance forall k (f :: k -> *) (a :: k). GHC.Classes.Ord (f a) => GHC.Classes.Ord (Data.Functor.Combinator.Step f a)
instance forall k (f :: k -> *) (a :: k). GHC.Classes.Eq (f a) => GHC.Classes.Eq (Data.Functor.Combinator.Step f a)
instance forall k (f :: k -> *) (a :: k). GHC.Show.Show (f a) => GHC.Show.Show (Data.Functor.Combinator.Step f a)
instance GHC.Base.Functor Data.Functor.Combinator.VoidT
instance forall k (a :: k). GHC.Classes.Ord (Data.Functor.Combinator.VoidT a)
instance forall k (a :: k). GHC.Classes.Eq (Data.Functor.Combinator.VoidT a)
instance forall k (a :: k). GHC.Show.Show (Data.Functor.Combinator.VoidT a)
instance GHC.Base.Functor f => GHC.Base.Functor (Data.Functor.Combinator.ListF f)
instance forall k (f :: k -> *) (a :: k). GHC.Classes.Ord (f a) => GHC.Classes.Ord (Data.Functor.Combinator.ListF f a)
instance forall k (f :: k -> *) (a :: k). GHC.Classes.Eq (f a) => GHC.Classes.Eq (Data.Functor.Combinator.ListF f a)
instance forall k (f :: k -> *) (a :: k). GHC.Show.Show (f a) => GHC.Show.Show (Data.Functor.Combinator.ListF f a)
instance Data.Functor.Combinator.HFunctor (Data.Functor.Day.Day f)
instance Data.Functor.Combinator.HFunctor ((GHC.Generics.:*:) f)
instance Data.Functor.Combinator.HFunctor ((GHC.Generics.:+:) f)
instance Data.Functor.Combinator.HFunctor (Data.Functor.Combinator.Cons Data.Profunctor.Types.Star f)
instance Data.Functor.Combinator.HFunctor (Data.Functor.Combinator.Cons Data.Semigroupoid.Static.Static f)
instance GHC.Base.Functor (Data.Functor.Combinator.Final GHC.Base.Functor f)
instance forall k (c :: (k -> *) -> GHC.Types.Constraint). Data.Functor.Combinator.HFunctor (Data.Functor.Combinator.Final c)
instance Data.Functor.Combinator.Interpret (Data.Functor.Combinator.Final c)
instance Data.Functor.Combinator.HBifunctor Data.Functor.Combinator.DayCons
instance Data.Functor.Combinator.Tensor Data.Functor.Combinator.DayCons
instance Data.Functor.Combinator.Monoidal Data.Functor.Combinator.DayCons
instance Data.Functor.Combinator.HBifunctor Data.Functor.Combinator.Comp
instance Data.Functor.Combinator.Tensor Data.Functor.Combinator.Comp
instance Data.Functor.Combinator.Monoidal Data.Functor.Combinator.Comp
instance GHC.Base.Functor (Data.Functor.Combinator.Free f)
instance GHC.Base.Applicative (Data.Functor.Combinator.Free f)
instance GHC.Base.Monad (Data.Functor.Combinator.Free f)
instance Control.Monad.Free.Class.MonadFree f (Data.Functor.Combinator.Free f)
instance Data.Functor.Combinator.HFunctor Data.Functor.Combinator.Free
instance Data.Functor.Combinator.Interpret Data.Functor.Combinator.Free
instance (forall x. GHC.Base.Functor (p g x)) => GHC.Base.Functor (Data.Functor.Combinator.Cons p f g)
instance forall k (t :: (* -> *) -> (* -> *) -> k -> *) (f :: * -> *). Data.Functor.Combinator.HBifunctor t => Data.Functor.Combinator.HFunctor (Data.Functor.Combinator.WrappedHBifunctor t f)
instance Data.Functor.Combinator.HFunctor Data.Functor.Combinator.Step
instance Data.Functor.Combinator.Interpret Data.Functor.Combinator.Step
instance Data.Functor.Combinator.Monoidal (GHC.Generics.:+:)
instance Data.Functor.Combinator.Tensor (GHC.Generics.:+:)
instance GHC.Base.Applicative f => GHC.Base.Applicative (Data.Functor.Combinator.ListF f)
instance Data.Functor.Combinator.Monoidal (GHC.Generics.:*:)
instance Data.Functor.Combinator.HFunctor Data.Functor.Combinator.ListF
instance Data.Functor.Combinator.Interpret Data.Functor.Combinator.ListF
instance Data.Functor.Combinator.Monoidal Data.Functor.Day.Day
instance forall k (i :: * -> *) (t :: k -> (* -> *) -> * -> *) (f :: k). (GHC.Base.Functor i, forall (g :: * -> *). GHC.Base.Functor g => GHC.Base.Functor (t f g)) => GHC.Base.Functor (Data.Functor.Combinator.F t i f)
instance forall k1 k2 (t :: (k1 -> *) -> (k2 -> *) -> k2 -> *) (i :: k2 -> *). Data.Functor.Combinator.HBifunctor t => Data.Functor.Combinator.HFunctor (Data.Functor.Combinator.F t i)
instance Data.Functor.Combinator.Tensor (GHC.Generics.:*:)
instance Data.Functor.Combinator.Tensor Data.Functor.Day.Day
instance Data.Functor.Combinator.HBifunctor (GHC.Generics.:*:)
instance Data.Functor.Combinator.HBifunctor Data.Functor.Day.Day
instance Data.Functor.Combinator.HBifunctor (GHC.Generics.:+:)
instance Data.Functor.Combinator.Interpret Data.Functor.Coyoneda.Coyoneda
instance Data.Functor.Combinator.Interpret Control.Applicative.Free.Ap
instance Data.Functor.Combinator.Interpret Control.Alternative.Free.Alt
instance Data.Functor.Combinator.HFunctor Data.Functor.Coyoneda.Coyoneda
instance Data.Functor.Combinator.HFunctor Control.Applicative.Free.Ap
instance Data.Functor.Combinator.HFunctor Control.Alternative.Free.Alt
instance Data.Functor.Combinator.HFunctor Control.Monad.Free.Church.F

module Data.Functor.Combinator.Class
type f ~> g = forall x. f x -> g x
infixr 0 ~>
class HFunctor t
hmap :: HFunctor t => (f ~> g) -> t f ~> t g

-- | Laws:
--   
--   <pre>
--   retract . inject == id
--   </pre>
class HFunctor t => Interpret t where {
    type family C t :: (Type -> Type) -> Constraint;
}
inject :: Interpret t => f ~> t f
retract :: (Interpret t, C t f) => t f ~> f
interpret :: (Interpret t, C t g) => (f ~> g) -> t f ~> g
class HBifunctor t
hleft :: HBifunctor t => (f ~> j) -> t f g ~> t j g
hright :: HBifunctor t => (g ~> k) -> t f g ~> t f k
hbimap :: HBifunctor t => (f ~> j) -> (g ~> k) -> t f g ~> t j k
class HBifunctor t => Tensor t where {
    type family I t :: Type -> Type;
}
intro1 :: Tensor t => f ~> t f (I t)
intro2 :: (Tensor t, Functor g) => g ~> t (I t) g
elim1 :: (Tensor t, Functor f) => t f (I t) ~> f
elim2 :: (Tensor t, Functor g) => t (I t) g ~> g
assoc :: (Tensor t, Functor f, Functor g, Functor h) => t f (t g h) ~> t (t f g) h
disassoc :: (Tensor t, Functor f, Functor g, Functor h) => t (t f g) h ~> t f (t g h)
data F t i f a
Done :: i a -> F t i f a
More :: t f (F t i f) a -> F t i f a
class (Tensor t, Interpret (TM t)) => Monoidal t where {
    type family TM t :: (Type -> Type) -> Type -> Type;
}
nilTM :: Monoidal t => I t ~> TM t f
consTM :: Monoidal t => t f (TM t f) ~> TM t f
unconsTM :: Monoidal t => TM t f ~> (I t :+: t f (TM t f))
appendTM :: Monoidal t => t (TM t f) (TM t f) ~> TM t f
fromF :: Monoidal t => F t (I t) f ~> TM t f
toF :: Monoidal t => TM t f ~> F t (I t) f
appendF :: Monoidal t => t (F t (I t) f) (F t (I t) f) ~> F t (I t) f
retractT :: (Monoidal t, C (TM t) f) => t f f ~> f
injectT :: (Monoidal t, C (TM t) f) => I t ~> f
toTM :: Monoidal t => t f f ~> TM t f
injectF :: forall t f. Tensor t => f ~> F t (I t) f
retractF :: forall t f. (Monoidal t, C (TM t) f) => F t (I t) f ~> f
interpretF :: forall t f g. (Monoidal t, C (TM t) g) => (f ~> g) -> F t (I t) f ~> g
newtype WrappedHBifunctor t (f :: Type -> Type) (g :: Type -> Type) a
WrappedHBifunctor :: t f g a -> WrappedHBifunctor t a
[unwrapHBifunctor] :: WrappedHBifunctor t a -> t f g a
data Cons :: ((Type -> Type) -> Type -> Type -> Type) -> (Type -> Type) -> (Type -> Type) -> Type -> Type
[:=>] :: f x -> p g x a -> Cons p f g a
type Comp = Cons Star
pattern Comp :: Functor f => f (g a) -> Comp f g a
unComp :: () => Comp f g a -> Functor f -> f (g a)
comp :: f (g a) -> Comp f g a
type DayCons = Cons Static
pattern DayCons :: Functor g => Day f g a -> DayCons f g a
unDayCons :: Cons Static b c d -> Day b c d

-- | Church-encoded Freer monad
newtype Free f a
Free :: (forall r. (a -> r) -> (forall s. f s -> (s -> r) -> r) -> r) -> Free f a
[runFree] :: Free f a -> forall r. (a -> r) -> (forall s. f s -> (s -> r) -> r) -> r
data Step f a
Step :: Natural -> f a -> Step f a
[stepPos] :: Step f a -> Natural
[stepVal] :: Step f a -> f a
data VoidT a
instance GHC.Base.Functor (t f g) => GHC.Base.Functor (Data.Functor.Combinator.Class.WrappedHBifunctor t f g)
instance GHC.Base.Functor f => GHC.Base.Functor (Data.Functor.Combinator.Class.Step f)
instance forall k (f :: k -> *) (a :: k). GHC.Classes.Ord (f a) => GHC.Classes.Ord (Data.Functor.Combinator.Class.Step f a)
instance forall k (f :: k -> *) (a :: k). GHC.Classes.Eq (f a) => GHC.Classes.Eq (Data.Functor.Combinator.Class.Step f a)
instance forall k (f :: k -> *) (a :: k). GHC.Show.Show (f a) => GHC.Show.Show (Data.Functor.Combinator.Class.Step f a)
instance GHC.Base.Functor Data.Functor.Combinator.Class.VoidT
instance forall k (a :: k). GHC.Classes.Ord (Data.Functor.Combinator.Class.VoidT a)
instance forall k (a :: k). GHC.Classes.Eq (Data.Functor.Combinator.Class.VoidT a)
instance forall k (a :: k). GHC.Show.Show (Data.Functor.Combinator.Class.VoidT a)
instance GHC.Base.Functor f => GHC.Base.Functor (Data.Functor.Combinator.Class.ListF f)
instance forall k (f :: k -> *) (a :: k). GHC.Classes.Ord (f a) => GHC.Classes.Ord (Data.Functor.Combinator.Class.ListF f a)
instance forall k (f :: k -> *) (a :: k). GHC.Classes.Eq (f a) => GHC.Classes.Eq (Data.Functor.Combinator.Class.ListF f a)
instance forall k (f :: k -> *) (a :: k). GHC.Show.Show (f a) => GHC.Show.Show (Data.Functor.Combinator.Class.ListF f a)
instance Data.Functor.Combinator.Class.HFunctor (Data.Functor.Day.Day f)
instance Data.Functor.Combinator.Class.HFunctor ((GHC.Generics.:*:) f)
instance Data.Functor.Combinator.Class.HFunctor ((GHC.Generics.:+:) f)
instance Data.Functor.Combinator.Class.HFunctor (Data.Functor.Combinator.Class.Cons Data.Profunctor.Types.Star f)
instance Data.Functor.Combinator.Class.HFunctor (Data.Functor.Combinator.Class.Cons Data.Semigroupoid.Static.Static f)
instance Data.Functor.Combinator.Class.HBifunctor Data.Functor.Combinator.Class.DayCons
instance Data.Functor.Combinator.Class.Tensor Data.Functor.Combinator.Class.DayCons
instance Data.Functor.Combinator.Class.Monoidal Data.Functor.Combinator.Class.DayCons
instance Data.Functor.Combinator.Class.HBifunctor Data.Functor.Combinator.Class.Comp
instance Data.Functor.Combinator.Class.Tensor Data.Functor.Combinator.Class.Comp
instance Data.Functor.Combinator.Class.Monoidal Data.Functor.Combinator.Class.Comp
instance GHC.Base.Functor (Data.Functor.Combinator.Class.Free f)
instance GHC.Base.Applicative (Data.Functor.Combinator.Class.Free f)
instance GHC.Base.Monad (Data.Functor.Combinator.Class.Free f)
instance Control.Monad.Free.Class.MonadFree f (Data.Functor.Combinator.Class.Free f)
instance Data.Functor.Combinator.Class.HFunctor Data.Functor.Combinator.Class.Free
instance Data.Functor.Combinator.Class.Interpret Data.Functor.Combinator.Class.Free
instance (forall x. GHC.Base.Functor (p g x)) => GHC.Base.Functor (Data.Functor.Combinator.Class.Cons p f g)
instance forall k (t :: (* -> *) -> (* -> *) -> k -> *) (f :: * -> *). Data.Functor.Combinator.Class.HBifunctor t => Data.Functor.Combinator.Class.HFunctor (Data.Functor.Combinator.Class.WrappedHBifunctor t f)
instance Data.Functor.Combinator.Class.HFunctor Data.Functor.Combinator.Class.Step
instance Data.Functor.Combinator.Class.Interpret Data.Functor.Combinator.Class.Step
instance Data.Functor.Combinator.Class.Monoidal (GHC.Generics.:+:)
instance Data.Functor.Combinator.Class.Tensor (GHC.Generics.:+:)
instance GHC.Base.Applicative f => GHC.Base.Applicative (Data.Functor.Combinator.Class.ListF f)
instance Data.Functor.Combinator.Class.Monoidal (GHC.Generics.:*:)
instance Data.Functor.Combinator.Class.HFunctor Data.Functor.Combinator.Class.ListF
instance Data.Functor.Combinator.Class.Interpret Data.Functor.Combinator.Class.ListF
instance Data.Functor.Combinator.Class.Monoidal Data.Functor.Day.Day
instance forall k (i :: * -> *) (t :: k -> (* -> *) -> * -> *) (f :: k). (GHC.Base.Functor i, forall (g :: * -> *). GHC.Base.Functor g => GHC.Base.Functor (t f g)) => GHC.Base.Functor (Data.Functor.Combinator.Class.F t i f)
instance forall k1 k2 (t :: (k1 -> *) -> (k2 -> *) -> k2 -> *) (i :: k2 -> *). Data.Functor.Combinator.Class.HBifunctor t => Data.Functor.Combinator.Class.HFunctor (Data.Functor.Combinator.Class.F t i)
instance Data.Functor.Combinator.Class.Tensor (GHC.Generics.:*:)
instance Data.Functor.Combinator.Class.Tensor Data.Functor.Day.Day
instance Data.Functor.Combinator.Class.HBifunctor (GHC.Generics.:*:)
instance Data.Functor.Combinator.Class.HBifunctor Data.Functor.Day.Day
instance Data.Functor.Combinator.Class.HBifunctor (GHC.Generics.:+:)
instance Data.Functor.Combinator.Class.Interpret Data.Functor.Coyoneda.Coyoneda
instance Data.Functor.Combinator.Class.Interpret Control.Applicative.Free.Ap
instance Data.Functor.Combinator.Class.Interpret Control.Alternative.Free.Alt
instance Data.Functor.Combinator.Class.HFunctor Data.Functor.Coyoneda.Coyoneda
instance Data.Functor.Combinator.Class.HFunctor Control.Applicative.Free.Ap
instance Data.Functor.Combinator.Class.HFunctor Control.Alternative.Free.Alt
instance Data.Functor.Combinator.Class.HFunctor Control.Monad.Free.Church.F

module Data.Functor.Combinator.Final

-- | A simple way to inject/reject into any eventual typeclass.
--   Essentially, <tt><a>Final</a> c</tt> is the "free c". <tt><a>Final</a>
--   <a>Monad</a></tt> is the free <a>Monad</a>, etc.
--   
--   Useful for lifting a functor <tt>f</tt> into arbitrary structure given
--   by a typeclass.
--   
--   Note that this doesn't have instances for all the typeclasses; you
--   probably have to define your own if you want to use <tt><a>Final</a>
--   c</tt> as an <i>instance</i> of <tt>c</tt> (using <a>liftFinal0</a>,
--   <a>liftFinal1</a>, <a>liftFinal2</a> for help). This is mostly meant
--   to be usable as a final <a>Interpret</a>, with
--   
--   <pre>
--   <a>inject</a>    :: f a -&gt; <a>Final</a> c f a
--   <a>interpret</a> :: (f <a>~&gt;</a> g) -&gt; <a>Final</a> c f a -&gt; g a
--   </pre>
newtype Final c f a
Final :: (forall g. c g => (forall x. f x -> g x) -> g a) -> Final c f a
[runFinal] :: Final c f a -> forall g. c g => (forall x. f x -> g x) -> g a
hoistFinalC :: (forall g x. (c g => g x) -> d g => g x) -> Final c f a -> Final d f a
liftFinal0 :: (forall g. c g => g a) -> Final c f a
liftFinal1 :: (forall g. c g => g a -> g b) -> Final c f a -> Final c f b
liftFinal2 :: (forall g. c g => g a -> g b -> g d) -> Final c f a -> Final c f b -> Final c f d
instance GHC.Base.Functor (Data.Functor.Combinator.Final.Final GHC.Base.Functor f)
instance GHC.Base.Functor (Data.Functor.Combinator.Final.Final GHC.Base.Applicative f)
instance GHC.Base.Applicative (Data.Functor.Combinator.Final.Final GHC.Base.Applicative f)
instance GHC.Base.Functor (Data.Functor.Combinator.Final.Final GHC.Base.Alternative f)
instance GHC.Base.Applicative (Data.Functor.Combinator.Final.Final GHC.Base.Alternative f)
instance GHC.Base.Alternative (Data.Functor.Combinator.Final.Final GHC.Base.Alternative f)
instance GHC.Base.Functor (Data.Functor.Combinator.Final.Final GHC.Base.Monad f)
instance GHC.Base.Applicative (Data.Functor.Combinator.Final.Final GHC.Base.Monad f)
instance GHC.Base.Monad (Data.Functor.Combinator.Final.Final GHC.Base.Monad f)
instance GHC.Base.Functor (Data.Functor.Combinator.Final.Final GHC.Base.MonadPlus f)
instance GHC.Base.Applicative (Data.Functor.Combinator.Final.Final GHC.Base.MonadPlus f)
instance GHC.Base.Monad (Data.Functor.Combinator.Final.Final GHC.Base.MonadPlus f)
instance GHC.Base.Alternative (Data.Functor.Combinator.Final.Final GHC.Base.MonadPlus f)
instance GHC.Base.MonadPlus (Data.Functor.Combinator.Final.Final GHC.Base.MonadPlus f)
instance Data.Functor.Combinator.Class.HFunctor (Data.Functor.Combinator.Final.Final c)
instance Data.Functor.Combinator.Class.Interpret (Data.Functor.Combinator.Final.Final c)
