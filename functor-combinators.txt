-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/mstksg/functor-combinators#readme</a>
@package functor-combinators
@version 0.1.0.0

module Control.Applicative.ListF

-- | This is the Free <a>Plus</a>.
newtype ListF f a
ListF :: [f a] -> ListF f a
[runListF] :: ListF f a -> [f a]
instance GHC.Base.Functor f => GHC.Base.Functor (Control.Applicative.ListF.ListF f)
instance GHC.Classes.Ord (f a) => GHC.Classes.Ord (Control.Applicative.ListF.ListF f a)
instance GHC.Classes.Eq (f a) => GHC.Classes.Eq (Control.Applicative.ListF.ListF f a)
instance GHC.Show.Show (f a) => GHC.Show.Show (Control.Applicative.ListF.ListF f a)
instance GHC.Base.Applicative f => GHC.Base.Applicative (Control.Applicative.ListF.ListF f)
instance GHC.Base.Functor f => Data.Functor.Alt.Alt (Control.Applicative.ListF.ListF f)
instance GHC.Base.Functor f => Data.Functor.Plus.Plus (Control.Applicative.ListF.ListF f)

module Control.Applicative.Step
data Step f a
Step :: Natural -> f a -> Step f a
[stepPos] :: Step f a -> Natural
[stepVal] :: Step f a -> f a
class Applicative f => AccumNat f
stepWith :: AccumNat f => Natural -> a -> f a
step :: AccumNat f => Natural -> f ()
instance GHC.Base.Functor f => GHC.Base.Functor (Control.Applicative.Step.Step f)
instance GHC.Classes.Ord (f a) => GHC.Classes.Ord (Control.Applicative.Step.Step f a)
instance GHC.Classes.Eq (f a) => GHC.Classes.Eq (Control.Applicative.Step.Step f a)
instance GHC.Show.Show (f a) => GHC.Show.Show (Control.Applicative.Step.Step f a)
instance GHC.Base.Applicative f => Control.Applicative.Step.AccumNat (Control.Applicative.Step.Step f)
instance GHC.Base.Monad m => Control.Applicative.Step.AccumNat (Control.Monad.Trans.Writer.Lazy.WriterT (Data.Semigroup.Internal.Sum GHC.Natural.Natural) m)
instance GHC.Base.Applicative f => GHC.Base.Applicative (Control.Applicative.Step.Step f)

module Data.Functor.Combinator
type f ~> g = forall x. f x -> g x
infixr 0 ~>
class HFunctor t
hmap :: HFunctor t => (f ~> g) -> t f ~> t g

-- | Laws:
--   
--   <pre>
--   retract . inject == id
--   </pre>
class HFunctor t => Interpret t where {
    type family C t :: (Type -> Type) -> Constraint;
}
inject :: Interpret t => f ~> t f
retract :: (Interpret t, C t f) => t f ~> f
interpret :: (Interpret t, C t g) => (f ~> g) -> t f ~> g
class HBifunctor t
hleft :: HBifunctor t => (f ~> j) -> t f g ~> t j g
hright :: HBifunctor t => (g ~> k) -> t f g ~> t f k
hbimap :: HBifunctor t => (f ~> j) -> (g ~> k) -> t f g ~> t j k
class HBifunctor t => Tensor t where {
    type family I t :: Type -> Type;
}
intro1 :: Tensor t => f ~> t f (I t)
intro2 :: (Tensor t, Functor g) => g ~> t (I t) g
elim1 :: (Tensor t, Functor f) => t f (I t) ~> f
elim2 :: (Tensor t, Functor g) => t (I t) g ~> g
assoc :: (Tensor t, Functor f, Functor g, Functor h) => t f (t g h) ~> t (t f g) h
disassoc :: (Tensor t, Functor f, Functor g, Functor h) => t (t f g) h ~> t f (t g h)
data F t i f a
Done :: i a -> F t i f a
More :: t f (F t i f) a -> F t i f a
class (Tensor t, Interpret (TM t)) => Monoidal t where {
    type family TM t :: (Type -> Type) -> Type -> Type;
}
nilTM :: Monoidal t => I t ~> TM t f
consTM :: Monoidal t => t f (TM t f) ~> TM t f
unconsTM :: Monoidal t => TM t f ~> (I t :+: t f (TM t f))
appendTM :: Monoidal t => t (TM t f) (TM t f) ~> TM t f
fromF :: Monoidal t => F t (I t) f ~> TM t f
toF :: Monoidal t => TM t f ~> F t (I t) f
appendF :: Monoidal t => t (F t (I t) f) (F t (I t) f) ~> F t (I t) f
retractT :: (Monoidal t, C (TM t) f) => t f f ~> f
injectT :: (Monoidal t, C (TM t) f) => I t ~> f
toTM :: Monoidal t => t f f ~> TM t f
injectF :: forall t f. Tensor t => f ~> F t (I t) f
retractF :: forall t f. (Monoidal t, C (TM t) f) => F t (I t) f ~> f
interpretF :: forall t f g. (Monoidal t, C (TM t) g) => (f ~> g) -> F t (I t) f ~> g
newtype WrappedHBifunctor t (f :: Type -> Type) (g :: Type -> Type) a
WrappedHBifunctor :: t f g a -> WrappedHBifunctor t a
[unwrapHBifunctor] :: WrappedHBifunctor t a -> t f g a
data Cons :: ((Type -> Type) -> Type -> Type -> Type) -> (Type -> Type) -> (Type -> Type) -> Type -> Type
[:=>] :: f x -> p g x a -> Cons p f g a
type Comp = Cons Star
pattern Comp :: Functor f => f (g a) -> Comp f g a
unComp :: () => Comp f g a -> Functor f -> f (g a)
comp :: f (g a) -> Comp f g a
type DayCons = Cons Static
pattern DayCons :: Functor g => Day f g a -> DayCons f g a
unDayCons :: Cons Static b c d -> Day b c d

-- | Church-encoded Freer monad
newtype Free f a
Free :: (forall r. (a -> r) -> (forall s. f s -> (s -> r) -> r) -> r) -> Free f a
[runFree] :: Free f a -> forall r. (a -> r) -> (forall s. f s -> (s -> r) -> r) -> r
data Step f a
Step :: Natural -> f a -> Step f a
[stepPos] :: Step f a -> Natural
[stepVal] :: Step f a -> f a
data VoidT a
instance GHC.Base.Functor (t f g) => GHC.Base.Functor (Data.Functor.Combinator.WrappedHBifunctor t f g)
instance GHC.Base.Functor f => GHC.Base.Functor (Data.Functor.Combinator.Step f)
instance forall k (f :: k -> *) (a :: k). GHC.Classes.Ord (f a) => GHC.Classes.Ord (Data.Functor.Combinator.Step f a)
instance forall k (f :: k -> *) (a :: k). GHC.Classes.Eq (f a) => GHC.Classes.Eq (Data.Functor.Combinator.Step f a)
instance forall k (f :: k -> *) (a :: k). GHC.Show.Show (f a) => GHC.Show.Show (Data.Functor.Combinator.Step f a)
instance GHC.Base.Functor Data.Functor.Combinator.VoidT
instance forall k (a :: k). GHC.Classes.Ord (Data.Functor.Combinator.VoidT a)
instance forall k (a :: k). GHC.Classes.Eq (Data.Functor.Combinator.VoidT a)
instance forall k (a :: k). GHC.Show.Show (Data.Functor.Combinator.VoidT a)
instance GHC.Base.Functor f => GHC.Base.Functor (Data.Functor.Combinator.ListF f)
instance forall k (f :: k -> *) (a :: k). GHC.Classes.Ord (f a) => GHC.Classes.Ord (Data.Functor.Combinator.ListF f a)
instance forall k (f :: k -> *) (a :: k). GHC.Classes.Eq (f a) => GHC.Classes.Eq (Data.Functor.Combinator.ListF f a)
instance forall k (f :: k -> *) (a :: k). GHC.Show.Show (f a) => GHC.Show.Show (Data.Functor.Combinator.ListF f a)
instance Data.Functor.Combinator.HFunctor (Data.Functor.Day.Day f)
instance Data.Functor.Combinator.HFunctor ((GHC.Generics.:*:) f)
instance Data.Functor.Combinator.HFunctor ((GHC.Generics.:+:) f)
instance Data.Functor.Combinator.HFunctor (Data.Functor.Combinator.Cons Data.Profunctor.Types.Star f)
instance Data.Functor.Combinator.HFunctor (Data.Functor.Combinator.Cons Data.Semigroupoid.Static.Static f)
instance GHC.Base.Functor (Data.Functor.Combinator.Final GHC.Base.Functor f)
instance forall k (c :: (k -> *) -> GHC.Types.Constraint). Data.Functor.Combinator.HFunctor (Data.Functor.Combinator.Final c)
instance Data.Functor.Combinator.Interpret (Data.Functor.Combinator.Final c)
instance Data.Functor.Combinator.HBifunctor Data.Functor.Combinator.DayCons
instance Data.Functor.Combinator.Tensor Data.Functor.Combinator.DayCons
instance Data.Functor.Combinator.Monoidal Data.Functor.Combinator.DayCons
instance Data.Functor.Combinator.HBifunctor Data.Functor.Combinator.Comp
instance Data.Functor.Combinator.Tensor Data.Functor.Combinator.Comp
instance Data.Functor.Combinator.Monoidal Data.Functor.Combinator.Comp
instance GHC.Base.Functor (Data.Functor.Combinator.Free f)
instance GHC.Base.Applicative (Data.Functor.Combinator.Free f)
instance GHC.Base.Monad (Data.Functor.Combinator.Free f)
instance Control.Monad.Free.Class.MonadFree f (Data.Functor.Combinator.Free f)
instance Data.Functor.Combinator.HFunctor Data.Functor.Combinator.Free
instance Data.Functor.Combinator.Interpret Data.Functor.Combinator.Free
instance (forall x. GHC.Base.Functor (p g x)) => GHC.Base.Functor (Data.Functor.Combinator.Cons p f g)
instance forall k (t :: (* -> *) -> (* -> *) -> k -> *) (f :: * -> *). Data.Functor.Combinator.HBifunctor t => Data.Functor.Combinator.HFunctor (Data.Functor.Combinator.WrappedHBifunctor t f)
instance Data.Functor.Combinator.HFunctor Data.Functor.Combinator.Step
instance Data.Functor.Combinator.Interpret Data.Functor.Combinator.Step
instance Data.Functor.Combinator.Monoidal (GHC.Generics.:+:)
instance Data.Functor.Combinator.Tensor (GHC.Generics.:+:)
instance GHC.Base.Applicative f => GHC.Base.Applicative (Data.Functor.Combinator.ListF f)
instance Data.Functor.Combinator.Monoidal (GHC.Generics.:*:)
instance Data.Functor.Combinator.HFunctor Data.Functor.Combinator.ListF
instance Data.Functor.Combinator.Interpret Data.Functor.Combinator.ListF
instance Data.Functor.Combinator.Monoidal Data.Functor.Day.Day
instance forall k (i :: * -> *) (t :: k -> (* -> *) -> * -> *) (f :: k). (GHC.Base.Functor i, forall (g :: * -> *). GHC.Base.Functor g => GHC.Base.Functor (t f g)) => GHC.Base.Functor (Data.Functor.Combinator.F t i f)
instance forall k1 k2 (t :: (k1 -> *) -> (k2 -> *) -> k2 -> *) (i :: k2 -> *). Data.Functor.Combinator.HBifunctor t => Data.Functor.Combinator.HFunctor (Data.Functor.Combinator.F t i)
instance Data.Functor.Combinator.Tensor (GHC.Generics.:*:)
instance Data.Functor.Combinator.Tensor Data.Functor.Day.Day
instance Data.Functor.Combinator.HBifunctor (GHC.Generics.:*:)
instance Data.Functor.Combinator.HBifunctor Data.Functor.Day.Day
instance Data.Functor.Combinator.HBifunctor (GHC.Generics.:+:)
instance Data.Functor.Combinator.Interpret Data.Functor.Coyoneda.Coyoneda
instance Data.Functor.Combinator.Interpret Control.Applicative.Free.Ap
instance Data.Functor.Combinator.Interpret Control.Alternative.Free.Alt
instance Data.Functor.Combinator.HFunctor Data.Functor.Coyoneda.Coyoneda
instance Data.Functor.Combinator.HFunctor Control.Applicative.Free.Ap
instance Data.Functor.Combinator.HFunctor Control.Alternative.Free.Alt
instance Data.Functor.Combinator.HFunctor Control.Monad.Free.Church.F

module Data.Functor.Combinator.Class
type f ~> g = forall x. f x -> g x
infixr 0 ~>
class HFunctor t
hmap :: HFunctor t => (f ~> g) -> t f ~> t g

-- | Laws:
--   
--   <pre>
--   retract . inject == id
--   </pre>
class HFunctor t => Interpret t where {
    type family C t :: (Type -> Type) -> Constraint;
}
inject :: Interpret t => f ~> t f
retract :: (Interpret t, C t f) => t f ~> f
interpret :: (Interpret t, C t g) => (f ~> g) -> t f ~> g
class HBifunctor t
hleft :: HBifunctor t => (f ~> j) -> t f g ~> t j g
hright :: HBifunctor t => (g ~> k) -> t f g ~> t f k
hbimap :: HBifunctor t => (f ~> j) -> (g ~> k) -> t f g ~> t j k
class HBifunctor t => Tensor t where {
    type family I t :: Type -> Type;
}
intro1 :: Tensor t => f ~> t f (I t)
intro2 :: (Tensor t, Functor g) => g ~> t (I t) g
elim1 :: (Tensor t, Functor f) => t f (I t) ~> f
elim2 :: (Tensor t, Functor g) => t (I t) g ~> g
assoc :: (Tensor t, Functor f, Functor g, Functor h) => t f (t g h) ~> t (t f g) h
disassoc :: (Tensor t, Functor f, Functor g, Functor h) => t (t f g) h ~> t f (t g h)
data F t i f a
Done :: i a -> F t i f a
More :: t f (F t i f) a -> F t i f a
class (Tensor t, Interpret (TM t)) => Monoidal t where {
    type family TM t :: (Type -> Type) -> Type -> Type;
}
nilTM :: Monoidal t => I t ~> TM t f
consTM :: Monoidal t => t f (TM t f) ~> TM t f
unconsTM :: Monoidal t => TM t f ~> (I t :+: t f (TM t f))
appendTM :: Monoidal t => t (TM t f) (TM t f) ~> TM t f
fromF :: Monoidal t => F t (I t) f ~> TM t f
toF :: Monoidal t => TM t f ~> F t (I t) f
appendF :: Monoidal t => t (F t (I t) f) (F t (I t) f) ~> F t (I t) f
retractT :: (Monoidal t, C (TM t) f) => t f f ~> f
injectT :: (Monoidal t, C (TM t) f) => I t ~> f
toTM :: Monoidal t => t f f ~> TM t f
injectF :: forall t f. Tensor t => f ~> F t (I t) f
retractF :: forall t f. (Monoidal t, C (TM t) f) => F t (I t) f ~> f
interpretF :: forall t f g. (Monoidal t, C (TM t) g) => (f ~> g) -> F t (I t) f ~> g
newtype WrappedHBifunctor t (f :: Type -> Type) (g :: Type -> Type) a
WrappedHBifunctor :: t f g a -> WrappedHBifunctor t a
[unwrapHBifunctor] :: WrappedHBifunctor t a -> t f g a

-- | Church-encoded Freer monad
newtype Free f a
Free :: (forall r. (a -> r) -> (forall s. f s -> (s -> r) -> r) -> r) -> Free f a
[runFree] :: Free f a -> forall r. (a -> r) -> (forall s. f s -> (s -> r) -> r) -> r
data VoidT a
instance GHC.Base.Functor (t f g) => GHC.Base.Functor (Data.Functor.Combinator.Class.WrappedHBifunctor t f g)
instance GHC.Base.Functor Data.Functor.Combinator.Class.VoidT
instance forall k (a :: k). GHC.Classes.Ord (Data.Functor.Combinator.Class.VoidT a)
instance forall k (a :: k). GHC.Classes.Eq (Data.Functor.Combinator.Class.VoidT a)
instance forall k (a :: k). GHC.Show.Show (Data.Functor.Combinator.Class.VoidT a)
instance Data.Functor.Combinator.Class.HFunctor (Data.Functor.Day.Day f)
instance Data.Functor.Combinator.Class.HFunctor ((GHC.Generics.:*:) f)
instance Data.Functor.Combinator.Class.HFunctor ((GHC.Generics.:+:) f)
instance GHC.Base.Functor (Data.Functor.Combinator.Class.Free f)
instance GHC.Base.Applicative (Data.Functor.Combinator.Class.Free f)
instance GHC.Base.Monad (Data.Functor.Combinator.Class.Free f)
instance Control.Monad.Free.Class.MonadFree f (Data.Functor.Combinator.Class.Free f)
instance Data.Functor.Combinator.Class.HFunctor Data.Functor.Combinator.Class.Free
instance Data.Functor.Combinator.Class.Interpret Data.Functor.Combinator.Class.Free
instance forall k (t :: (* -> *) -> (* -> *) -> k -> *) (f :: * -> *). Data.Functor.Combinator.Class.HBifunctor t => Data.Functor.Combinator.Class.HFunctor (Data.Functor.Combinator.Class.WrappedHBifunctor t f)
instance Data.Functor.Combinator.Class.Tensor (GHC.Generics.:+:)
instance Data.Functor.Combinator.Class.Monoidal (GHC.Generics.:*:)
instance Data.Functor.Combinator.Class.Monoidal Data.Functor.Day.Day
instance Data.Functor.Combinator.Class.Monoidal (GHC.Generics.:+:)
instance forall k (i :: * -> *) (t :: k -> (* -> *) -> * -> *) (f :: k). (GHC.Base.Functor i, forall (g :: * -> *). GHC.Base.Functor g => GHC.Base.Functor (t f g)) => GHC.Base.Functor (Data.Functor.Combinator.Class.F t i f)
instance forall k1 k2 (t :: (k1 -> *) -> (k2 -> *) -> k2 -> *) (i :: k2 -> *). Data.Functor.Combinator.Class.HBifunctor t => Data.Functor.Combinator.Class.HFunctor (Data.Functor.Combinator.Class.F t i)
instance Data.Functor.Combinator.Class.Tensor (GHC.Generics.:*:)
instance Data.Functor.Combinator.Class.Tensor Data.Functor.Day.Day
instance Data.Functor.Combinator.Class.HBifunctor (GHC.Generics.:*:)
instance Data.Functor.Combinator.Class.HBifunctor Data.Functor.Day.Day
instance Data.Functor.Combinator.Class.HBifunctor (GHC.Generics.:+:)
instance Data.Functor.Combinator.Class.Interpret Data.Functor.Coyoneda.Coyoneda
instance Data.Functor.Combinator.Class.Interpret Control.Applicative.Free.Ap
instance Data.Functor.Combinator.Class.Interpret Control.Applicative.ListF.ListF
instance Data.Functor.Combinator.Class.Interpret Control.Alternative.Free.Alt
instance Data.Functor.Combinator.Class.Interpret Control.Applicative.Step.Step
instance Data.Functor.Combinator.Class.HFunctor Data.Functor.Coyoneda.Coyoneda
instance Data.Functor.Combinator.Class.HFunctor Control.Applicative.Free.Ap
instance Data.Functor.Combinator.Class.HFunctor Control.Applicative.ListF.ListF
instance Data.Functor.Combinator.Class.HFunctor Control.Alternative.Free.Alt
instance Data.Functor.Combinator.Class.HFunctor Control.Applicative.Step.Step
instance Data.Functor.Combinator.Class.HFunctor Control.Monad.Free.Church.F

module Data.Functor.Combinator.Cons

-- | A lot of tensors can be factored out into a <a>Cons</a> on some
--   parameterized profunctor. For example, we have:
--   
--   <pre>
--   <a>:.:</a> = <a>Cons</a> <a>Star</a>
--   <a>Day</a> = <a>Cons</a> <a>Static</a>
--   <a>:*:</a> = <a>Cons</a> <a>ProdK</a>
--   </pre>
--   
--   In the case of <a>:.:</a>, this actually allows us to have
--   <a>HFunctor</a> and <a>Interpret</a> instances for functor
--   composition, because the representation of <a>:.:</a> normally does
--   not allow this. This gives us a proper tensor to form <a>Free</a>,
--   which makes the free monad work nicely within our system.
--   
--   In the normal case, you can just use <a>Day</a> and <a>:*:</a> instead
--   of <tt><a>DayCons</a> = <a>Cons</a> <a>Static</a></tt> and
--   <tt><a>ProdCons</a> = <a>Cons</a> <a>ProdK</a></tt>. The only one that
--   gives us extra power is <tt><a>Comp</a> = <a>Cons</a>
--   <a>Star</a></tt>.
--   
--   You can use <a>DayCons</a> and <a>ProdCons</a> as <a>Day</a> and
--   <a>:*:</a> using the provided pattern synonyms.
data Cons :: ((Type -> Type) -> Type -> Type -> Type) -> (Type -> Type) -> (Type -> Type) -> Type -> Type
pattern Comp :: Functor f => f (g a) -> Comp f g a
pattern DayCons :: Functor g => Day f g a -> DayCons f g a
pattern ProdCons :: Functor f => (f :*: g) a -> ProdCons f g a

-- | A version of <a>:.:</a> that permits <a>HBifunctor</a>, <a>Tensor</a>,
--   and <a>Monoidal</a> instances.
type Comp = Cons Star
unComp :: () => Comp f g a -> Functor f -> f (g a)
comp :: f (g a) -> Comp f g a
type DayCons = Cons Static
unDayCons :: DayCons b c ~> Day b c
data ProdK g a b
ProdK :: (a -> b) -> g b -> ProdK g a b
type ProdCons = Cons ProdK
unProdCons :: () => ProdCons f g a -> Functor f -> (f :*: g) a
prodCons :: (f :*: g) ~> ProdCons f g
instance Data.Functor.Plus.Plus (Data.Functor.Combinator.Cons.ListFCo f)
instance GHC.Base.Applicative f => GHC.Base.Applicative (Data.Functor.Combinator.Cons.ListFCo f)
instance GHC.Base.Functor (Data.Functor.Combinator.Cons.ListFCo f)
instance Data.Functor.Combinator.Class.HFunctor (Data.Functor.Combinator.Cons.Cons Data.Profunctor.Types.Star f)
instance Data.Functor.Combinator.Class.HFunctor (Data.Functor.Combinator.Cons.Cons Data.Semigroupoid.Static.Static f)
instance Data.Functor.Combinator.Class.HFunctor (Data.Functor.Combinator.Cons.Cons Data.Functor.Combinator.Cons.ProdK f)
instance Data.Functor.Alt.Alt (Data.Functor.Combinator.Cons.ListFCo f)
instance Data.Functor.Combinator.Class.HFunctor Data.Functor.Combinator.Cons.ListFCo
instance Data.Functor.Combinator.Class.Interpret Data.Functor.Combinator.Cons.ListFCo
instance Data.Functor.Combinator.Class.Monoidal Data.Functor.Combinator.Cons.ProdCons
instance Data.Functor.Combinator.Class.HBifunctor Data.Functor.Combinator.Cons.ProdCons
instance Data.Functor.Combinator.Class.Tensor Data.Functor.Combinator.Cons.ProdCons
instance Data.Functor.Combinator.Class.HBifunctor Data.Functor.Combinator.Cons.DayCons
instance Data.Functor.Combinator.Class.Tensor Data.Functor.Combinator.Cons.DayCons
instance Data.Functor.Combinator.Class.Monoidal Data.Functor.Combinator.Cons.DayCons
instance Data.Functor.Combinator.Class.HBifunctor Data.Functor.Combinator.Cons.Comp
instance Data.Functor.Combinator.Class.Tensor Data.Functor.Combinator.Cons.Comp
instance Data.Functor.Combinator.Class.Monoidal Data.Functor.Combinator.Cons.Comp
instance (forall x. GHC.Base.Functor (p g x)) => GHC.Base.Functor (Data.Functor.Combinator.Cons.Cons p f g)

module Data.Functor.Combinator.Final

-- | A simple way to inject/reject into any eventual typeclass.
--   Essentially, <tt><a>Final</a> c</tt> is the "free c". <tt><a>Final</a>
--   <a>Monad</a></tt> is the free <a>Monad</a>, etc.
--   
--   Useful for lifting a functor <tt>f</tt> into arbitrary structure given
--   by a typeclass.
--   
--   Note that this doesn't have instances for all the typeclasses; you
--   probably have to define your own if you want to use <tt><a>Final</a>
--   c</tt> as an <i>instance</i> of <tt>c</tt> (using <a>liftFinal0</a>,
--   <a>liftFinal1</a>, <a>liftFinal2</a> for help). This is mostly meant
--   to be usable as a final <a>Interpret</a>, with
--   
--   <pre>
--   <a>inject</a>    :: f a -&gt; <a>Final</a> c f a
--   <a>interpret</a> :: (f <a>~&gt;</a> g) -&gt; <a>Final</a> c f a -&gt; g a
--   </pre>
newtype Final c f a
Final :: (forall g. c g => (forall x. f x -> g x) -> g a) -> Final c f a
[runFinal] :: Final c f a -> forall g. c g => (forall x. f x -> g x) -> g a
hoistFinalC :: (forall g x. (c g => g x) -> d g => g x) -> Final c f a -> Final d f a
liftFinal0 :: (forall g. c g => g a) -> Final c f a
liftFinal1 :: (forall g. c g => g a -> g b) -> Final c f a -> Final c f b
liftFinal2 :: (forall g. c g => g a -> g b -> g d) -> Final c f a -> Final c f b -> Final c f d
instance GHC.Base.Functor (Data.Functor.Combinator.Final.Final GHC.Base.Functor f)
instance GHC.Base.Functor (Data.Functor.Combinator.Final.Final GHC.Base.Applicative f)
instance GHC.Base.Applicative (Data.Functor.Combinator.Final.Final GHC.Base.Applicative f)
instance GHC.Base.Functor (Data.Functor.Combinator.Final.Final GHC.Base.Alternative f)
instance GHC.Base.Applicative (Data.Functor.Combinator.Final.Final GHC.Base.Alternative f)
instance GHC.Base.Alternative (Data.Functor.Combinator.Final.Final GHC.Base.Alternative f)
instance GHC.Base.Functor (Data.Functor.Combinator.Final.Final GHC.Base.Monad f)
instance GHC.Base.Applicative (Data.Functor.Combinator.Final.Final GHC.Base.Monad f)
instance GHC.Base.Monad (Data.Functor.Combinator.Final.Final GHC.Base.Monad f)
instance GHC.Base.Functor (Data.Functor.Combinator.Final.Final GHC.Base.MonadPlus f)
instance GHC.Base.Applicative (Data.Functor.Combinator.Final.Final GHC.Base.MonadPlus f)
instance GHC.Base.Monad (Data.Functor.Combinator.Final.Final GHC.Base.MonadPlus f)
instance GHC.Base.Alternative (Data.Functor.Combinator.Final.Final GHC.Base.MonadPlus f)
instance GHC.Base.MonadPlus (Data.Functor.Combinator.Final.Final GHC.Base.MonadPlus f)
instance Data.Functor.Combinator.Class.HFunctor (Data.Functor.Combinator.Final.Final c)
instance Data.Functor.Combinator.Class.Interpret (Data.Functor.Combinator.Final.Final c)
