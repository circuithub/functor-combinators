-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/mstksg/functor-combinators#readme</a>
@package functor-combinators
@version 0.1.0.0


-- | This module provides functor combinators that are wrappers over lists
--   or maybes of <tt>f a</tt>s, especially for their <a>Interpret</a>
--   instances.
--   
--   Each one transforms a functor into some product of itself. For
--   example, <tt><a>NonEmptyF</a> f</tt> represents <tt>f <a>:*:</a>
--   f</tt>, or <tt>f :*: f :*: f</tt>, or <tt>f :*: f :*: f :*: f</tt>,
--   etc.
module Control.Applicative.ListF

-- | A list of <tt>f a</tt>s. Can be used to describe a product of many
--   different values of type <tt>f a</tt>.
--   
--   This is the Free <a>Plus</a>.
newtype ListF f a
ListF :: [f a] -> ListF f a
[runListF] :: ListF f a -> [f a]

-- | Map a function over the inside of a <a>ListF</a>.
mapListF :: ([f a] -> [g b]) -> ListF f a -> ListF g b

-- | A non-empty list of <tt>f a</tt>s. Can be used to describe a product
--   between many different possible values of type <tt>f a</tt>.
--   
--   Essentially:
--   
--   <pre>
--   <a>NonEmptyF</a> f
--       ~ f                          -- one f
--     <a>:+:</a> (f <a>:*:</a> f)              -- two f's
--     :+: (f :*: f :*: f)            -- three f's
--     :+: (f :*: f :*: f :*: f)      -- four f's
--     :+: ...                        -- etc.
--   </pre>
--   
--   This is the Free <a>Plus</a>.
newtype NonEmptyF f a
NonEmptyF :: NonEmpty (f a) -> NonEmptyF f a
[runNonEmptyF] :: NonEmptyF f a -> NonEmpty (f a)

-- | Treat a <tt><a>NonEmptyF</a> f</tt> as a product between an <tt>f</tt>
--   and a <tt><a>ListF</a> f</tt>.
--   
--   <a>nonEmptyProd</a> is the record accessor.
pattern ProdNonEmpty :: (f :*: ListF f) a -> NonEmptyF f a

-- | Map a function over the inside of a <a>NonEmptyF</a>.
mapNonEmptyF :: (NonEmpty (f a) -> NonEmpty (g b)) -> NonEmptyF f a -> NonEmptyF g b

-- | Convert a <a>NonEmptyF</a> into a <a>ListF</a> with at least one item.
toListF :: NonEmptyF f ~> ListF f

-- | Convert a <a>ListF</a> either a <a>NonEmptyF</a>, or a <a>Proxy</a> in
--   the case that the list was empty.
fromListF :: ListF f ~> (Proxy :+: NonEmptyF f)

-- | A maybe <tt>f a</tt>.
--   
--   Can be useful for describing a "an <tt>f a</tt> that may or may not be
--   there".
--   
--   This is the free structure for a "fail"-like typeclass that only has
--   <tt>zero :: f a</tt>.
newtype MaybeF f a
MaybeF :: Maybe (f a) -> MaybeF f a
[runMaybeF] :: MaybeF f a -> Maybe (f a)

-- | Map a function over the inside of a <a>MaybeF</a>.
mapMaybeF :: (Maybe (f a) -> Maybe (g b)) -> MaybeF f a -> MaybeF g b

-- | Convert a <a>ListF</a> into a <a>MaybeF</a> containing the first <tt>f
--   a</tt> in the list, if it exists.
listToMaybeF :: ListF f ~> MaybeF f

-- | Convert a <a>MaybeF</a> into a <a>ListF</a> with zero or one items.
maybeToListF :: MaybeF f ~> ListF f
instance Data.Functor.Classes.Ord1 f => Data.Functor.Classes.Ord1 (Control.Applicative.ListF.MaybeF f)
instance GHC.Base.Applicative f => GHC.Base.Applicative (Control.Applicative.ListF.MaybeF f)
instance GHC.Base.Functor f => Data.Functor.Alt.Alt (Control.Applicative.ListF.MaybeF f)
instance GHC.Base.Functor f => Data.Functor.Plus.Plus (Control.Applicative.ListF.MaybeF f)
instance GHC.Base.Applicative f => GHC.Base.Alternative (Control.Applicative.ListF.MaybeF f)
instance GHC.Base.Semigroup (Control.Applicative.ListF.MaybeF f a)
instance GHC.Base.Monoid (Control.Applicative.ListF.MaybeF f a)
instance Data.Functor.Classes.Eq1 f => Data.Functor.Classes.Eq1 (Control.Applicative.ListF.MaybeF f)
instance Data.Functor.Classes.Read1 f => Data.Functor.Classes.Read1 (Control.Applicative.ListF.MaybeF f)
instance Data.Functor.Classes.Show1 f => Data.Functor.Classes.Show1 (Control.Applicative.ListF.MaybeF f)
instance (Data.Typeable.Internal.Typeable f, Data.Typeable.Internal.Typeable a, Data.Data.Data (f a)) => Data.Data.Data (Control.Applicative.ListF.MaybeF f a)
instance GHC.Generics.Generic (Control.Applicative.ListF.MaybeF f a)
instance Data.Traversable.Traversable f => Data.Traversable.Traversable (Control.Applicative.ListF.MaybeF f)
instance Data.Foldable.Foldable f => Data.Foldable.Foldable (Control.Applicative.ListF.MaybeF f)
instance GHC.Base.Functor f => GHC.Base.Functor (Control.Applicative.ListF.MaybeF f)
instance GHC.Classes.Ord (f a) => GHC.Classes.Ord (Control.Applicative.ListF.MaybeF f a)
instance GHC.Classes.Eq (f a) => GHC.Classes.Eq (Control.Applicative.ListF.MaybeF f a)
instance GHC.Read.Read (f a) => GHC.Read.Read (Control.Applicative.ListF.MaybeF f a)
instance GHC.Show.Show (f a) => GHC.Show.Show (Control.Applicative.ListF.MaybeF f a)
instance Data.Functor.Classes.Ord1 f => Data.Functor.Classes.Ord1 (Control.Applicative.ListF.NonEmptyF f)
instance GHC.Base.Applicative f => GHC.Base.Applicative (Control.Applicative.ListF.NonEmptyF f)
instance GHC.Base.Functor f => Data.Functor.Alt.Alt (Control.Applicative.ListF.NonEmptyF f)
instance GHC.Base.Semigroup (Control.Applicative.ListF.NonEmptyF f a)
instance Data.Functor.Classes.Eq1 f => Data.Functor.Classes.Eq1 (Control.Applicative.ListF.NonEmptyF f)
instance Data.Functor.Classes.Read1 f => Data.Functor.Classes.Read1 (Control.Applicative.ListF.NonEmptyF f)
instance Data.Functor.Classes.Show1 f => Data.Functor.Classes.Show1 (Control.Applicative.ListF.NonEmptyF f)
instance (Data.Typeable.Internal.Typeable f, Data.Typeable.Internal.Typeable a, Data.Data.Data (f a)) => Data.Data.Data (Control.Applicative.ListF.NonEmptyF f a)
instance GHC.Generics.Generic (Control.Applicative.ListF.NonEmptyF f a)
instance Data.Traversable.Traversable f => Data.Traversable.Traversable (Control.Applicative.ListF.NonEmptyF f)
instance Data.Foldable.Foldable f => Data.Foldable.Foldable (Control.Applicative.ListF.NonEmptyF f)
instance GHC.Base.Functor f => GHC.Base.Functor (Control.Applicative.ListF.NonEmptyF f)
instance GHC.Classes.Ord (f a) => GHC.Classes.Ord (Control.Applicative.ListF.NonEmptyF f a)
instance GHC.Classes.Eq (f a) => GHC.Classes.Eq (Control.Applicative.ListF.NonEmptyF f a)
instance GHC.Read.Read (f a) => GHC.Read.Read (Control.Applicative.ListF.NonEmptyF f a)
instance GHC.Show.Show (f a) => GHC.Show.Show (Control.Applicative.ListF.NonEmptyF f a)
instance Data.Functor.Classes.Ord1 f => Data.Functor.Classes.Ord1 (Control.Applicative.ListF.ListF f)
instance GHC.Base.Applicative f => GHC.Base.Applicative (Control.Applicative.ListF.ListF f)
instance GHC.Base.Functor f => Data.Functor.Alt.Alt (Control.Applicative.ListF.ListF f)
instance GHC.Base.Functor f => Data.Functor.Plus.Plus (Control.Applicative.ListF.ListF f)
instance GHC.Base.Applicative f => GHC.Base.Alternative (Control.Applicative.ListF.ListF f)
instance GHC.Base.Semigroup (Control.Applicative.ListF.ListF f a)
instance GHC.Base.Monoid (Control.Applicative.ListF.ListF f a)
instance Data.Functor.Classes.Eq1 f => Data.Functor.Classes.Eq1 (Control.Applicative.ListF.ListF f)
instance Data.Functor.Classes.Read1 f => Data.Functor.Classes.Read1 (Control.Applicative.ListF.ListF f)
instance Data.Functor.Classes.Show1 f => Data.Functor.Classes.Show1 (Control.Applicative.ListF.ListF f)
instance (Data.Typeable.Internal.Typeable f, Data.Typeable.Internal.Typeable a, Data.Data.Data (f a)) => Data.Data.Data (Control.Applicative.ListF.ListF f a)
instance GHC.Generics.Generic (Control.Applicative.ListF.ListF f a)
instance Data.Traversable.Traversable f => Data.Traversable.Traversable (Control.Applicative.ListF.ListF f)
instance Data.Foldable.Foldable f => Data.Foldable.Foldable (Control.Applicative.ListF.ListF f)
instance GHC.Base.Functor f => GHC.Base.Functor (Control.Applicative.ListF.ListF f)
instance GHC.Classes.Ord (f a) => GHC.Classes.Ord (Control.Applicative.ListF.ListF f a)
instance GHC.Classes.Eq (f a) => GHC.Classes.Eq (Control.Applicative.ListF.ListF f a)
instance GHC.Read.Read (f a) => GHC.Read.Read (Control.Applicative.ListF.ListF f a)
instance GHC.Show.Show (f a) => GHC.Show.Show (Control.Applicative.ListF.ListF f a)


-- | The church-encoded <a>Freer</a> Monad. Basically provides the free
--   monad in a way that is compatible with <a>HFunctor</a> and
--   <a>Interpret</a>, and <a>:.:</a> or <a>Compose</a> in a way that is
--   compatible with <a>HBifunctor</a> and <a>Tensor</a> and
--   <a>Monoidal</a>.
module Control.Monad.Freer.Church

-- | A <tt><a>Free</a> f</tt> is <tt>f</tt> enhanced with "sequential
--   binding" capabilities. It allows you to sequence multiple <tt>f</tt>s
--   one after the other, and also to determine "what <tt>f</tt> to
--   sequence" based on the result of the computation so far.
--   
--   Essentially, you can think of this as "giving <tt>f</tt> a
--   <a>Monad</a> instance", with all that that entails (<a>return</a>,
--   <a>&gt;&gt;=</a>, etc.).
--   
--   Lift <tt>f</tt> into it with <tt><a>inject</a> :: f a -&gt; Free f
--   a</tt>. When you finally want to "use" it, you can interpret it into
--   any monadic context:
--   
--   <pre>
--   <a>interpret</a>
--       :: <a>Monad</a> g
--       =&gt; (forall x. f x -&gt; g x)
--       -&gt; <a>Free</a> f a
--       -&gt; g a
--   </pre>
--   
--   Under the hood, this is the Church-encoded Freer monad. It's
--   <a>Free</a>, or <a>F</a>, but in a way that is compatible with
--   <a>HFunctor</a> and <a>Interpret</a>.
newtype Free f a
Free :: (forall r. (a -> r) -> (forall s. f s -> (s -> r) -> r) -> r) -> Free f a
[runFree] :: Free f a -> forall r. (a -> r) -> (forall s. f s -> (s -> r) -> r) -> r

-- | Convert a <tt><a>Free</a> f</tt> into any instance of
--   <tt><a>MonadFree</a> f</tt>.
reFree :: (MonadFree f m, Functor f) => Free f a -> m a
liftFree :: f ~> Free f
interpretFree :: Monad g => (f ~> g) -> Free f ~> g
retractFree :: Monad f => Free f ~> f
hoistFree :: (f ~> g) -> Free f ~> Free g
newtype Free1 f a
Free1 :: (forall r. (forall s. f s -> (s -> a) -> r) -> (forall s. f s -> (s -> r) -> r) -> r) -> Free1 f a
[runFree1] :: Free1 f a -> forall r. (forall s. f s -> (s -> a) -> r) -> (forall s. f s -> (s -> r) -> r) -> r
toFree :: Free1 f ~> Free f
liftFree1 :: f ~> Free1 f
free1Comp :: Free1 f ~> Comp f (Free f)
matchFree1 :: Functor f => Free1 f ~> (f :+: Comp f (Free1 f))
interpretFree1 :: Bind g => (f ~> g) -> Free1 f ~> g
retractFree1 :: Bind f => Free1 f ~> f
hoistFree1 :: (f ~> g) -> Free1 f ~> Free1 g

-- | Functor composition. <tt><a>Comp</a> f g a</tt> is equivalent to <tt>f
--   (g a)</tt>, and the <a>Comp</a> pattern synonym is a way of getting
--   the <tt>f (g a)</tt> in a <tt><a>Comp</a> f g a</tt>.
--   
--   For example, <tt><a>Maybe</a> (<a>IO</a> <a>Bool</a>)</tt> is
--   <tt><a>Comp</a> <a>Maybe</a> <a>IO</a> <a>Bool</a></tt>.
--   
--   This is mostly useful for its typeclass instances: in particular,
--   <a>Functor</a>, <a>Applicative</a>, <a>HBifunctor</a>, and
--   <a>Monoidal</a>.
--   
--   This is essentially a version of <a>:.:</a> and <a>Compose</a> that
--   allows for an <a>HBifunctor</a> instance.
--   
--   It is slightly less performant. Using <tt><a>comp</a> .
--   <a>unComp</a></tt> every once in a while will concretize a <a>Comp</a>
--   value (if you have <tt><a>Functor</a> f</tt>) and remove some
--   indirection if you have a lot of chained operations.
--   
--   The "free monoid" over <a>Comp</a> is <a>Free</a>, and the "free
--   semigroup" over <a>Comp</a> is <a>Free1</a>.
data Comp f g a
(:>>=) :: f x -> (x -> g a) -> Comp f g a

-- | Pattern match on and construct a <tt><a>Comp</a> f g a</tt> as if it
--   were <tt>f (g a)</tt>.
pattern Comp :: Functor f => f (g a) -> Comp f g a

-- | "Smart constructor" for <a>Comp</a> that doesn't require
--   <tt><a>Functor</a> f</tt>.
comp :: f (g a) -> Comp f g a
instance GHC.Base.Functor g => GHC.Base.Functor (Control.Monad.Freer.Church.Comp f g)
instance (GHC.Base.Applicative f, GHC.Base.Applicative g) => GHC.Base.Applicative (Control.Monad.Freer.Church.Comp f g)
instance (Data.Foldable.Foldable f, Data.Foldable.Foldable g) => Data.Foldable.Foldable (Control.Monad.Freer.Church.Comp f g)
instance (Data.Traversable.Traversable f, Data.Traversable.Traversable g) => Data.Traversable.Traversable (Control.Monad.Freer.Church.Comp f g)
instance (GHC.Base.Alternative f, GHC.Base.Alternative g) => GHC.Base.Alternative (Control.Monad.Freer.Church.Comp f g)
instance (GHC.Base.Functor f, Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g) => Data.Functor.Classes.Show1 (Control.Monad.Freer.Church.Comp f g)
instance (GHC.Base.Functor f, Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g, GHC.Show.Show a) => GHC.Show.Show (Control.Monad.Freer.Church.Comp f g a)
instance (GHC.Base.Functor f, Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) => Data.Functor.Classes.Read1 (Control.Monad.Freer.Church.Comp f g)
instance (GHC.Base.Functor f, Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g, GHC.Read.Read a) => GHC.Read.Read (Control.Monad.Freer.Church.Comp f g a)
instance (GHC.Base.Functor f, Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g) => Data.Functor.Classes.Eq1 (Control.Monad.Freer.Church.Comp f g)
instance (GHC.Base.Functor f, Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g) => Data.Functor.Classes.Ord1 (Control.Monad.Freer.Church.Comp f g)
instance (GHC.Base.Functor f, Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g, GHC.Classes.Eq a) => GHC.Classes.Eq (Control.Monad.Freer.Church.Comp f g a)
instance (GHC.Base.Functor f, Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g, GHC.Classes.Ord a) => GHC.Classes.Ord (Control.Monad.Freer.Church.Comp f g a)
instance GHC.Base.Functor (Control.Monad.Freer.Church.Free1 f)
instance Data.Functor.Bind.Class.Apply (Control.Monad.Freer.Church.Free1 f)
instance Data.Functor.Bind.Class.Bind (Control.Monad.Freer.Church.Free1 f)
instance (GHC.Base.Functor f, Data.Functor.Classes.Eq1 f) => Data.Functor.Classes.Eq1 (Control.Monad.Freer.Church.Free1 f)
instance (GHC.Base.Functor f, Data.Functor.Classes.Ord1 f) => Data.Functor.Classes.Ord1 (Control.Monad.Freer.Church.Free1 f)
instance (GHC.Base.Functor f, Data.Functor.Classes.Eq1 f, GHC.Classes.Eq a) => GHC.Classes.Eq (Control.Monad.Freer.Church.Free1 f a)
instance (GHC.Base.Functor f, Data.Functor.Classes.Ord1 f, GHC.Classes.Ord a) => GHC.Classes.Ord (Control.Monad.Freer.Church.Free1 f a)
instance GHC.Base.Functor (Control.Monad.Freer.Church.Free f)
instance Data.Functor.Bind.Class.Apply (Control.Monad.Freer.Church.Free f)
instance GHC.Base.Applicative (Control.Monad.Freer.Church.Free f)
instance Data.Functor.Bind.Class.Bind (Control.Monad.Freer.Church.Free f)
instance GHC.Base.Monad (Control.Monad.Freer.Church.Free f)
instance Control.Monad.Free.Class.MonadFree f (Control.Monad.Freer.Church.Free f)
instance Data.Foldable.Foldable f => Data.Foldable.Foldable (Control.Monad.Freer.Church.Free f)
instance Data.Traversable.Traversable f => Data.Traversable.Traversable (Control.Monad.Freer.Church.Free f)
instance (GHC.Base.Functor f, Data.Functor.Classes.Eq1 f) => Data.Functor.Classes.Eq1 (Control.Monad.Freer.Church.Free f)
instance (GHC.Base.Functor f, Data.Functor.Classes.Ord1 f) => Data.Functor.Classes.Ord1 (Control.Monad.Freer.Church.Free f)
instance (GHC.Base.Functor f, Data.Functor.Classes.Eq1 f, GHC.Classes.Eq a) => GHC.Classes.Eq (Control.Monad.Freer.Church.Free f a)
instance (GHC.Base.Functor f, Data.Functor.Classes.Ord1 f, GHC.Classes.Ord a) => GHC.Classes.Ord (Control.Monad.Freer.Church.Free f a)
instance (GHC.Base.Functor f, Data.Functor.Classes.Show1 f) => Data.Functor.Classes.Show1 (Control.Monad.Freer.Church.Free f)
instance (GHC.Base.Functor f, Data.Functor.Classes.Show1 f, GHC.Show.Show a) => GHC.Show.Show (Control.Monad.Freer.Church.Free f a)

module Data.Functor.HFunctor.IsoF
type f <~> g = forall p a. Profunctor p => p (g a) (g a) -> p (f a) (f a)
infixr 0 <~>
isoF :: (f ~> g) -> (g ~> f) -> f <~> g
viewF :: (f <~> g) -> f ~> g
reviewF :: (f <~> g) -> g ~> f
overF :: (f <~> g) -> (g ~> g) -> f ~> f
fromF :: AnIsoF' f g -> g <~> f
type AnIsoF' f g = forall a. Exchange (g a) (g a) (g a) (g a) -> Exchange (g a) (g a) (f a) (f a)
cloneIsoF' :: AnIsoF' f g -> f <~> g
data Exchange a b s t
Exchange :: (s -> a) -> (b -> t) -> Exchange a b s t
instance Data.Profunctor.Unsafe.Profunctor (Data.Functor.HFunctor.IsoF.Exchange a b)


-- | This module provides functor combinators that are the fixed points of
--   applications of <a>:+:</a> and <a>TheseT</a>. They are useful for
--   their <a>Interpret</a> instances, along with their relationship to the
--   <a>Monoidal</a> insatnces of <a>:+:</a> and <a>TheseT</a>.
module Control.Applicative.Step

-- | An <tt>f a</tt>, along with a <a>Natural</a> index.
--   
--   <pre>
--   Step f a ~ (<a>Natural</a>, f a)
--   Step f   ~ ((,) <a>Natural</a>) <a>:.:</a> f       -- functor composition
--   </pre>
--   
--   It is the fixed point of applications of <a>:+:</a> (functor sums).
--   
--   Intuitively, in an infinite <tt>f :+: f :+: f :+: f ...</tt>, you have
--   exactly one <tt>f</tt> <i>somewhere</i>. A <tt><a>Step</a> f a</tt>
--   has that <tt>f</tt>, with a <a>Natural</a> giving you "where" the
--   <tt>f</tt> is in the long chain.
--   
--   Can be useful for using with the <a>Monoidal</a> instance of
--   <a>:+:</a>.
--   
--   <a>interpret</a>ing it requires no constraint on the target context.
data Step f a
Step :: Natural -> f a -> Step f a
[stepPos] :: Step f a -> Natural
[stepVal] :: Step f a -> f a

-- | A non-empty map of <a>Natural</a> to <tt>f a</tt>. Basically, contains
--   multiple <tt>f a</tt>s, each at a given <a>Natural</a> index.
--   
--   <pre>
--   Steps f a ~ <a>Map</a> <a>Natural</a> (f a)
--   Steps f   ~ <a>Map</a> <a>Natural</a> <a>:.:</a> f       -- functor composition
--   </pre>
--   
--   It is the fixed point of applications of <a>TheseT</a>.
--   
--   Intuitively, in an infinite <tt>f `TheseT` f `TheseT` f `TheseT` f
--   ...</tt>, each of those infinite positions may have an <tt>f</tt> in
--   them. However, because of the at-least-one nature of <a>TheseT</a>, we
--   know we have at least one f at one position <i>somewhere</i>.
--   
--   A <tt><a>Steps</a> f a</tt> has potentially many <tt>f</tt>s, each
--   stored at a different <a>Natural</a> position, with the guaruntee that
--   at least one <tt>f</tt> exists.
--   
--   Can be useful for using with the <a>Monoidal</a> instance of
--   <a>TheseT</a>.
--   
--   <a>interpret</a>ing it requires at least an <a>Alt</a> instance in the
--   target context, since we have to handle potentially more than one
--   <tt>f</tt>.
newtype Steps f a
Steps :: NEMap Natural (f a) -> Steps f a
[getSteps] :: Steps f a -> NEMap Natural (f a)
stepUp :: (f :+: Step f) ~> Step f
stepDown :: Step f ~> (f :+: Step f)
stepping :: Step f <~> (f :+: Step f)

-- | <a>Void1</a> is a functor that is uninhabited for all inputs. That is,
--   <tt><a>Void1</a> a</tt> is uninhabited for all <tt>a</tt>.
--   
--   The identity functor of <a>:+:</a> (and also <a>TheseT</a>)
data Void1 a

-- | We have a natural transformation between <a>Void1</a> and any other
--   functor <tt>f</tt> with no constraints.
absurd1 :: Void1 a -> f a

-- | <tt><a>Void2</a> a b</tt> is uninhabited for all <tt>a</tt> and
--   <tt>b</tt>.
data Void2 a b

-- | If you treat a <tt><a>Void2</a> f a</tt> as a functor combinator, then
--   <a>absurd2</a> lets you convert from a <tt><a>Void2</a> f a</tt> into
--   a <tt>t f a</tt> for any functor combinator <tt>t</tt>.
absurd2 :: Void2 f a -> t f a
instance forall k (a :: k). Data.Functor.Classes.Ord1 (Control.Applicative.Step.Void2 a)
instance forall k (a :: k). Data.Functor.Classes.Eq1 (Control.Applicative.Step.Void2 a)
instance forall k (a :: k). Data.Functor.Classes.Read1 (Control.Applicative.Step.Void2 a)
instance forall k (a :: k). Data.Functor.Classes.Show1 (Control.Applicative.Step.Void2 a)
instance forall k1 (a :: k1) k2 (b :: k2). (Data.Typeable.Internal.Typeable a, Data.Typeable.Internal.Typeable b, Data.Typeable.Internal.Typeable k1, Data.Typeable.Internal.Typeable k2) => Data.Data.Data (Control.Applicative.Step.Void2 a b)
instance forall k1 (a :: k1) k2 (b :: k2). GHC.Generics.Generic (Control.Applicative.Step.Void2 a b)
instance forall k (a :: k). Data.Traversable.Traversable (Control.Applicative.Step.Void2 a)
instance forall k (a :: k). Data.Foldable.Foldable (Control.Applicative.Step.Void2 a)
instance forall k (a :: k). GHC.Base.Functor (Control.Applicative.Step.Void2 a)
instance forall k1 (a :: k1) k2 (b :: k2). GHC.Classes.Ord (Control.Applicative.Step.Void2 a b)
instance forall k1 (a :: k1) k2 (b :: k2). GHC.Classes.Eq (Control.Applicative.Step.Void2 a b)
instance forall k1 (a :: k1) k2 (b :: k2). GHC.Read.Read (Control.Applicative.Step.Void2 a b)
instance forall k1 (a :: k1) k2 (b :: k2). GHC.Show.Show (Control.Applicative.Step.Void2 a b)
instance Data.Functor.Classes.Ord1 f => Data.Functor.Classes.Ord1 (Control.Applicative.Step.Steps f)
instance Data.Semigroup.Foldable.Class.Foldable1 f => Data.Semigroup.Foldable.Class.Foldable1 (Control.Applicative.Step.Steps f)
instance Data.Semigroup.Traversable.Class.Traversable1 f => Data.Semigroup.Traversable.Class.Traversable1 (Control.Applicative.Step.Steps f)
instance forall k (f :: k -> *) (a :: k). GHC.Base.Semigroup (Control.Applicative.Step.Steps f a)
instance GHC.Base.Functor f => Data.Functor.Alt.Alt (Control.Applicative.Step.Steps f)
instance Data.Functor.Classes.Eq1 f => Data.Functor.Classes.Eq1 (Control.Applicative.Step.Steps f)
instance Data.Functor.Classes.Read1 f => Data.Functor.Classes.Read1 (Control.Applicative.Step.Steps f)
instance Data.Functor.Classes.Show1 f => Data.Functor.Classes.Show1 (Control.Applicative.Step.Steps f)
instance forall k (f :: k -> *) (a :: k). (Data.Typeable.Internal.Typeable a, Data.Typeable.Internal.Typeable f, Data.Typeable.Internal.Typeable k, Data.Data.Data (f a)) => Data.Data.Data (Control.Applicative.Step.Steps f a)
instance forall k (f :: k -> *) (a :: k). GHC.Generics.Generic (Control.Applicative.Step.Steps f a)
instance Data.Traversable.Traversable f => Data.Traversable.Traversable (Control.Applicative.Step.Steps f)
instance Data.Foldable.Foldable f => Data.Foldable.Foldable (Control.Applicative.Step.Steps f)
instance GHC.Base.Functor f => GHC.Base.Functor (Control.Applicative.Step.Steps f)
instance forall k (f :: k -> *) (a :: k). GHC.Classes.Ord (f a) => GHC.Classes.Ord (Control.Applicative.Step.Steps f a)
instance forall k (f :: k -> *) (a :: k). GHC.Classes.Eq (f a) => GHC.Classes.Eq (Control.Applicative.Step.Steps f a)
instance forall k (f :: k -> *) (a :: k). GHC.Read.Read (f a) => GHC.Read.Read (Control.Applicative.Step.Steps f a)
instance forall k (f :: k -> *) (a :: k). GHC.Show.Show (f a) => GHC.Show.Show (Control.Applicative.Step.Steps f a)
instance Data.Functor.Classes.Ord1 Control.Applicative.Step.Void1
instance Data.Functor.Classes.Eq1 Control.Applicative.Step.Void1
instance Data.Functor.Classes.Read1 Control.Applicative.Step.Void1
instance Data.Functor.Classes.Show1 Control.Applicative.Step.Void1
instance forall k (a :: k). (Data.Typeable.Internal.Typeable a, Data.Typeable.Internal.Typeable k) => Data.Data.Data (Control.Applicative.Step.Void1 a)
instance forall k (a :: k). GHC.Generics.Generic (Control.Applicative.Step.Void1 a)
instance Data.Traversable.Traversable Control.Applicative.Step.Void1
instance Data.Foldable.Foldable Control.Applicative.Step.Void1
instance GHC.Base.Functor Control.Applicative.Step.Void1
instance forall k (a :: k). GHC.Classes.Ord (Control.Applicative.Step.Void1 a)
instance forall k (a :: k). GHC.Classes.Eq (Control.Applicative.Step.Void1 a)
instance forall k (a :: k). GHC.Read.Read (Control.Applicative.Step.Void1 a)
instance forall k (a :: k). GHC.Show.Show (Control.Applicative.Step.Void1 a)
instance Data.Functor.Classes.Ord1 f => Data.Functor.Classes.Ord1 (Control.Applicative.Step.Step f)
instance GHC.Base.Applicative f => GHC.Base.Applicative (Control.Applicative.Step.Step f)
instance Data.Semigroup.Foldable.Class.Foldable1 f => Data.Semigroup.Foldable.Class.Foldable1 (Control.Applicative.Step.Step f)
instance Data.Semigroup.Traversable.Class.Traversable1 f => Data.Semigroup.Traversable.Class.Traversable1 (Control.Applicative.Step.Step f)
instance Data.Functor.Classes.Eq1 f => Data.Functor.Classes.Eq1 (Control.Applicative.Step.Step f)
instance Data.Functor.Classes.Read1 f => Data.Functor.Classes.Read1 (Control.Applicative.Step.Step f)
instance Data.Functor.Classes.Show1 f => Data.Functor.Classes.Show1 (Control.Applicative.Step.Step f)
instance forall k (f :: k -> *) (a :: k). (Data.Typeable.Internal.Typeable a, Data.Typeable.Internal.Typeable f, Data.Typeable.Internal.Typeable k, Data.Data.Data (f a)) => Data.Data.Data (Control.Applicative.Step.Step f a)
instance forall k (f :: k -> *) (a :: k). GHC.Generics.Generic (Control.Applicative.Step.Step f a)
instance Data.Traversable.Traversable f => Data.Traversable.Traversable (Control.Applicative.Step.Step f)
instance Data.Foldable.Foldable f => Data.Foldable.Foldable (Control.Applicative.Step.Step f)
instance GHC.Base.Functor f => GHC.Base.Functor (Control.Applicative.Step.Step f)
instance forall k (f :: k -> *) (a :: k). GHC.Classes.Ord (f a) => GHC.Classes.Ord (Control.Applicative.Step.Step f a)
instance forall k (f :: k -> *) (a :: k). GHC.Classes.Eq (f a) => GHC.Classes.Eq (Control.Applicative.Step.Step f a)
instance forall k (f :: k -> *) (a :: k). GHC.Read.Read (f a) => GHC.Read.Read (Control.Applicative.Step.Step f a)
instance forall k (f :: k -> *) (a :: k). GHC.Show.Show (f a) => GHC.Show.Show (Control.Applicative.Step.Step f a)

module Data.Functor.HBifunctor

-- | A <a>HBifunctor</a> is like an <a>HFunctor</a>, but it enhances
--   <i>two</i> different functors instead of just one.
--   
--   Usually, it enhaces them "together" in some sort of combining way.
--   
--   This typeclass provides a uniform instance for "swapping out" or
--   "hoisting" the enhanced functors. We can hoist the first one with
--   <a>hleft</a>, the second one with <a>hright</a>, or both at the same
--   time with <a>hbimap</a>.
--   
--   For example, the <tt>f :*: g</tt> type gives us "both <tt>f</tt> and
--   <tt>g</tt>":
--   
--   <pre>
--   data (f <a>:*:</a> g) a = f a :*: g a
--   </pre>
--   
--   It combines both <tt>f</tt> and <tt>g</tt> into a unified structure
--   --- here, it does it by providing both <tt>f</tt> and <tt>g</tt>.
--   
--   The single law is:
--   
--   <pre>
--   <a>hbimap</a> <a>id</a> id == id
--   </pre>
--   
--   This ensures that <a>hleft</a>, <a>hright</a>, and <a>hbimap</a> do
--   not affect the structure that <tt>t</tt> adds on top of the underlying
--   functors.
class HBifunctor t

-- | Swap out the first transformed functor.
hleft :: HBifunctor t => (f ~> j) -> t f g ~> t j g

-- | Swap out the second transformed functor.
hright :: HBifunctor t => (g ~> k) -> t f g ~> t f k

-- | Swap out both transformed functors at the same time.
hbimap :: HBifunctor t => (f ~> j) -> (g ~> k) -> t f g ~> t j k

-- | Useful newtype to allow us to derive an <a>HFunctor</a> instance from
--   any instance of <a>HBifunctor</a>, using -XDerivingVia.
--   
--   For example, because we have <tt>instance <a>HBifunctor</a>
--   <a>Day</a></tt>, we can write:
--   
--   <pre>
--   deriving via (<a>WrappedHBifunctor</a> <a>Day</a> f) instance <a>HFunctor</a> (<a>Day</a> f)
--   </pre>
--   
--   to give us an automatic <a>HFunctor</a> instance and save us some
--   work.
newtype WrappedHBifunctor t (f :: Type -> Type) (g :: Type -> Type) a
WrapHBifunctor :: t f g a -> WrappedHBifunctor t a
[unwrapHBifunctor] :: WrappedHBifunctor t a -> t f g a
overHBifunctor :: HBifunctor t => AnIsoF' f f' -> AnIsoF' g g' -> t f g <~> t f' g'

-- | Form an <a>HFunctor</a> by applying the same input twice to an
--   <a>HBifunctor</a>.
newtype JoinT t f a
JoinT :: t f f a -> JoinT t f a
[runJoinT] :: JoinT t f a -> t f f a

-- | Form an <a>HBifunctor</a> by wrapping another <a>HBifunctor</a> in a
--   <a>HFunctor</a>.
newtype TannenT t p f g a
TannenT :: t (p f g) a -> TannenT t p f g a
[runTannenT] :: TannenT t p f g a -> t (p f g) a

-- | Form an <a>HBifunctor</a> over two <a>HFunctor</a>s.
newtype BiffT p s t f g a
BiffT :: p (s f) (t g) a -> BiffT p s t f g a
[runBiffT] :: BiffT p s t f g a -> p (s f) (t g) a

-- | Form an <a>HBifunctor</a> over a <a>HFunctor</a> by ignoring the
--   second argument.
newtype ClownT t f g a
ClownT :: t f a -> ClownT t f g a
[runClownT] :: ClownT t f g a -> t f a

-- | Form an <a>HBifunctor</a> over a <a>HFunctor</a> by ignoring the first
--   argument.
newtype JokerT t f g a
JokerT :: t g a -> JokerT t f g a
[runJokerT] :: JokerT t f g a -> t g a
instance forall k1 k2 (t :: k1 -> k2 -> *) k3 (f :: k3) (g :: k1) (a :: k2). GHC.Read.Read (t g a) => GHC.Read.Read (Data.Functor.HBifunctor.JokerT t f g a)
instance forall k1 k2 (t :: k1 -> k2 -> *) k3 (f :: k3) (g :: k1) (a :: k2). GHC.Show.Show (t g a) => GHC.Show.Show (Data.Functor.HBifunctor.JokerT t f g a)
instance forall k1 k2 (t :: k1 -> k2 -> *) k3 (f :: k3) (g :: k1) (a :: k2). GHC.Classes.Ord (t g a) => GHC.Classes.Ord (Data.Functor.HBifunctor.JokerT t f g a)
instance forall k1 k2 (t :: k1 -> k2 -> *) k3 (f :: k3) (g :: k1) (a :: k2). GHC.Classes.Eq (t g a) => GHC.Classes.Eq (Data.Functor.HBifunctor.JokerT t f g a)
instance forall k1 k2 (t :: k1 -> k2 -> *) (f :: k1) k3 (g :: k3) (a :: k2). GHC.Read.Read (t f a) => GHC.Read.Read (Data.Functor.HBifunctor.ClownT t f g a)
instance forall k1 k2 (t :: k1 -> k2 -> *) (f :: k1) k3 (g :: k3) (a :: k2). GHC.Show.Show (t f a) => GHC.Show.Show (Data.Functor.HBifunctor.ClownT t f g a)
instance forall k1 k2 (t :: k1 -> k2 -> *) (f :: k1) k3 (g :: k3) (a :: k2). GHC.Classes.Ord (t f a) => GHC.Classes.Ord (Data.Functor.HBifunctor.ClownT t f g a)
instance forall k1 k2 (t :: k1 -> k2 -> *) (f :: k1) k3 (g :: k3) (a :: k2). GHC.Classes.Eq (t f a) => GHC.Classes.Eq (Data.Functor.HBifunctor.ClownT t f g a)
instance forall k (t :: k -> k -> * -> *) (f :: k). GHC.Base.Functor (t f f) => GHC.Base.Functor (Data.Functor.HBifunctor.JoinT t f)
instance forall k1 k2 k3 (t :: k3 -> * -> *) (p :: k1 -> k2 -> k3) (f :: k1) (g :: k2). GHC.Base.Functor (t (p f g)) => GHC.Base.Functor (Data.Functor.HBifunctor.TannenT t p f g)
instance (Data.Functor.HFunctor.Internal.HFunctor t, Data.Functor.HFunctor.Internal.HBifunctor p) => Data.Functor.HFunctor.Internal.HFunctor (Data.Functor.HBifunctor.TannenT t p f)
instance forall k1 k2 k3 k4 (p :: k3 -> k4 -> * -> *) (s :: k2 -> k3) (f :: k2) (t :: k1 -> k4) (g :: k1). GHC.Base.Functor (p (s f) (t g)) => GHC.Base.Functor (Data.Functor.HBifunctor.BiffT p s t f g)
instance (Data.Functor.HFunctor.Internal.HBifunctor p, Data.Functor.HFunctor.Internal.HFunctor s, Data.Functor.HFunctor.Internal.HFunctor t) => Data.Functor.HFunctor.Internal.HFunctor (Data.Functor.HBifunctor.BiffT p s t f)
instance forall k1 k2 (t :: k2 -> * -> *) (f :: k2) (g :: k1). GHC.Base.Functor (t f) => GHC.Base.Functor (Data.Functor.HBifunctor.ClownT t f g)
instance Data.Functor.HFunctor.Internal.HFunctor t => Data.Functor.HFunctor.Internal.HFunctor (Data.Functor.HBifunctor.ClownT t f)
instance forall k1 k2 (t :: k2 -> * -> *) (g :: k2) (f :: k1). GHC.Base.Functor (t g) => GHC.Base.Functor (Data.Functor.HBifunctor.JokerT t f g)
instance Data.Functor.HFunctor.Internal.HFunctor t => Data.Functor.HFunctor.Internal.HFunctor (Data.Functor.HBifunctor.JokerT t f)
instance forall k1 k2 (t :: k2 -> * -> *) (g :: k2) (f :: k1). Data.Functor.Classes.Show1 (t g) => Data.Functor.Classes.Show1 (Data.Functor.HBifunctor.JokerT t f g)
instance Data.Functor.HFunctor.Internal.HFunctor t => Data.Functor.HFunctor.Internal.HBifunctor (Data.Functor.HBifunctor.JokerT t)
instance forall k1 k2 (t :: k2 -> * -> *) (f :: k2) (g :: k1). Data.Functor.Classes.Show1 (t f) => Data.Functor.Classes.Show1 (Data.Functor.HBifunctor.ClownT t f g)
instance Data.Functor.HFunctor.Internal.HFunctor t => Data.Functor.HFunctor.Internal.HBifunctor (Data.Functor.HBifunctor.ClownT t)
instance (Data.Functor.HFunctor.Internal.HBifunctor p, Data.Functor.HFunctor.Internal.HFunctor s, Data.Functor.HFunctor.Internal.HFunctor t) => Data.Functor.HFunctor.Internal.HBifunctor (Data.Functor.HBifunctor.BiffT p s t)
instance (Data.Functor.HFunctor.Internal.HFunctor t, Data.Functor.HFunctor.Internal.HBifunctor p) => Data.Functor.HFunctor.Internal.HBifunctor (Data.Functor.HBifunctor.TannenT t p)
instance Data.Functor.HFunctor.Internal.HBifunctor t => Data.Functor.HFunctor.Internal.HFunctor (Data.Functor.HBifunctor.JoinT t)


-- | This module provides tools for working with unary functor combinators.
--   
--   These are types <tt>f</tt> that take a functor <tt>f</tt> and return a
--   new functor <tt>t f</tt>, enhancing <tt>f</tt> with new structure and
--   abilities.
--   
--   The main operations these combinators support are:
--   
--   <pre>
--   <a>hmap</a> :: (forall x. f x -&gt; g x) -&gt; t f a -&gt; t g a
--   </pre>
--   
--   which lets you "swap out" the functor being transformed,
--   
--   <pre>
--   <a>inject</a> :: f a -&gt; t f a
--   </pre>
--   
--   which lets you "lift" an <tt>f a</tt> into its transformed version,
--   and also:
--   
--   <pre>
--   <tt>interpret</tt>
--       :: C t g
--       =&gt; (forall x. f a -&gt; g a)
--       -&gt; t f a
--       -&gt; g a
--   </pre>
--   
--   that lets you "interpret" a <tt>t f a</tt> into a context <tt>g
--   a</tt>, essentially "running" the computaiton that it encodes. The
--   context is required to have a typeclass constraints that reflects what
--   is "required" to be able to run a functor combinator.
--   
--   Every single instance provides different tools. Check out the instance
--   list for a nice list of useful combinators, or also the README for a
--   high-level rundown.
--   
--   See <a>Data.Functor.Tensor</a> for binary functor combinators that mix
--   together two or more different functors.
module Data.Functor.HFunctor

-- | An <a>HFunctor</a> can be thought of a unary "functor transformer" ---
--   a basic functor combinator. It takes a functor as input and returns a
--   functor as output.
--   
--   It "enhances" a functor with extra structure (sort of like how a monad
--   transformer enhances a <a>Monad</a> with extra structure).
--   
--   As a uniform inteface, we can "swap the underlying functor" (also
--   sometimes called "hoisting"). This is what <a>hmap</a> does: it lets
--   us swap out the <tt>f</tt> in a <tt>t f</tt> for a <tt>t g</tt>.
--   
--   For example, the free monad <a>Free</a> takes a <a>Functor</a> and
--   returns a new <a>Functor</a>. In the process, it provides a monadic
--   structure over <tt>f</tt>. <a>hmap</a> lets us turn a <tt><a>Free</a>
--   f</tt> into a <tt><a>Free</a> g</tt>: a monad built over <tt>f</tt>
--   can be turned into a monad built over <tt>g</tt>.
--   
--   For the ability to move in and out of the enhanced functor, see
--   <a>Interpret</a>.
class HFunctor t

-- | If we can turn an <tt>f</tt> into a <tt>g</tt>, then we can turn a
--   <tt>t f</tt> into a <tt>t g</tt>.
--   
--   It must be the case that
--   
--   <pre>
--   <a>hmap</a> <a>id</a> == id
--   </pre>
--   
--   Essentially, <tt>t f</tt> adds some "extra structure" to <tt>f</tt>.
--   <a>hmap</a> must swap out the functor, <i>without affecting the added
--   structure</i>.
--   
--   For example, <tt><a>ListF</a> f a</tt> is essentially a list of <tt>f
--   a</tt>s. If we <a>hmap</a> to swap out the <tt>f a</tt>s for <tt>g
--   a</tt>s, then we must ensure that the "added structure" (here, the
--   number of items in the list) remains the same. So, <a>hmap</a> must
--   preserve the number of items in the list.
--   
--   The law <tt><a>hmap</a> <a>id</a> == id</tt> is a way of formalizing
--   this informal property.
hmap :: HFunctor t => (f ~> g) -> t f ~> t g
overHFunctor :: HFunctor t => AnIsoF' f g -> t f <~> t g
class HFunctor t => Inject t

-- | Lift an <tt>f</tt> into the enhanced <tt>t f</tt> structure. Analogous
--   to <a>lift</a> from <a>MonadTrans</a>.
inject :: Inject t => f ~> t f
class HFunctor t => HBind t
hbind :: HBind t => (f ~> t g) -> t f ~> t g
data HLift t f a
HPure :: f a -> HLift t f a
HOther :: t f a -> HLift t f a
data HFree t f a
HReturn :: f a -> HFree t f a
HJoin :: t (HFree t f) a -> HFree t f a
instance (GHC.Base.Functor f, GHC.Base.Functor (t f)) => GHC.Base.Functor (Data.Functor.HFunctor.HLift t f)
instance (GHC.Base.Functor f, GHC.Base.Functor (t (Data.Functor.HFunctor.HFree t f))) => GHC.Base.Functor (Data.Functor.HFunctor.HFree t f)
instance Data.Functor.HFunctor.HBind Data.Functor.Coyoneda.Coyoneda
instance Data.Functor.HFunctor.HBind Control.Applicative.Free.Ap
instance Data.Functor.HFunctor.HBind Control.Applicative.ListF.ListF
instance Data.Functor.HFunctor.HBind Control.Applicative.ListF.NonEmptyF
instance Data.Functor.HFunctor.HBind Control.Applicative.ListF.MaybeF
instance Data.Functor.HFunctor.HBind Control.Applicative.Step.Step
instance Data.Functor.HFunctor.HBind Control.Applicative.Step.Steps
instance Data.Functor.HFunctor.HBind Control.Alternative.Free.Alt
instance Data.Functor.HFunctor.HBind Control.Monad.Freer.Church.Free
instance Data.Functor.HFunctor.HBind Control.Monad.Freer.Church.Free1
instance Data.Functor.HFunctor.HBind Control.Applicative.Free.Final.Ap
instance Data.Functor.HFunctor.HBind Control.Applicative.Free.Fast.Ap
instance Data.Functor.HFunctor.HBind Control.Monad.Trans.Identity.IdentityT
instance Data.Functor.HFunctor.HBind Control.Applicative.Lift.Lift
instance Data.Functor.HFunctor.HBind Data.Functor.Bind.Class.MaybeApply
instance Data.Functor.HFunctor.HBind Control.Applicative.Backwards.Backwards
instance Data.Functor.HFunctor.HBind Data.Functor.Bind.Class.WrappedApplicative
instance Data.Functor.HFunctor.HBind Data.Functor.Reverse.Reverse
instance Data.Functor.HFunctor.HBind Control.Applicative.Step.Void2
instance (Data.Functor.HFunctor.HBind t, Data.Functor.HFunctor.Inject t) => Data.Functor.HFunctor.HBind (Data.Functor.HFunctor.HLift t)
instance Data.Functor.HFunctor.Inject Data.Functor.Coyoneda.Coyoneda
instance Data.Functor.HFunctor.Inject Control.Applicative.Free.Ap
instance Data.Functor.HFunctor.Inject Control.Applicative.ListF.ListF
instance Data.Functor.HFunctor.Inject Control.Applicative.ListF.NonEmptyF
instance Data.Functor.HFunctor.Inject Control.Applicative.ListF.MaybeF
instance Data.Functor.HFunctor.Inject Control.Applicative.Step.Step
instance Data.Functor.HFunctor.Inject Control.Applicative.Step.Steps
instance Data.Functor.HFunctor.Inject Control.Alternative.Free.Alt
instance Data.Functor.HFunctor.Inject Control.Monad.Freer.Church.Free
instance Data.Functor.HFunctor.Inject Control.Monad.Freer.Church.Free1
instance Data.Functor.HFunctor.Inject Control.Applicative.Free.Final.Ap
instance Data.Functor.HFunctor.Inject Control.Applicative.Free.Fast.Ap
instance Data.Functor.HFunctor.Inject Control.Monad.Trans.Identity.IdentityT
instance Data.Functor.HFunctor.Inject Control.Applicative.Lift.Lift
instance Data.Functor.HFunctor.Inject Data.Functor.Bind.Class.MaybeApply
instance Data.Functor.HFunctor.Inject Control.Applicative.Backwards.Backwards
instance Data.Functor.HFunctor.Inject Data.Functor.Bind.Class.WrappedApplicative
instance Data.Functor.HFunctor.Inject (Control.Monad.Trans.Reader.ReaderT r)
instance Data.Functor.HFunctor.Inject Data.Functor.Reverse.Reverse
instance (Data.Functor.HFunctor.Inject s, Data.Functor.HFunctor.Inject t) => Data.Functor.HFunctor.Inject (Control.Monad.Trans.Compose.ComposeT s t)
instance Data.Functor.HFunctor.Internal.HFunctor t => Data.Functor.HFunctor.Inject (Data.Functor.HFunctor.HLift t)
instance Data.Functor.HFunctor.Internal.HFunctor t => Data.Functor.HFunctor.Inject (Data.Functor.HFunctor.HFree t)
instance (Data.Functor.Classes.Show1 (t (Data.Functor.HFunctor.HFree t f)), Data.Functor.Classes.Show1 f) => Data.Functor.Classes.Show1 (Data.Functor.HFunctor.HFree t f)
instance (Data.Functor.Classes.Show1 (t (Data.Functor.HFunctor.HFree t f)), Data.Functor.Classes.Show1 f, GHC.Show.Show a) => GHC.Show.Show (Data.Functor.HFunctor.HFree t f a)
instance Data.Functor.HFunctor.Internal.HFunctor t => Data.Functor.HFunctor.Internal.HFunctor (Data.Functor.HFunctor.HFree t)
instance (Data.Functor.Classes.Show1 (t f), Data.Functor.Classes.Show1 f) => Data.Functor.Classes.Show1 (Data.Functor.HFunctor.HLift t f)
instance (Data.Functor.Classes.Show1 (t f), Data.Functor.Classes.Show1 f, GHC.Show.Show a) => GHC.Show.Show (Data.Functor.HFunctor.HLift t f a)
instance Data.Functor.HFunctor.Internal.HFunctor t => Data.Functor.HFunctor.Internal.HFunctor (Data.Functor.HFunctor.HLift t)


-- | This module provides tools for working with unary functor combinators.
--   
--   These are types <tt>f</tt> that take a functor <tt>f</tt> and return a
--   new functor <tt>t f</tt>, enhancing <tt>f</tt> with new structure and
--   abilities.
--   
--   The main operations these combinators support are:
--   
--   <pre>
--   <a>hmap</a> :: (forall x. f x -&gt; g x) -&gt; t f a -&gt; t g a
--   </pre>
--   
--   which lets you "swap out" the functor being transformed,
--   
--   <pre>
--   <a>inject</a> :: f a -&gt; t f a
--   </pre>
--   
--   which lets you "lift" an <tt>f a</tt> into its transformed version,
--   and also:
--   
--   <pre>
--   <a>interpret</a>
--       :: C t g
--       =&gt; (forall x. f a -&gt; g a)
--       -&gt; t f a
--       -&gt; g a
--   </pre>
--   
--   that lets you "interpret" a <tt>t f a</tt> into a context <tt>g
--   a</tt>, essentially "running" the computaiton that it encodes. The
--   context is required to have a typeclass constraints that reflects what
--   is "required" to be able to run a functor combinator.
--   
--   Every single instance provides different tools. Check out the instance
--   list for a nice list of useful combinators, or also the README for a
--   high-level rundown.
--   
--   See <a>Data.Functor.Tensor</a> for binary functor combinators that mix
--   together two or more different functors.
module Data.Functor.Interpret

-- | An <a>HFunctor</a> can be thought of a unary "functor transformer" ---
--   a basic functor combinator. It takes a functor as input and returns a
--   functor as output.
--   
--   It "enhances" a functor with extra structure (sort of like how a monad
--   transformer enhances a <a>Monad</a> with extra structure).
--   
--   As a uniform inteface, we can "swap the underlying functor" (also
--   sometimes called "hoisting"). This is what <a>hmap</a> does: it lets
--   us swap out the <tt>f</tt> in a <tt>t f</tt> for a <tt>t g</tt>.
--   
--   For example, the free monad <a>Free</a> takes a <a>Functor</a> and
--   returns a new <a>Functor</a>. In the process, it provides a monadic
--   structure over <tt>f</tt>. <a>hmap</a> lets us turn a <tt><a>Free</a>
--   f</tt> into a <tt><a>Free</a> g</tt>: a monad built over <tt>f</tt>
--   can be turned into a monad built over <tt>g</tt>.
--   
--   For the ability to move in and out of the enhanced functor, see
--   <a>Interpret</a>.
class HFunctor t

-- | If we can turn an <tt>f</tt> into a <tt>g</tt>, then we can turn a
--   <tt>t f</tt> into a <tt>t g</tt>.
--   
--   It must be the case that
--   
--   <pre>
--   <a>hmap</a> <a>id</a> == id
--   </pre>
--   
--   Essentially, <tt>t f</tt> adds some "extra structure" to <tt>f</tt>.
--   <a>hmap</a> must swap out the functor, <i>without affecting the added
--   structure</i>.
--   
--   For example, <tt><a>ListF</a> f a</tt> is essentially a list of <tt>f
--   a</tt>s. If we <a>hmap</a> to swap out the <tt>f a</tt>s for <tt>g
--   a</tt>s, then we must ensure that the "added structure" (here, the
--   number of items in the list) remains the same. So, <a>hmap</a> must
--   preserve the number of items in the list.
--   
--   The law <tt><a>hmap</a> <a>id</a> == id</tt> is a way of formalizing
--   this informal property.
hmap :: HFunctor t => (f ~> g) -> t f ~> t g

-- | An <a>Interpret</a> lets us move in and out of the "enhanced"
--   <a>Functor</a>.
--   
--   For example, <tt><a>Free</a> f</tt> is <tt>f</tt> enhanced with
--   monadic structure. We get:
--   
--   <pre>
--   <a>inject</a>    :: f a -&gt; <a>Free</a> f a
--   <a>interpret</a> :: <a>Monad</a> m =&gt; (forall x. f x -&gt; m x) -&gt; <a>Free</a> f a -&gt; m a
--   </pre>
--   
--   <a>inject</a> will let us use our <tt>f</tt> inside the enhanced
--   <tt><a>Free</a> f</tt>. <a>interpret</a> will let us "extract" the
--   <tt>f</tt> from a <tt><a>Free</a> f</tt> if we can give an
--   <i>interpreting function</i> that interprets <tt>f</tt> into some
--   target <a>Monad</a>.
--   
--   The type family <a>C</a> tells us the typeclass constraint of the
--   "target" functor. For <a>Free</a>, it is <a>Monad</a>, but for other
--   <a>Interpret</a> instances, we might have other constraints.
--   
--   We enforce that:
--   
--   <pre>
--   <a>interpret</a> id . <a>inject</a> == id
--   </pre>
--   
--   That is, if we lift a value into our structure, then immediately
--   interpret it out as itself, it should lave the value unchanged.
class Inject t => Interpret t where {
    
    -- | The constraint on the target context of <a>interpret</a>.
    type family C t :: (Type -> Type) -> Constraint;
}

-- | Remove the <tt>f</tt> out of the enhanced <tt>t f</tt> structure,
--   provided that <tt>f</tt> satisfies the necessary constraints. If it
--   doesn't, it needs to be properly <a>interpret</a>ed out.
retract :: (Interpret t, C t f) => t f ~> f

-- | Given an "interpeting function" from <tt>f</tt> to <tt>g</tt>,
--   interpret the <tt>f</tt> out of the <tt>t f</tt> into a final context
--   <tt>g</tt>.
interpret :: (Interpret t, C t g) => (f ~> g) -> t f ~> g

-- | A convenient flipped version of <a>interpret</a>.
interpretFor :: (Interpret t, C t g) => t f a -> (f ~> g) -> g a

-- | Useful wrapper over <a>retract</a> to allow you to directly extract an
--   <tt>a</tt> from a <tt>t f a</tt>, if <tt>f</tt> is a valid retraction
--   from <tt>t</tt>, and <tt>f</tt> is an instance of <a>Copointed</a>.
--   
--   Useful <tt>f</tt>s include <a>Identity</a> or related newtype wrappers
--   from base:
--   
--   <pre>
--   <a>extractI</a>
--       :: (<a>Interpret</a> t, <a>C</a> t <a>Identity</a>)
--       =&gt; t <a>Identity</a> a
--       -&gt; a
--   </pre>
extractI :: (Interpret t, C t f, Copointed f) => t f a -> a

-- | Useful wrapper over <a>interpret</a> to allow you to directly extract
--   a value <tt>b</tt> out of the <tt>t f a</tt>, if you can convert <tt>f
--   x</tt> into <tt>b</tt>.
--   
--   Note that depending on the constraints on the interpretation of
--   <tt>t</tt>, you may have extra constraints on <tt>b</tt>.
--   
--   <ul>
--   <li>If <tt><a>C</a> t</tt> is <a>Unconstrained</a>, there are no
--   constraints on <tt>b</tt></li>
--   <li>If <tt><a>C</a> t</tt> is <a>Apply</a>, <tt>b</tt> needs to be an
--   instance of <a>Semigroup</a></li>
--   <li>If <tt><a>C</a> t</tt> is <a>Applicative</a>, <tt>b</tt> needs to
--   be an instance of <a>Monoid</a></li>
--   </ul>
--   
--   For some constraints (like <a>Monad</a>), this will not be usable.
--   
--   <pre>
--   -- get the length of the <tt>Map String</tt> in the <a>Step</a>.
--   <a>collectI</a> length
--        :: Step (Map String) Bool
--        -&gt; [Int]
--   </pre>
getI :: (Interpret t, C t (Const b)) => (forall x. f x -> b) -> t f a -> b

-- | Useful wrapper over <a>getI</a> to allow you to collect a <tt>b</tt>
--   from all instances of <tt>f</tt> inside a <tt>t f a</tt>.
--   
--   This will work if <tt><a>C</a> t</tt> is <a>Unconstrained</a>,
--   <a>Apply</a>, or <a>Applicative</a>.
--   
--   <pre>
--   -- get the lengths of all <tt>Map String</tt>s in the <tt>Ap</tt>.
--   <a>collectI</a> length
--        :: Ap (Map String) Bool
--        -&gt; [Int]
--   </pre>
collectI :: (Interpret t, C t (Const [b])) => (forall x. f x -> b) -> t f a -> [b]

-- | A constraint on <tt>a</tt> for both <tt>c a</tt> and <tt>d a</tt>.
--   Requiring <tt><a>AndC</a> <a>Show</a> <a>Eq</a> a</tt> is the same as
--   requiring <tt>(<a>Show</a> a, <a>Eq</a> a)</tt>.
class (c a, d a) => AndC c d a
instance forall k (c :: k -> GHC.Types.Constraint) (a :: k) (d :: k -> GHC.Types.Constraint). (c a, d a) => Data.Functor.Interpret.AndC c d a
instance (Data.Functor.Interpret.Interpret s, Data.Functor.Interpret.Interpret t) => Data.Functor.Interpret.Interpret (Control.Monad.Trans.Compose.ComposeT s t)
instance Data.Functor.Interpret.Interpret Data.Functor.Coyoneda.Coyoneda
instance Data.Functor.Interpret.Interpret Control.Applicative.Free.Ap
instance Data.Functor.Interpret.Interpret Control.Applicative.ListF.ListF
instance Data.Functor.Interpret.Interpret Control.Applicative.ListF.NonEmptyF
instance Data.Functor.Interpret.Interpret Control.Applicative.ListF.MaybeF
instance Data.Functor.Interpret.Interpret Control.Applicative.Step.Step
instance Data.Functor.Interpret.Interpret Control.Applicative.Step.Steps
instance Data.Functor.Interpret.Interpret Control.Alternative.Free.Alt
instance Data.Functor.Interpret.Interpret Control.Monad.Freer.Church.Free
instance Data.Functor.Interpret.Interpret Control.Monad.Freer.Church.Free1
instance Data.Functor.Interpret.Interpret Control.Applicative.Free.Final.Ap
instance Data.Functor.Interpret.Interpret Control.Applicative.Free.Fast.Ap
instance Data.Functor.Interpret.Interpret Control.Monad.Trans.Identity.IdentityT
instance Data.Functor.Interpret.Interpret Control.Applicative.Lift.Lift
instance Data.Functor.Interpret.Interpret Data.Functor.Bind.Class.MaybeApply
instance Data.Functor.Interpret.Interpret Control.Applicative.Backwards.Backwards
instance Data.Functor.Interpret.Interpret Data.Functor.Bind.Class.WrappedApplicative
instance Data.Functor.Interpret.Interpret (Control.Monad.Trans.Reader.ReaderT r)
instance Data.Functor.Interpret.Interpret Data.Functor.Reverse.Reverse
instance Data.Functor.Interpret.Interpret t => Data.Functor.Interpret.Interpret (Data.Functor.HFunctor.HLift t)
instance Data.Functor.Interpret.Interpret t => Data.Functor.Interpret.Interpret (Data.Functor.HFunctor.HFree t)


-- | The free <a>Apply</a>. Provides <a>Ap1</a> and various utility
--   methods. See <a>Ap1</a> for more details.
--   
--   Ideally <a>Ap1</a> would be in the <i>free</i> package. However, it is
--   defined here for now.
module Data.Functor.Apply.Free

-- | One or more <tt>f</tt>s convolved with itself.
--   
--   Essentially:
--   
--   <pre>
--   <a>Ap1</a> f
--       ~ f                            -- one f
--     <a>:+:</a> (f `'Day'\\` f)          -- two f's
--     :+: (f `Day` f `Day` f)           -- three f's
--     :+: (f `Day` f `Day` f `Day` f)  -- four f's
--     :+: ...                          -- etc.
--   </pre>
--   
--   Useful if you want to promote an <tt>f</tt> to a situation with "at
--   least one <tt>f</tt> sequenced with itself".
--   
--   Mostly useful for its <a>HFunctor</a> and <a>Interpret</a> instance,
--   along with its relationship with <a>Ap</a> and <a>Day</a>.
--   
--   This is the free <a>Apply</a> --- Basically a "non-empty" <a>Ap</a>.
--   
--   The construction here is based on <a>Ap</a>, similar to now
--   <a>NonEmpty</a> is built on list.
data Ap1 :: (Type -> Type) -> Type -> Type
[Ap1] :: f a -> Ap f (a -> b) -> Ap1 f b

-- | An <tt><a>Ap1</a> f</tt> is just a <tt><a>Day</a> f (<a>Ap</a>
--   f)</tt>. This bidirectional pattern synonym lets you treat it as such.
pattern DayAp1 :: Day f (Ap f) a -> Ap1 f a

-- | An <a>Ap1</a> is a "non-empty" <a>Ap</a>; this function "forgets" the
--   non-empty property and turns it back into a normal <a>Ap</a>.
toAp :: Ap1 f ~> Ap f

-- | Convert an <a>Ap</a> into an <a>Ap1</a> if possible. If the <a>Ap</a>
--   was "empty", return the <a>Pure</a> value instead.
fromAp :: Ap f ~> (Identity :+: Ap1 f)

-- | Embed an <tt>f</tt> into <a>Ap1</a>.
liftAp1 :: f ~> Ap1 f

-- | Extract the <tt>f</tt> out of the <a>Ap1</a>.
--   
--   <pre>
--   <a>retractAp1</a> . <a>liftAp1</a> == id
--   </pre>
retractAp1 :: Apply f => Ap1 f ~> f

-- | Interpret an <tt><a>Ap</a> f</tt> into some <a>Apply</a> context
--   <tt>g</tt>.
runAp1 :: Apply g => (f ~> g) -> Ap1 f ~> g
instance GHC.Base.Functor (Data.Functor.Apply.Free.Ap1 f)
instance Data.Functor.Bind.Class.Apply (Data.Functor.Apply.Free.Ap1 f)
instance Data.Functor.HFunctor.Internal.HFunctor Data.Functor.Apply.Free.Ap1
instance Data.Functor.HFunctor.Inject Data.Functor.Apply.Free.Ap1
instance Data.Functor.HFunctor.HBind Data.Functor.Apply.Free.Ap1
instance Data.Functor.Interpret.Interpret Data.Functor.Apply.Free.Ap1


-- | The free <a>Apply</a>. Provides <a>Ap1</a> and various utility
--   methods. See <a>Ap1</a> for more details.
--   
--   Ideally <a>Ap1</a> would be in the <i>free</i> package. However, it is
--   defined here for now.
module Data.Functor.HFunctor.Final

-- | A simple way to inject/reject into any eventual typeclass.
--   
--   In a way, this is the "ultimate" multi-purpose <a>Interpret</a>
--   instance. You can use this to inject an <tt>f</tt> into a free
--   structure of any typeclass. If you want <tt>f</tt> to have a
--   <a>Monad</a> instance, for example, just use
--   
--   <pre>
--   <a>inject</a> :: f a -&gt; <a>Final</a> <a>Monad</a> f a
--   </pre>
--   
--   When you want to eventually interpret out the data, use:
--   
--   <pre>
--   <a>interpret</a> :: (f <a>~&gt;</a> g) -&gt; <a>Final</a> c f a -&gt; g a
--   </pre>
--   
--   Essentially, <tt><a>Final</a> c</tt> is the "free c". <tt><a>Final</a>
--   <a>Monad</a></tt> is the free <a>Monad</a>, etc.
--   
--   <a>Final</a> can theoretically replace <a>Ap</a>, <a>Ap1</a>,
--   <a>ListF</a>, <a>NonEmptyF</a>, <a>MaybeF</a>, <a>Free</a>,
--   <a>Identity</a>, <a>Coyoneda</a>, and other instances of
--   <a>FreeOf</a>, if you don't care about being able to pattern match on
--   explicit structure.
--   
--   However, it cannot replace <a>Interpret</a> instances that are not
--   free structures, like <a>Step</a>, <a>Steps</a>, <a>Backwards</a>,
--   etc.
--   
--   Note that this doesn't have instances for <i>all</i> the typeclasses
--   you could lift things into; you probably have to define your own if
--   you want to use <tt><a>Final</a> c</tt> as an <i>instance</i> of
--   <tt>c</tt> (using <a>liftFinal0</a>, <a>liftFinal1</a>,
--   <a>liftFinal2</a> for help).
newtype Final c f a
Final :: (forall g. c g => (forall x. f x -> g x) -> g a) -> Final c f a
[runFinal] :: Final c f a -> forall g. c g => (forall x. f x -> g x) -> g a

-- | <a>Concretize</a> a <a>Final</a>.
fromFinal :: (Interpret t, c (t f)) => Final c f ~> t f

-- | <a>Finalize</a> an <a>Interpret</a> instance.
--   
--   <pre>
--   toFinal :: <a>Coyoneda</a> f <a>~&gt;</a> <a>Final</a> <a>Functor</a> f
--   toFinal :: <a>Ap</a> f <a>~&gt;</a> <a>Final</a> <a>Applicative</a> f
--   toFinal :: <a>Alt</a> f <a>~&gt;</a> <a>Final</a> <a>Alternative</a> f
--   toFinal :: <a>Free</a> f <a>~&gt;</a> <a>Final</a> <a>Monad</a> f
--   toFinal :: <a>Lift</a> f <a>~&gt;</a> <a>Final</a> <a>Pointed</a> f
--   toFinal :: <a>ListF</a> f <a>~&gt;</a> <a>Final</a> <a>Plus</a> f
--   </pre>
--   
--   Note that the instance of <tt>c</tt> for <tt><a>Final</a> c</tt> must
--   be defined.
--   
--   This operation can potentially <i>forget</i> structure in <tt>t</tt>.
--   For example, we have:
--   
--   <pre>
--   <a>toFinal</a> :: <a>Steps</a> f ~&gt; <a>Final</a> <a>Alt</a> f
--   </pre>
--   
--   In this process, we lose the "positional" structure of <a>Steps</a>.
--   
--   In the case where <a>toFinal</a> doesn't lose any information, this
--   will form an isomorphism with <a>fromFinal</a>, and <tt>t</tt> is
--   known as the "Free <tt>c</tt>". For such a situation, <tt>t</tt> will
--   have a <a>FreeOf</a> instance.
toFinal :: (Interpret t, C t (Final c f)) => t f ~> Final c f

-- | A typeclass associating a free structure with the typeclass it is free
--   on.
--   
--   This essentially lists instances of <a>Interpret</a> where a "trip"
--   through <a>Final</a> will leave it unchanged.
--   
--   <pre>
--   <a>fromFree</a> . <a>FreeOf</a> == id
--   <a>FreeOf</a> . <a>fromFree</a> == id
--   </pre>
--   
--   This can be useful because <a>Final</a> doesn't have a concrete
--   structure that you can pattern match on and inspect, but <tt>t</tt>
--   might. This lets you work on a concrete structure if you desire.
class Interpret t => FreeOf c t | t -> c
fromFree :: FreeOf c t => t f ~> Final c f
toFree :: (FreeOf c t, Functor f) => Final c f ~> t f
fromFree :: (FreeOf c t, C t (Final c f)) => t f ~> Final c f
toFree :: (FreeOf c t, c (t f)) => Final c f ~> t f

-- | Re-interpret the context under a <a>Final</a>.
hoistFinalC :: (forall g x. (c g => g x) -> d g => g x) -> Final c f a -> Final d f a

-- | Lift an action into a <a>Final</a>.
liftFinal0 :: (forall g. c g => g a) -> Final c f a

-- | Map the action in a <a>Final</a>.
liftFinal1 :: (forall g. c g => g a -> g b) -> Final c f a -> Final c f b

-- | Merge two <a>Final</a> actions.
liftFinal2 :: (forall g. c g => g a -> g b -> g d) -> Final c f a -> Final c f b -> Final c f d
instance Data.Functor.HFunctor.Final.FreeOf GHC.Base.Functor Data.Functor.Coyoneda.Coyoneda
instance Data.Functor.HFunctor.Final.FreeOf GHC.Base.Applicative Control.Applicative.Free.Ap
instance Data.Functor.HFunctor.Final.FreeOf Data.Functor.Bind.Class.Apply Data.Functor.Apply.Free.Ap1
instance Data.Functor.HFunctor.Final.FreeOf GHC.Base.Applicative Control.Applicative.Free.Fast.Ap
instance Data.Functor.HFunctor.Final.FreeOf GHC.Base.Alternative Control.Alternative.Free.Alt
instance Data.Functor.HFunctor.Final.FreeOf GHC.Base.Monad Control.Monad.Freer.Church.Free
instance Data.Functor.HFunctor.Final.FreeOf Data.Functor.Bind.Class.Bind Control.Monad.Freer.Church.Free1
instance Data.Functor.HFunctor.Final.FreeOf Data.Pointed.Pointed Control.Applicative.Lift.Lift
instance Data.Functor.HFunctor.Final.FreeOf Data.Pointed.Pointed Data.Functor.Bind.Class.MaybeApply
instance Data.Functor.HFunctor.Final.FreeOf Data.Functor.Alt.Alt Control.Applicative.ListF.NonEmptyF
instance Data.Functor.HFunctor.Final.FreeOf Data.Functor.Plus.Plus Control.Applicative.ListF.ListF
instance Data.Functor.HFunctor.Final.FreeOf Data.Constraint.Trivial.Unconstrained Control.Monad.Trans.Identity.IdentityT
instance GHC.Base.Functor (Data.Functor.HFunctor.Final.Final GHC.Base.Functor f)
instance GHC.Base.Functor (Data.Functor.HFunctor.Final.Final Data.Functor.Bind.Class.Apply f)
instance Data.Functor.Bind.Class.Apply (Data.Functor.HFunctor.Final.Final Data.Functor.Bind.Class.Apply f)
instance GHC.Base.Functor (Data.Functor.HFunctor.Final.Final Data.Functor.Bind.Class.Bind f)
instance Data.Functor.Bind.Class.Apply (Data.Functor.HFunctor.Final.Final Data.Functor.Bind.Class.Bind f)
instance Data.Functor.Bind.Class.Bind (Data.Functor.HFunctor.Final.Final Data.Functor.Bind.Class.Bind f)
instance GHC.Base.Functor (Data.Functor.HFunctor.Final.Final GHC.Base.Applicative f)
instance Data.Functor.Bind.Class.Apply (Data.Functor.HFunctor.Final.Final GHC.Base.Applicative f)
instance GHC.Base.Applicative (Data.Functor.HFunctor.Final.Final GHC.Base.Applicative f)
instance GHC.Base.Functor (Data.Functor.HFunctor.Final.Final GHC.Base.Alternative f)
instance Data.Functor.Bind.Class.Apply (Data.Functor.HFunctor.Final.Final GHC.Base.Alternative f)
instance GHC.Base.Applicative (Data.Functor.HFunctor.Final.Final GHC.Base.Alternative f)
instance GHC.Base.Alternative (Data.Functor.HFunctor.Final.Final GHC.Base.Alternative f)
instance GHC.Base.Functor (Data.Functor.HFunctor.Final.Final GHC.Base.Monad f)
instance Data.Functor.Bind.Class.Apply (Data.Functor.HFunctor.Final.Final GHC.Base.Monad f)
instance GHC.Base.Applicative (Data.Functor.HFunctor.Final.Final GHC.Base.Monad f)
instance GHC.Base.Monad (Data.Functor.HFunctor.Final.Final GHC.Base.Monad f)
instance GHC.Base.Functor (Data.Functor.HFunctor.Final.Final GHC.Base.MonadPlus f)
instance GHC.Base.Applicative (Data.Functor.HFunctor.Final.Final GHC.Base.MonadPlus f)
instance GHC.Base.Monad (Data.Functor.HFunctor.Final.Final GHC.Base.MonadPlus f)
instance GHC.Base.Alternative (Data.Functor.HFunctor.Final.Final GHC.Base.MonadPlus f)
instance GHC.Base.MonadPlus (Data.Functor.HFunctor.Final.Final GHC.Base.MonadPlus f)
instance Data.Pointed.Pointed (Data.Functor.HFunctor.Final.Final Data.Pointed.Pointed f)
instance GHC.Base.Functor (Data.Functor.HFunctor.Final.Final (Control.Monad.Reader.Class.MonadReader r) f)
instance GHC.Base.Applicative (Data.Functor.HFunctor.Final.Final (Control.Monad.Reader.Class.MonadReader r) f)
instance Data.Functor.Bind.Class.Apply (Data.Functor.HFunctor.Final.Final (Control.Monad.Reader.Class.MonadReader r) f)
instance GHC.Base.Monad (Data.Functor.HFunctor.Final.Final (Control.Monad.Reader.Class.MonadReader r) f)
instance Control.Monad.Reader.Class.MonadReader r (Data.Functor.HFunctor.Final.Final (Control.Monad.Reader.Class.MonadReader r) f)
instance GHC.Base.Functor (Data.Functor.HFunctor.Final.Final Data.Functor.Alt.Alt f)
instance Data.Functor.Alt.Alt (Data.Functor.HFunctor.Final.Final Data.Functor.Alt.Alt f)
instance GHC.Base.Functor (Data.Functor.HFunctor.Final.Final Data.Functor.Plus.Plus f)
instance Data.Functor.Alt.Alt (Data.Functor.HFunctor.Final.Final Data.Functor.Plus.Plus f)
instance Data.Functor.Plus.Plus (Data.Functor.HFunctor.Final.Final Data.Functor.Plus.Plus f)
instance Data.Functor.HFunctor.Internal.HFunctor (Data.Functor.HFunctor.Final.Final c)
instance Data.Functor.HFunctor.Inject (Data.Functor.HFunctor.Final.Final c)
instance Data.Functor.Interpret.Interpret (Data.Functor.HFunctor.Final.Final c)

module Data.Functor.Associative

-- | An <a>HBifunctor</a> where it doesn't matter which binds first is
--   <a>Associative</a>. Knowing this gives us a lot of power to rearrange
--   the internals of our <a>HFunctor</a> at will.
--   
--   For example, for the functor product:
--   
--   <pre>
--   data (f <a>:*:</a> g) a = f a :*: g a
--   </pre>
--   
--   We know that <tt>f :*: (g :*: h)</tt> is the same as <tt>(f :*: g) :*:
--   h</tt>.
class HBifunctor t => Associative t

-- | The isomorphism between <tt>t f (t g h) a</tt> and <tt>t (t f g) h
--   a</tt>. To use this isomorphism, see <a>assoc</a> and <a>disassoc</a>.
associating :: (Associative t, Functor f, Functor g, Functor h) => t f (t g h) <~> t (t f g) h

-- | Reassociate an application of <tt>t</tt>.
assoc :: (Associative t, Functor f, Functor g, Functor h) => t f (t g h) ~> t (t f g) h

-- | Reassociate an application of <tt>t</tt>.
disassoc :: (Associative t, Functor f, Functor g, Functor h) => t (t f g) h ~> t f (t g h)
class (Associative t, Interpret (SF t)) => Semigroupoidal t where {
    type family SF t :: (Type -> Type) -> Type -> Type;
}

-- | If a <tt><a>SF</a> t f</tt> represents multiple applications of <tt>t
--   f</tt> to itself, then we can also "append" two <tt><a>SF</a> t
--   f</tt>s applied to themselves into one giant <tt><a>SF</a> t f</tt>
--   containing all of the <tt>t f</tt>s.
appendSF :: Semigroupoidal t => t (SF t f) (SF t f) ~> SF t f
matchSF :: (Semigroupoidal t, Functor f) => SF t f ~> (f :+: t f (SF t f))

-- | Prepend an application of <tt>t f</tt> to the front of a <tt><a>SF</a>
--   t f</tt>.
consSF :: Semigroupoidal t => t f (SF t f) ~> SF t f

-- | Embed a direct application of <tt>f</tt> to itself into a
--   <tt><a>SF</a> t f</tt>.
toSF :: Semigroupoidal t => t f f ~> SF t f

-- | A version of <a>retract</a> that works for a <tt>Tensor</tt>. It
--   retracts <i>both</i> <tt>f</tt>s into a single <tt>f</tt>.
biretract :: (Semigroupoidal t, C (SF t) f) => t f f ~> f

-- | A version of <a>interpret</a> that works for a <tt>Tensor</tt>. It
--   takes two interpreting functions, and interprets both joined functors
--   one after the other into <tt>h</tt>.
binterpret :: (Semigroupoidal t, C (SF t) h) => (f ~> h) -> (g ~> h) -> t f g ~> h

-- | An <tt><a>SF</a> t f</tt> represents the successive application of
--   <tt>t</tt> to <tt>f</tt>, over and over again. So, that means that an
--   <tt><a>SF</a> t f</tt> must either be a single <tt>f</tt>, or an <tt>t
--   f (SF t f)</tt>.
--   
--   <a>matchingSF</a> states that these two are isomorphic. Use
--   <a>matchSF</a> and <tt><a>inject</a> <a>!*!</a> <a>consSF</a></tt> to
--   convert between one and the other.
matchingSF :: (Semigroupoidal t, Functor f) => SF t f <~> (f :+: t f (SF t f))

-- | Useful wrapper over <tt>retractT</tt> to allow you to directly extract
--   an <tt>a</tt> from a <tt>t f f a</tt>, if <tt>f</tt> is a valid
--   retraction from <tt>t</tt>, and <tt>f</tt> is an instance of
--   <a>Copointed</a>.
--   
--   Useful <tt>f</tt>s include <a>Identity</a> or related newtype wrappers
--   from base:
--   
--   <pre>
--   <a>extractT</a>
--       :: (<tt>Monoidal</tt> t, <a>C</a> (<tt>MF</tt> t) <a>Identity</a>)
--       =&gt; t <a>Identity</a> <a>Identity</a> a
--       -&gt; a
--   </pre>
extractT :: (Semigroupoidal t, C (SF t) f, Copointed f) => t f f a -> a

-- | Useful wrapper over <a>interpret</a> to allow you to directly extract
--   a value <tt>b</tt> out of the <tt>t f a</tt>, if you can convert <tt>f
--   x</tt> into <tt>b</tt>.
--   
--   Note that depending on the constraints on the interpretation of
--   <tt>t</tt>, you may have extra constraints on <tt>b</tt>.
--   
--   <ul>
--   <li>If <tt><a>C</a> (<tt>MF</tt> t)</tt> is <a>Unconstrained</a>,
--   there are no constraints on <tt>b</tt></li>
--   <li>If <tt><a>C</a> (<tt>MF</tt> t)</tt> is <a>Apply</a>, <tt>b</tt>
--   needs to be an instance of <a>Semigroup</a></li>
--   <li>If <tt><a>C</a> (<tt>MF</tt> t)</tt> is <a>Applicative</a>,
--   <tt>b</tt> needs to be an instance of <a>Monoid</a></li>
--   </ul>
--   
--   For some constraints (like <a>Monad</a>), this will not be usable.
--   
--   <pre>
--   -- Return the length of either the list, or the Map, depending on which
--   --   one s in the <a>+</a>
--   length !*! length
--       :: ([] :+: Map Int) Char
--       -&gt; Int
--   
--   -- Return the length of both the list and the map, added together
--   (Sum . length) !*! (Sum . length)
--       :: Day [] (Map Int) Char
--       -&gt; Sum Int
--   </pre>
getT :: (Semigroupoidal t, C (SF t) (Const b)) => (forall x. f x -> b) -> (forall x. g x -> b) -> t f g a -> b

-- | Useful wrapper over <a>getT</a> to allow you to collect a <tt>b</tt>
--   from all instances of <tt>f</tt> and <tt>g</tt> inside a <tt>t f g
--   a</tt>.
--   
--   This will work if <tt><a>C</a> t</tt> is <a>Unconstrained</a>,
--   <a>Apply</a>, or <a>Applicative</a>.
collectT :: (Semigroupoidal t, C (SF t) (Const [b])) => (forall x. f x -> b) -> (forall x. g x -> b) -> t f g a -> [b]

-- | Infix alias for <a>binterpret</a>
(!*!) :: (Semigroupoidal t, C (SF t) h) => (f ~> h) -> (g ~> h) -> t f g ~> h
infixr 5 !*!

-- | Infix alias for <a>getT</a>
(!$!) :: (Semigroupoidal t, C (SF t) (Const b)) => (forall x. f x -> b) -> (forall x. g x -> b) -> t f g a -> b
infixr 5 !$!
data Chain1 t f a
Done1 :: f a -> Chain1 t f a
More1 :: t f (Chain1 t f) a -> Chain1 t f a
foldChain1 :: forall t f g. HBifunctor t => (f ~> g) -> (t f g ~> g) -> Chain1 t f ~> g
unfoldChain1 :: forall t f g. HBifunctor t => (g ~> (f :+: t f g)) -> g ~> Chain1 t f

-- | A type <tt><a>SF</a> t</tt> is supposed to represent the successive
--   application of <tt>t</tt>s to itself. The type <tt><a>Chain1</a> t
--   f</tt> is an actual concrete ADT that contains successive applications
--   of <tt>t</tt> to itself, and you can pattern match on each layer.
--   
--   <a>unrollingSF</a> states that the two types are isormorphic. Use
--   <tt>runollSF</tt> and <a>rerollSF</a> to convert between the two.
unrollingSF :: forall t f. (Semigroupoidal t, Functor f) => SF t f <~> Chain1 t f

-- | A type <tt><a>SF</a> t</tt> is supposed to represent the successive
--   application of <tt>t</tt>s to itself. <a>unrollSF</a> makes that
--   successive application explicit, buy converting it to a literal
--   <a>Chain1</a> of applications of <tt>t</tt> to itself.
unrollSF :: forall t f. (Semigroupoidal t, Functor f) => SF t f ~> Chain1 t f

-- | A type <tt><a>SF</a> t</tt> is supposed to represent the successive
--   application of <tt>t</tt>s to itself. <a>rerollSF</a> takes an
--   explicit <a>Chain1</a> of applications of <tt>t</tt> to itself and
--   rolls it back up into an <tt><a>SF</a> t</tt>.
rerollSF :: Semigroupoidal t => Chain1 t f ~> SF t f
instance (GHC.Base.Functor f, GHC.Base.Functor (t f (Data.Functor.Associative.Chain1 t f))) => GHC.Base.Functor (Data.Functor.Associative.Chain1 t f)
instance (Data.Functor.Classes.Show1 (t f (Data.Functor.Associative.Chain1 t f)), Data.Functor.Classes.Show1 f) => Data.Functor.Classes.Show1 (Data.Functor.Associative.Chain1 t f)
instance (Data.Functor.Classes.Show1 (t f (Data.Functor.Associative.Chain1 t f)), Data.Functor.Classes.Show1 f, GHC.Show.Show a) => GHC.Show.Show (Data.Functor.Associative.Chain1 t f a)
instance Data.Functor.HFunctor.Internal.HBifunctor t => Data.Functor.HFunctor.Internal.HFunctor (Data.Functor.Associative.Chain1 t)
instance Data.Functor.HFunctor.Internal.HBifunctor t => Data.Functor.HFunctor.Inject (Data.Functor.Associative.Chain1 t)
instance (Data.Functor.HFunctor.Internal.HBifunctor t, Data.Functor.Associative.Semigroupoidal t) => Data.Functor.Interpret.Interpret (Data.Functor.Associative.Chain1 t)
instance Data.Functor.Associative.Semigroupoidal (GHC.Generics.:*:)
instance Data.Functor.Associative.Semigroupoidal Data.Functor.Day.Day
instance Data.Functor.Associative.Semigroupoidal (GHC.Generics.:+:)
instance Data.Functor.Associative.Semigroupoidal Control.Monad.Freer.Church.Comp
instance (Data.Functor.Interpret.Interpret t, Data.Functor.HFunctor.HBind t) => Data.Functor.Associative.Semigroupoidal (Data.Functor.HBifunctor.ClownT t)
instance (Data.Functor.Interpret.Interpret t, Data.Functor.HFunctor.HBind t) => Data.Functor.Associative.Semigroupoidal (Data.Functor.HBifunctor.JokerT t)
instance Data.Functor.Associative.Associative (GHC.Generics.:*:)
instance Data.Functor.Associative.Associative Data.Functor.Day.Day
instance Data.Functor.Associative.Associative (GHC.Generics.:+:)
instance Data.Functor.Associative.Associative Control.Monad.Freer.Church.Comp
instance (Data.Functor.Interpret.Interpret t, Data.Functor.HFunctor.HBind t) => Data.Functor.Associative.Associative (Data.Functor.HBifunctor.ClownT t)
instance (Data.Functor.Interpret.Interpret t, Data.Functor.HFunctor.HBind t) => Data.Functor.Associative.Associative (Data.Functor.HBifunctor.JokerT t)


-- | This module provides tools for working with binary functor
--   combinators.
--   
--   <a>Data.Functor.HFunctor</a> deals with <i>single</i> functor
--   combinators (transforming a single functor). This module provides
--   tools for working with combinators that combine and mix two functors
--   "together".
--   
--   The binary analog of <a>HFunctor</a> is <a>HBifunctor</a>: we can map
--   a structure-transforming function over both of the transformed
--   functors.
--   
--   The binary analog of <a>Interpret</a> is <a>Monoidal</a> (and
--   <a>Tensor</a>). If your combinator is an instance of <a>Monoidal</a>,
--   it means that you can "squish" both arguments together into an
--   <a>Interpret</a>. For example:
--   
--   <pre>
--   <a>toMF</a> :: (f <a>:*:</a> f) a -&gt; <a>ListF</a> f a
--   <a>toMF</a> :: <a>Comp</a> f f a -&gt; <a>Free</a> f a
--   <a>toMF</a> :: <a>Day</a> f f a -&gt; <a>Ap</a> f a
--   </pre>
module Data.Functor.Tensor

-- | A <a>HBifunctor</a> can be a <a>Tensor</a> if:
--   
--   <ol>
--   <li>There is some identity <tt>i</tt> where <tt>t i f</tt> is
--   equivalent to just <tt>f</tt>. That is, "enhancing" <tt>f</tt> with
--   <tt>t i</tt> does nothing.</li>
--   <li><tt>t</tt> is associative: <tt>f <tt>t</tt> (g <tt>t</tt> h)</tt>
--   is equivalent to <tt>(f <tt>t</tt> g) <tt>t</tt> h)</tt>.</li>
--   </ol>
--   
--   The methods in this class provide us useful ways of navigating a
--   <tt><a>Tensor</a> t</tt> with respect to this property.
--   
--   Realistically, there won't be any <a>Tensor</a> instances that are not
--   also <a>Monoidal</a> instances. The two classes are separated only to
--   help organize functionality into cleaner sub-divisions.
class Associative t => Tensor t where {
    
    -- | The identity of <tt><a>Tensor</a> t</tt>. If you "combine" <tt>f</tt>
    --   with the identity, it leaves <tt>f</tt> unchanged.
    --   
    --   For example, the identity of <a>:*:</a> is <a>Proxy</a>. This is
    --   because
    --   
    --   <pre>
    --   (<a>Proxy</a> :*: f) a
    --   </pre>
    --   
    --   is equivalent to just
    --   
    --   <pre>
    --   f a
    --   </pre>
    --   
    --   <a>:*:</a>-ing <tt>f</tt> with <a>Proxy</a> gives you no additional
    --   structure.
    type family I t :: Type -> Type;
}
intro1 :: Tensor t => f ~> t f (I t)
intro2 :: Tensor t => g ~> t (I t) g
elim1 :: (Tensor t, Functor f) => t f (I t) ~> f
elim2 :: (Tensor t, Functor g) => t (I t) g ~> g
rightIdentity :: (Tensor t, Functor f) => f <~> t f (I t)
leftIdentity :: (Tensor t, Functor g) => g <~> t (I t) g
voidLeftIdentity :: f <~> (Void1 :+: f)
voidRightIdentity :: f <~> (Void1 :+: f)

-- | For some tensors <tt>t</tt>, you can represt the act of repeatedly
--   combining the same functor an arbitrary amount of times:
--   
--   <pre>
--   t f f                    -- 2 times
--   t f (t f f)              -- 3 times
--   t f (t f (t f f))        -- 4 times
--   t f (t f (t f (t f f)))  -- 5 times
--   </pre>
--   
--   Sometimes, we have a type that can <i>describe</i> this repeated
--   combination. For example, <tt><a>ListF</a> f</tt> is the type that
--   contains <tt>f</tt> <a>:*:</a>d with itself many number of times, and
--   <tt><a>Ap</a></tt> is the type that contains <tt>f</tt> <a>Day</a>d
--   with itself many number of times.
--   
--   <pre>
--   <a>ListF</a> [x, y]       == x <a>:*:</a> y
--   <a>ListF</a> [x, y, z]    == x <a>:*:</a> y <a>:*:</a> z
--   <a>ListF</a> [x, y, z, q] == x <a>:*:</a> y <a>:*:</a> z <a>:*:</a> q
--   </pre>
--   
--   This is convenient because it allows you to represent repeated
--   applications of <tt>t</tt> as a single data type.
--   
--   For example, <tt><a>Day</a> f f</tt> can be interpreted as "two
--   sequenced <tt>f</tt>s", allowing you to specify "I want exactly two
--   sequenced <tt>f</tt>s". If you want to specify "I want 0, 1, or many
--   <tt>f</tt>s sequenced after each other", then you can use
--   <tt><a>Ap</a> f</tt>.
--   
--   And, <tt>f <a>:*:</a> f</tt> can be interpreted as "a free selection
--   of two <tt>f</tt>s", allowing you to specify "I have to <tt>f</tt>s
--   that I can use". If you want to specify "I want 0, 1, or many
--   different <tt>f</tt>s that I can use", you can use <tt><a>ListF</a>
--   f</tt>.
--   
--   The <a>Monoidal</a> class unifies different such patterns. The
--   associated type <a>MF</a> is the "repeated aplications of <tt>t</tt>"
--   type.
--   
--   See documentation of <a>Data.Functor.Tensor</a> for information on how
--   to define instances of this typeclass.
class (Tensor t, Semigroupoidal t, Interpret (MF t)) => Monoidal t where {
    type family MF t :: (Type -> Type) -> Type -> Type;
}
appendMF :: Monoidal t => t (MF t f) (MF t f) ~> MF t f
splitSF :: Monoidal t => SF t f ~> t f (MF t f)
splittingMF :: Monoidal t => MF t f <~> (I t :+: t f (MF t f))
toMF :: Monoidal t => t f f ~> MF t f
fromSF :: Monoidal t => SF t f ~> MF t f
pureT :: (Monoidal t, C (MF t) f) => I t ~> f
nilMF :: forall t f. Monoidal t => I t ~> MF t f
consMF :: forall t f. Monoidal t => t f (MF t f) ~> MF t f
unconsMF :: forall t f. Monoidal t => MF t f ~> (I t :+: t f (MF t f))
unmatchMF :: forall t f. Monoidal t => (I t :+: SF t f) ~> MF t f

-- | Convenient wrapper over <a>intro1</a> that lets us introduce an
--   arbitrary functor <tt>g</tt> to the right of an <tt>f</tt>.
inL :: forall t f g a. (Monoidal t, C (MF t) g) => f a -> t f g a

-- | Convenient wrapper over <a>intro2</a> that lets us introduce an
--   arbitrary functor <tt>f</tt> to the right of a <tt>g</tt>.
inR :: forall t f g a. (Monoidal t, C (MF t) f) => g a -> t f g a

-- | A useful construction that works like a "linked list" of <tt>t f</tt>
--   applied to itself multiple times. That is, it contains <tt>t f f</tt>,
--   <tt>t f (t f f)</tt>, <tt>t f (t f (t f f))</tt>, etc.
--   
--   If <tt>t</tt> is <a>Monoidal</a>, then it means we can "collapse" this
--   linked list into some final type <tt><a>MF</a> t</tt> (<a>fromF</a>),
--   and also extract it back into a linked list (<tt>toF</tt>).
data Chain t i f a
Done :: i a -> Chain t i f a
More :: t f (Chain t i f) a -> Chain t i f a
foldChain :: forall t i f g. HBifunctor t => (i ~> g) -> (t f g ~> g) -> Chain t i f ~> g
unfoldChain :: forall t f g i. HBifunctor t => (g ~> (i :+: t f g)) -> g ~> Chain t i f
unrollMF :: forall t f. Monoidal t => MF t f ~> Chain t (I t) f
rerollMF :: forall t f. Monoidal t => Chain t (I t) f ~> MF t f
unrollingMF :: forall t f. Monoidal t => MF t f <~> Chain t (I t) f
fromChain1 :: forall t f. Monoidal t => Chain1 t f ~> Chain t (I t) f
instance (Data.Functor.Tensor.Monoidal t, i Data.Type.Equality.~ Data.Functor.Tensor.I t) => Data.Functor.Interpret.Interpret (Data.Functor.Tensor.Chain t i)
instance Data.Functor.Tensor.Monoidal (GHC.Generics.:*:)
instance Data.Functor.Tensor.Monoidal Data.Functor.Day.Day
instance Data.Functor.Tensor.Monoidal (GHC.Generics.:+:)
instance Data.Functor.Tensor.Monoidal Control.Monad.Freer.Church.Comp
instance forall k (i :: * -> *) (t :: k -> (* -> *) -> * -> *) (f :: k). (GHC.Base.Functor i, GHC.Base.Functor (t f (Data.Functor.Tensor.Chain t i f))) => GHC.Base.Functor (Data.Functor.Tensor.Chain t i f)
instance forall k (t :: k -> (* -> *) -> * -> *) (f :: k) (i :: * -> *). (Data.Functor.Classes.Show1 (t f (Data.Functor.Tensor.Chain t i f)), Data.Functor.Classes.Show1 i) => Data.Functor.Classes.Show1 (Data.Functor.Tensor.Chain t i f)
instance forall k (t :: k -> (* -> *) -> * -> *) (f :: k) (i :: * -> *) a. (Data.Functor.Classes.Show1 (t f (Data.Functor.Tensor.Chain t i f)), Data.Functor.Classes.Show1 i, GHC.Show.Show a) => GHC.Show.Show (Data.Functor.Tensor.Chain t i f a)
instance Data.Functor.HFunctor.Internal.HBifunctor t => Data.Functor.HFunctor.Internal.HFunctor (Data.Functor.Tensor.Chain t i)
instance (Data.Functor.Tensor.Tensor t, i Data.Type.Equality.~ Data.Functor.Tensor.I t) => Data.Functor.HFunctor.Inject (Data.Functor.Tensor.Chain t i)
instance Data.Functor.Tensor.Tensor (GHC.Generics.:*:)
instance Data.Functor.Tensor.Tensor Data.Functor.Day.Day
instance Data.Functor.Tensor.Tensor (GHC.Generics.:+:)
instance Data.Functor.Tensor.Tensor Control.Monad.Freer.Church.Comp

module Data.Functor.Tensor.Matchable
class Monoidal t => Matchable t
unsplitSF :: Matchable t => t f (MF t f) ~> SF t f
matchMF :: Matchable t => MF t f ~> (I t :+: SF t f)
splittingSF :: Matchable t => SF t f <~> t f (MF t f)
matchingMF :: forall t f. Matchable t => MF t f <~> (I t :+: SF t f)
splitChain1 :: forall t f. Matchable t => Chain1 t f ~> t f (Chain t (I t) f)
unsplitChain1 :: forall t f. (Matchable t, Functor f) => t f (Chain t (I t) f) ~> Chain1 t f
splittingChain1 :: forall t f. (Matchable t, Functor f) => Chain1 t f <~> t f (Chain t (I t) f)
matchChain :: forall t f. (Matchable t, Functor f) => Chain t (I t) f ~> (I t :+: Chain1 t f)
unmatchChain :: forall t f. Matchable t => (I t :+: Chain1 t f) ~> Chain t (I t) f
matchingChain :: forall t f. (Matchable t, Functor f) => Chain t (I t) f <~> (I t :+: Chain1 t f)
instance Data.Functor.Tensor.Matchable.Matchable (GHC.Generics.:*:)
instance Data.Functor.Tensor.Matchable.Matchable Data.Functor.Day.Day
instance Data.Functor.Tensor.Matchable.Matchable (GHC.Generics.:+:)


-- | Functor combinators and tools (typeclasses and utiility functions) to
--   manipulate them.
--   
--   Classes include:
--   
--   <ul>
--   <li><a>HFunctor</a> and <a>HBifunctor</a>, used to swap out the
--   functors that the combinators modify</li>
--   <li><a>Interpret</a>, <a>Tensor</a>, <a>Monoidal</a>, used to inject
--   and interpret functor values with respect to their combinators.</li>
--   </ul>
--   
--   We have some helpful utility functions, as well, built on top of these
--   typeclasses.
--   
--   The second half of this module exports the various useful functor
--   combinators that can modify functors to add extra functionality, or
--   join two functors together and mix them in different ways. Use them to
--   build your final structure by combining simpler ones in composable
--   ways!
--   
--   See README for a tutorial and a rundown on each different functor
--   combinator.
module Data.Functor.Combinator

-- | A natural transformation from <tt>f</tt> to <tt>g</tt>.
type (~>) (f :: k -> Type) (g :: k -> Type) = forall (x :: k). () => f x -> g x
infixr 0 ~>

-- | An <a>HFunctor</a> can be thought of a unary "functor transformer" ---
--   a basic functor combinator. It takes a functor as input and returns a
--   functor as output.
--   
--   It "enhances" a functor with extra structure (sort of like how a monad
--   transformer enhances a <a>Monad</a> with extra structure).
--   
--   As a uniform inteface, we can "swap the underlying functor" (also
--   sometimes called "hoisting"). This is what <a>hmap</a> does: it lets
--   us swap out the <tt>f</tt> in a <tt>t f</tt> for a <tt>t g</tt>.
--   
--   For example, the free monad <a>Free</a> takes a <a>Functor</a> and
--   returns a new <a>Functor</a>. In the process, it provides a monadic
--   structure over <tt>f</tt>. <a>hmap</a> lets us turn a <tt><a>Free</a>
--   f</tt> into a <tt><a>Free</a> g</tt>: a monad built over <tt>f</tt>
--   can be turned into a monad built over <tt>g</tt>.
--   
--   For the ability to move in and out of the enhanced functor, see
--   <a>Interpret</a>.
class HFunctor t

-- | If we can turn an <tt>f</tt> into a <tt>g</tt>, then we can turn a
--   <tt>t f</tt> into a <tt>t g</tt>.
--   
--   It must be the case that
--   
--   <pre>
--   <a>hmap</a> <a>id</a> == id
--   </pre>
--   
--   Essentially, <tt>t f</tt> adds some "extra structure" to <tt>f</tt>.
--   <a>hmap</a> must swap out the functor, <i>without affecting the added
--   structure</i>.
--   
--   For example, <tt><a>ListF</a> f a</tt> is essentially a list of <tt>f
--   a</tt>s. If we <a>hmap</a> to swap out the <tt>f a</tt>s for <tt>g
--   a</tt>s, then we must ensure that the "added structure" (here, the
--   number of items in the list) remains the same. So, <a>hmap</a> must
--   preserve the number of items in the list.
--   
--   The law <tt><a>hmap</a> <a>id</a> == id</tt> is a way of formalizing
--   this informal property.
hmap :: HFunctor t => (f ~> g) -> t f ~> t g

-- | An <a>Interpret</a> lets us move in and out of the "enhanced"
--   <a>Functor</a>.
--   
--   For example, <tt><a>Free</a> f</tt> is <tt>f</tt> enhanced with
--   monadic structure. We get:
--   
--   <pre>
--   <a>inject</a>    :: f a -&gt; <a>Free</a> f a
--   <a>interpret</a> :: <a>Monad</a> m =&gt; (forall x. f x -&gt; m x) -&gt; <a>Free</a> f a -&gt; m a
--   </pre>
--   
--   <a>inject</a> will let us use our <tt>f</tt> inside the enhanced
--   <tt><a>Free</a> f</tt>. <a>interpret</a> will let us "extract" the
--   <tt>f</tt> from a <tt><a>Free</a> f</tt> if we can give an
--   <i>interpreting function</i> that interprets <tt>f</tt> into some
--   target <a>Monad</a>.
--   
--   The type family <a>C</a> tells us the typeclass constraint of the
--   "target" functor. For <a>Free</a>, it is <a>Monad</a>, but for other
--   <a>Interpret</a> instances, we might have other constraints.
--   
--   We enforce that:
--   
--   <pre>
--   <a>interpret</a> id . <a>inject</a> == id
--   </pre>
--   
--   That is, if we lift a value into our structure, then immediately
--   interpret it out as itself, it should lave the value unchanged.
class Inject t => Interpret t where {
    
    -- | The constraint on the target context of <a>interpret</a>.
    type family C t :: (Type -> Type) -> Constraint;
}

-- | Remove the <tt>f</tt> out of the enhanced <tt>t f</tt> structure,
--   provided that <tt>f</tt> satisfies the necessary constraints. If it
--   doesn't, it needs to be properly <a>interpret</a>ed out.
retract :: (Interpret t, C t f) => t f ~> f

-- | Given an "interpeting function" from <tt>f</tt> to <tt>g</tt>,
--   interpret the <tt>f</tt> out of the <tt>t f</tt> into a final context
--   <tt>g</tt>.
interpret :: (Interpret t, C t g) => (f ~> g) -> t f ~> g

-- | A convenient flipped version of <a>interpret</a>.
interpretFor :: (Interpret t, C t g) => t f a -> (f ~> g) -> g a

-- | Useful wrapper over <a>retract</a> to allow you to directly extract an
--   <tt>a</tt> from a <tt>t f a</tt>, if <tt>f</tt> is a valid retraction
--   from <tt>t</tt>, and <tt>f</tt> is an instance of <a>Copointed</a>.
--   
--   Useful <tt>f</tt>s include <a>Identity</a> or related newtype wrappers
--   from base:
--   
--   <pre>
--   <a>extractI</a>
--       :: (<a>Interpret</a> t, <a>C</a> t <a>Identity</a>)
--       =&gt; t <a>Identity</a> a
--       -&gt; a
--   </pre>
extractI :: (Interpret t, C t f, Copointed f) => t f a -> a

-- | Useful wrapper over <a>interpret</a> to allow you to directly extract
--   a value <tt>b</tt> out of the <tt>t f a</tt>, if you can convert <tt>f
--   x</tt> into <tt>b</tt>.
--   
--   Note that depending on the constraints on the interpretation of
--   <tt>t</tt>, you may have extra constraints on <tt>b</tt>.
--   
--   <ul>
--   <li>If <tt><a>C</a> t</tt> is <a>Unconstrained</a>, there are no
--   constraints on <tt>b</tt></li>
--   <li>If <tt><a>C</a> t</tt> is <a>Apply</a>, <tt>b</tt> needs to be an
--   instance of <a>Semigroup</a></li>
--   <li>If <tt><a>C</a> t</tt> is <a>Applicative</a>, <tt>b</tt> needs to
--   be an instance of <a>Monoid</a></li>
--   </ul>
--   
--   For some constraints (like <a>Monad</a>), this will not be usable.
--   
--   <pre>
--   -- get the length of the <tt>Map String</tt> in the <a>Step</a>.
--   <a>collectI</a> length
--        :: Step (Map String) Bool
--        -&gt; [Int]
--   </pre>
getI :: (Interpret t, C t (Const b)) => (forall x. f x -> b) -> t f a -> b

-- | Useful wrapper over <a>getI</a> to allow you to collect a <tt>b</tt>
--   from all instances of <tt>f</tt> inside a <tt>t f a</tt>.
--   
--   This will work if <tt><a>C</a> t</tt> is <a>Unconstrained</a>,
--   <a>Apply</a>, or <a>Applicative</a>.
--   
--   <pre>
--   -- get the lengths of all <tt>Map String</tt>s in the <tt>Ap</tt>.
--   <a>collectI</a> length
--        :: Ap (Map String) Bool
--        -&gt; [Int]
--   </pre>
collectI :: (Interpret t, C t (Const [b])) => (forall x. f x -> b) -> t f a -> [b]

-- | A <a>HBifunctor</a> is like an <a>HFunctor</a>, but it enhances
--   <i>two</i> different functors instead of just one.
--   
--   Usually, it enhaces them "together" in some sort of combining way.
--   
--   This typeclass provides a uniform instance for "swapping out" or
--   "hoisting" the enhanced functors. We can hoist the first one with
--   <a>hleft</a>, the second one with <a>hright</a>, or both at the same
--   time with <a>hbimap</a>.
--   
--   For example, the <tt>f :*: g</tt> type gives us "both <tt>f</tt> and
--   <tt>g</tt>":
--   
--   <pre>
--   data (f <a>:*:</a> g) a = f a :*: g a
--   </pre>
--   
--   It combines both <tt>f</tt> and <tt>g</tt> into a unified structure
--   --- here, it does it by providing both <tt>f</tt> and <tt>g</tt>.
--   
--   The single law is:
--   
--   <pre>
--   <a>hbimap</a> <a>id</a> id == id
--   </pre>
--   
--   This ensures that <a>hleft</a>, <a>hright</a>, and <a>hbimap</a> do
--   not affect the structure that <tt>t</tt> adds on top of the underlying
--   functors.
class HBifunctor t

-- | Swap out the first transformed functor.
hleft :: HBifunctor t => (f ~> j) -> t f g ~> t j g

-- | Swap out the second transformed functor.
hright :: HBifunctor t => (g ~> k) -> t f g ~> t f k

-- | Swap out both transformed functors at the same time.
hbimap :: HBifunctor t => (f ~> j) -> (g ~> k) -> t f g ~> t j k

-- | A <a>HBifunctor</a> can be a <a>Tensor</a> if:
--   
--   <ol>
--   <li>There is some identity <tt>i</tt> where <tt>t i f</tt> is
--   equivalent to just <tt>f</tt>. That is, "enhancing" <tt>f</tt> with
--   <tt>t i</tt> does nothing.</li>
--   <li><tt>t</tt> is associative: <tt>f <tt>t</tt> (g <tt>t</tt> h)</tt>
--   is equivalent to <tt>(f <tt>t</tt> g) <tt>t</tt> h)</tt>.</li>
--   </ol>
--   
--   The methods in this class provide us useful ways of navigating a
--   <tt><a>Tensor</a> t</tt> with respect to this property.
--   
--   Realistically, there won't be any <a>Tensor</a> instances that are not
--   also <a>Monoidal</a> instances. The two classes are separated only to
--   help organize functionality into cleaner sub-divisions.
class Associative t => Tensor t where {
    
    -- | The identity of <tt><a>Tensor</a> t</tt>. If you "combine" <tt>f</tt>
    --   with the identity, it leaves <tt>f</tt> unchanged.
    --   
    --   For example, the identity of <a>:*:</a> is <a>Proxy</a>. This is
    --   because
    --   
    --   <pre>
    --   (<a>Proxy</a> :*: f) a
    --   </pre>
    --   
    --   is equivalent to just
    --   
    --   <pre>
    --   f a
    --   </pre>
    --   
    --   <a>:*:</a>-ing <tt>f</tt> with <a>Proxy</a> gives you no additional
    --   structure.
    type family I t :: Type -> Type;
}

-- | Convenient wrapper over <a>intro1</a> that lets us introduce an
--   arbitrary functor <tt>g</tt> to the right of an <tt>f</tt>.
inL :: forall t f g a. (Monoidal t, C (MF t) g) => f a -> t f g a

-- | Convenient wrapper over <a>intro2</a> that lets us introduce an
--   arbitrary functor <tt>f</tt> to the right of a <tt>g</tt>.
inR :: forall t f g a. (Monoidal t, C (MF t) f) => g a -> t f g a

-- | Infix alias for <a>getT</a>
(!$!) :: (Semigroupoidal t, C (SF t) (Const b)) => (forall x. f x -> b) -> (forall x. g x -> b) -> t f g a -> b
infixr 5 !$!

-- | Useful wrapper over <tt>retractT</tt> to allow you to directly extract
--   an <tt>a</tt> from a <tt>t f f a</tt>, if <tt>f</tt> is a valid
--   retraction from <tt>t</tt>, and <tt>f</tt> is an instance of
--   <a>Copointed</a>.
--   
--   Useful <tt>f</tt>s include <a>Identity</a> or related newtype wrappers
--   from base:
--   
--   <pre>
--   <a>extractT</a>
--       :: (<tt>Monoidal</tt> t, <a>C</a> (<tt>MF</tt> t) <a>Identity</a>)
--       =&gt; t <a>Identity</a> <a>Identity</a> a
--       -&gt; a
--   </pre>
extractT :: (Semigroupoidal t, C (SF t) f, Copointed f) => t f f a -> a

-- | Useful wrapper over <a>interpret</a> to allow you to directly extract
--   a value <tt>b</tt> out of the <tt>t f a</tt>, if you can convert <tt>f
--   x</tt> into <tt>b</tt>.
--   
--   Note that depending on the constraints on the interpretation of
--   <tt>t</tt>, you may have extra constraints on <tt>b</tt>.
--   
--   <ul>
--   <li>If <tt><a>C</a> (<tt>MF</tt> t)</tt> is <a>Unconstrained</a>,
--   there are no constraints on <tt>b</tt></li>
--   <li>If <tt><a>C</a> (<tt>MF</tt> t)</tt> is <a>Apply</a>, <tt>b</tt>
--   needs to be an instance of <a>Semigroup</a></li>
--   <li>If <tt><a>C</a> (<tt>MF</tt> t)</tt> is <a>Applicative</a>,
--   <tt>b</tt> needs to be an instance of <a>Monoid</a></li>
--   </ul>
--   
--   For some constraints (like <a>Monad</a>), this will not be usable.
--   
--   <pre>
--   -- Return the length of either the list, or the Map, depending on which
--   --   one s in the <a>+</a>
--   length !*! length
--       :: ([] :+: Map Int) Char
--       -&gt; Int
--   
--   -- Return the length of both the list and the map, added together
--   (Sum . length) !*! (Sum . length)
--       :: Day [] (Map Int) Char
--       -&gt; Sum Int
--   </pre>
getT :: (Semigroupoidal t, C (SF t) (Const b)) => (forall x. f x -> b) -> (forall x. g x -> b) -> t f g a -> b

-- | Infix alias for <a>binterpret</a>
(!*!) :: (Semigroupoidal t, C (SF t) h) => (f ~> h) -> (g ~> h) -> t f g ~> h
infixr 5 !*!

-- | Useful wrapper over <a>getT</a> to allow you to collect a <tt>b</tt>
--   from all instances of <tt>f</tt> and <tt>g</tt> inside a <tt>t f g
--   a</tt>.
--   
--   This will work if <tt><a>C</a> t</tt> is <a>Unconstrained</a>,
--   <a>Apply</a>, or <a>Applicative</a>.
collectT :: (Semigroupoidal t, C (SF t) (Const [b])) => (forall x. f x -> b) -> (forall x. g x -> b) -> t f g a -> [b]

-- | A covariant <a>Functor</a> suitable for Yoneda reduction
data Coyoneda (f :: Type -> Type) a
[Coyoneda] :: forall (f :: Type -> Type) a b. () => (b -> a) -> f b -> Coyoneda f a

-- | A list of <tt>f a</tt>s. Can be used to describe a product of many
--   different values of type <tt>f a</tt>.
--   
--   This is the Free <a>Plus</a>.
newtype ListF f a
ListF :: [f a] -> ListF f a
[runListF] :: ListF f a -> [f a]

-- | A non-empty list of <tt>f a</tt>s. Can be used to describe a product
--   between many different possible values of type <tt>f a</tt>.
--   
--   Essentially:
--   
--   <pre>
--   <a>NonEmptyF</a> f
--       ~ f                          -- one f
--     <a>:+:</a> (f <a>:*:</a> f)              -- two f's
--     :+: (f :*: f :*: f)            -- three f's
--     :+: (f :*: f :*: f :*: f)      -- four f's
--     :+: ...                        -- etc.
--   </pre>
--   
--   This is the Free <a>Plus</a>.
newtype NonEmptyF f a
NonEmptyF :: NonEmpty (f a) -> NonEmptyF f a
[runNonEmptyF] :: NonEmptyF f a -> NonEmpty (f a)

-- | Treat a <tt><a>NonEmptyF</a> f</tt> as a product between an <tt>f</tt>
--   and a <tt><a>ListF</a> f</tt>.
--   
--   <a>nonEmptyProd</a> is the record accessor.
pattern ProdNonEmpty :: (f :*: ListF f) a -> NonEmptyF f a

-- | A maybe <tt>f a</tt>.
--   
--   Can be useful for describing a "an <tt>f a</tt> that may or may not be
--   there".
--   
--   This is the free structure for a "fail"-like typeclass that only has
--   <tt>zero :: f a</tt>.
newtype MaybeF f a
MaybeF :: Maybe (f a) -> MaybeF f a
[runMaybeF] :: MaybeF f a -> Maybe (f a)

-- | The free <a>Applicative</a> for a <a>Functor</a> <tt>f</tt>.
data Ap (f :: Type -> Type) a

-- | One or more <tt>f</tt>s convolved with itself.
--   
--   Essentially:
--   
--   <pre>
--   <a>Ap1</a> f
--       ~ f                            -- one f
--     <a>:+:</a> (f `'Day'\\` f)          -- two f's
--     :+: (f `Day` f `Day` f)           -- three f's
--     :+: (f `Day` f `Day` f `Day` f)  -- four f's
--     :+: ...                          -- etc.
--   </pre>
--   
--   Useful if you want to promote an <tt>f</tt> to a situation with "at
--   least one <tt>f</tt> sequenced with itself".
--   
--   Mostly useful for its <a>HFunctor</a> and <a>Interpret</a> instance,
--   along with its relationship with <a>Ap</a> and <a>Day</a>.
--   
--   This is the free <a>Apply</a> --- Basically a "non-empty" <a>Ap</a>.
--   
--   The construction here is based on <a>Ap</a>, similar to now
--   <a>NonEmpty</a> is built on list.
data Ap1 :: (Type -> Type) -> Type -> Type
data Alt (f :: Type -> Type) a

-- | A <tt><a>Free</a> f</tt> is <tt>f</tt> enhanced with "sequential
--   binding" capabilities. It allows you to sequence multiple <tt>f</tt>s
--   one after the other, and also to determine "what <tt>f</tt> to
--   sequence" based on the result of the computation so far.
--   
--   Essentially, you can think of this as "giving <tt>f</tt> a
--   <a>Monad</a> instance", with all that that entails (<a>return</a>,
--   <a>&gt;&gt;=</a>, etc.).
--   
--   Lift <tt>f</tt> into it with <tt><a>inject</a> :: f a -&gt; Free f
--   a</tt>. When you finally want to "use" it, you can interpret it into
--   any monadic context:
--   
--   <pre>
--   <a>interpret</a>
--       :: <a>Monad</a> g
--       =&gt; (forall x. f x -&gt; g x)
--       -&gt; <a>Free</a> f a
--       -&gt; g a
--   </pre>
--   
--   Under the hood, this is the Church-encoded Freer monad. It's
--   <a>Free</a>, or <a>F</a>, but in a way that is compatible with
--   <a>HFunctor</a> and <a>Interpret</a>.
data Free f a

-- | An <tt>f a</tt>, along with a <a>Natural</a> index.
--   
--   <pre>
--   Step f a ~ (<a>Natural</a>, f a)
--   Step f   ~ ((,) <a>Natural</a>) <a>:.:</a> f       -- functor composition
--   </pre>
--   
--   It is the fixed point of applications of <a>:+:</a> (functor sums).
--   
--   Intuitively, in an infinite <tt>f :+: f :+: f :+: f ...</tt>, you have
--   exactly one <tt>f</tt> <i>somewhere</i>. A <tt><a>Step</a> f a</tt>
--   has that <tt>f</tt>, with a <a>Natural</a> giving you "where" the
--   <tt>f</tt> is in the long chain.
--   
--   Can be useful for using with the <a>Monoidal</a> instance of
--   <a>:+:</a>.
--   
--   <a>interpret</a>ing it requires no constraint on the target context.
data Step f a
Step :: Natural -> f a -> Step f a
[stepPos] :: Step f a -> Natural
[stepVal] :: Step f a -> f a

-- | A non-empty map of <a>Natural</a> to <tt>f a</tt>. Basically, contains
--   multiple <tt>f a</tt>s, each at a given <a>Natural</a> index.
--   
--   <pre>
--   Steps f a ~ <a>Map</a> <a>Natural</a> (f a)
--   Steps f   ~ <a>Map</a> <a>Natural</a> <a>:.:</a> f       -- functor composition
--   </pre>
--   
--   It is the fixed point of applications of <a>TheseT</a>.
--   
--   Intuitively, in an infinite <tt>f `TheseT` f `TheseT` f `TheseT` f
--   ...</tt>, each of those infinite positions may have an <tt>f</tt> in
--   them. However, because of the at-least-one nature of <a>TheseT</a>, we
--   know we have at least one f at one position <i>somewhere</i>.
--   
--   A <tt><a>Steps</a> f a</tt> has potentially many <tt>f</tt>s, each
--   stored at a different <a>Natural</a> position, with the guaruntee that
--   at least one <tt>f</tt> exists.
--   
--   Can be useful for using with the <a>Monoidal</a> instance of
--   <a>TheseT</a>.
--   
--   <a>interpret</a>ing it requires at least an <a>Alt</a> instance in the
--   target context, since we have to handle potentially more than one
--   <tt>f</tt>.
newtype Steps f a
Steps :: NEMap Natural (f a) -> Steps f a
[getSteps] :: Steps f a -> NEMap Natural (f a)

-- | The functor combinator that forgets all structure in the input.
--   Ignores the input structure and stores no information.
--   
--   Acts like the "zero" with respect to functor combinator composition.
--   
--   <pre>
--   <tt>ComposeT</tt> ProxyF f      ~ ProxyF
--   <tt>ComposeT</tt> f      ProxyF ~ ProxyF
--   </pre>
--   
--   It can be <a>inject</a>ed into (losing all information), but it is
--   impossible to ever <a>retract</a> or <a>interpret</a> it.
data ProxyF f a
ProxyF :: ProxyF f a

-- | <tt><a>Void2</a> a b</tt> is uninhabited for all <tt>a</tt> and
--   <tt>b</tt>.
data Void2 a b

-- | The Day convolution of two covariant functors.
data Day (f :: Type -> Type) (g :: Type -> Type) a
[Day] :: forall (f :: Type -> Type) (g :: Type -> Type) a b c. () => f b -> g c -> (b -> c -> a) -> Day f g a

-- | Products: encode multiple arguments to constructors
data (:*:) (f :: k -> Type) (g :: k -> Type) (p :: k) :: forall k. () => k -> Type -> k -> Type -> k -> Type
(:*:) :: f p -> g p -> (:*:)
infixr 6 :*:
infixr 6 :*:

-- | Sums: encode choice between constructors
data (:+:) (f :: k -> Type) (g :: k -> Type) (p :: k) :: forall k. () => k -> Type -> k -> Type -> k -> Type
L1 :: f p -> (:+:)
R1 :: g p -> (:+:)
infixr 5 :+:

-- | <a>Void1</a> is a functor that is uninhabited for all inputs. That is,
--   <tt><a>Void1</a> a</tt> is uninhabited for all <tt>a</tt>.
--   
--   The identity functor of <a>:+:</a> (and also <a>TheseT</a>)
data Void1 a

-- | A <tt>These f g a</tt> has either an <tt>f a</tt>, a <tt>g a</tt>, or
--   both.
--   
--   This is re-defined here from the <i>these</i> package, to avoid the
--   high dependency footprint.
data These1 f g a
This1 :: f a -> These1 f g a
That1 :: g a -> These1 f g a
These1 :: f a -> g a -> These1 f g a

-- | Functor composition. <tt><a>Comp</a> f g a</tt> is equivalent to <tt>f
--   (g a)</tt>, and the <a>Comp</a> pattern synonym is a way of getting
--   the <tt>f (g a)</tt> in a <tt><a>Comp</a> f g a</tt>.
--   
--   For example, <tt><a>Maybe</a> (<a>IO</a> <a>Bool</a>)</tt> is
--   <tt><a>Comp</a> <a>Maybe</a> <a>IO</a> <a>Bool</a></tt>.
--   
--   This is mostly useful for its typeclass instances: in particular,
--   <a>Functor</a>, <a>Applicative</a>, <a>HBifunctor</a>, and
--   <a>Monoidal</a>.
--   
--   This is essentially a version of <a>:.:</a> and <a>Compose</a> that
--   allows for an <a>HBifunctor</a> instance.
--   
--   It is slightly less performant. Using <tt><a>comp</a> .
--   <a>unComp</a></tt> every once in a while will concretize a <a>Comp</a>
--   value (if you have <tt><a>Functor</a> f</tt>) and remove some
--   indirection if you have a lot of chained operations.
--   
--   The "free monoid" over <a>Comp</a> is <a>Free</a>, and the "free
--   semigroup" over <a>Comp</a> is <a>Free1</a>.
data Comp f g a

-- | Pattern match on and construct a <tt><a>Comp</a> f g a</tt> as if it
--   were <tt>f (g a)</tt>.
pattern Comp :: Functor f => f (g a) -> Comp f g a

-- | A simple way to inject/reject into any eventual typeclass.
--   
--   In a way, this is the "ultimate" multi-purpose <a>Interpret</a>
--   instance. You can use this to inject an <tt>f</tt> into a free
--   structure of any typeclass. If you want <tt>f</tt> to have a
--   <a>Monad</a> instance, for example, just use
--   
--   <pre>
--   <a>inject</a> :: f a -&gt; <a>Final</a> <a>Monad</a> f a
--   </pre>
--   
--   When you want to eventually interpret out the data, use:
--   
--   <pre>
--   <a>interpret</a> :: (f <a>~&gt;</a> g) -&gt; <a>Final</a> c f a -&gt; g a
--   </pre>
--   
--   Essentially, <tt><a>Final</a> c</tt> is the "free c". <tt><a>Final</a>
--   <a>Monad</a></tt> is the free <a>Monad</a>, etc.
--   
--   <a>Final</a> can theoretically replace <a>Ap</a>, <a>Ap1</a>,
--   <a>ListF</a>, <a>NonEmptyF</a>, <a>MaybeF</a>, <a>Free</a>,
--   <a>Identity</a>, <a>Coyoneda</a>, and other instances of
--   <a>FreeOf</a>, if you don't care about being able to pattern match on
--   explicit structure.
--   
--   However, it cannot replace <a>Interpret</a> instances that are not
--   free structures, like <a>Step</a>, <a>Steps</a>, <a>Backwards</a>,
--   etc.
--   
--   Note that this doesn't have instances for <i>all</i> the typeclasses
--   you could lift things into; you probably have to define your own if
--   you want to use <tt><a>Final</a> c</tt> as an <i>instance</i> of
--   <tt>c</tt> (using <a>liftFinal0</a>, <a>liftFinal1</a>,
--   <a>liftFinal2</a> for help).
newtype Final c f a
Final :: (forall g. c g => (forall x. f x -> g x) -> g a) -> Final c f a
[runFinal] :: Final c f a -> forall g. c g => (forall x. f x -> g x) -> g a

-- | A typeclass associating a free structure with the typeclass it is free
--   on.
--   
--   This essentially lists instances of <a>Interpret</a> where a "trip"
--   through <a>Final</a> will leave it unchanged.
--   
--   <pre>
--   <a>fromFree</a> . <a>FreeOf</a> == id
--   <a>FreeOf</a> . <a>fromFree</a> == id
--   </pre>
--   
--   This can be useful because <a>Final</a> doesn't have a concrete
--   structure that you can pattern match on and inspect, but <tt>t</tt>
--   might. This lets you work on a concrete structure if you desire.
class Interpret t => FreeOf c t | t -> c
fromFree :: FreeOf c t => t f ~> Final c f
toFree :: (FreeOf c t, Functor f) => Final c f ~> t f
fromFree :: (FreeOf c t, C t (Final c f)) => t f ~> Final c f
toFree :: (FreeOf c t, c (t f)) => Final c f ~> t f
instance forall k (f :: k). Data.Functor.Classes.Ord1 (Data.Functor.Combinator.ProxyF f)
instance Data.Functor.HFunctor.Internal.HFunctor Data.Functor.Combinator.ProxyF
instance Data.Functor.HFunctor.HBind Data.Functor.Combinator.ProxyF
instance Data.Functor.HFunctor.Inject Data.Functor.Combinator.ProxyF
instance Data.Functor.Interpret.Interpret Data.Functor.Combinator.ProxyF
instance forall k (f :: k). Data.Functor.Classes.Eq1 (Data.Functor.Combinator.ProxyF f)
instance forall k (f :: k). Data.Functor.Classes.Read1 (Data.Functor.Combinator.ProxyF f)
instance forall k (f :: k). Data.Functor.Classes.Show1 (Data.Functor.Combinator.ProxyF f)
instance forall k1 (f :: k1) k2 (a :: k2). (Data.Typeable.Internal.Typeable f, Data.Typeable.Internal.Typeable a, Data.Typeable.Internal.Typeable k1, Data.Typeable.Internal.Typeable k2) => Data.Data.Data (Data.Functor.Combinator.ProxyF f a)
instance forall k1 (f :: k1) k2 (a :: k2). GHC.Generics.Generic (Data.Functor.Combinator.ProxyF f a)
instance forall k (f :: k). Data.Traversable.Traversable (Data.Functor.Combinator.ProxyF f)
instance forall k (f :: k). Data.Foldable.Foldable (Data.Functor.Combinator.ProxyF f)
instance forall k (f :: k). GHC.Base.Functor (Data.Functor.Combinator.ProxyF f)
instance forall k1 (f :: k1) k2 (a :: k2). GHC.Classes.Ord (Data.Functor.Combinator.ProxyF f a)
instance forall k1 (f :: k1) k2 (a :: k2). GHC.Classes.Eq (Data.Functor.Combinator.ProxyF f a)
instance forall k1 (f :: k1) k2 (a :: k2). GHC.Read.Read (Data.Functor.Combinator.ProxyF f a)
instance forall k1 (f :: k1) k2 (a :: k2). GHC.Show.Show (Data.Functor.Combinator.ProxyF f a)
