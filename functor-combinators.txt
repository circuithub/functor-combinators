-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/mstksg/functor-combinators#readme</a>
@package functor-combinators
@version 0.1.0.0

module Control.Applicative.ListF

-- | This is the Free <a>Plus</a>.
newtype ListF f a
ListF :: [f a] -> ListF f a
[runListF] :: ListF f a -> [f a]
instance GHC.Base.Functor f => GHC.Base.Functor (Control.Applicative.ListF.ListF f)
instance GHC.Classes.Ord (f a) => GHC.Classes.Ord (Control.Applicative.ListF.ListF f a)
instance GHC.Classes.Eq (f a) => GHC.Classes.Eq (Control.Applicative.ListF.ListF f a)
instance GHC.Show.Show (f a) => GHC.Show.Show (Control.Applicative.ListF.ListF f a)
instance GHC.Base.Applicative f => GHC.Base.Applicative (Control.Applicative.ListF.ListF f)
instance GHC.Base.Functor f => Data.Functor.Alt.Alt (Control.Applicative.ListF.ListF f)
instance GHC.Base.Functor f => Data.Functor.Plus.Plus (Control.Applicative.ListF.ListF f)

module Control.Applicative.Step
data Step f a
Step :: Natural -> f a -> Step f a
[stepPos] :: Step f a -> Natural
[stepVal] :: Step f a -> f a
class Applicative f => AccumNat f
stepWith :: AccumNat f => Natural -> a -> f a
step :: AccumNat f => Natural -> f ()
instance GHC.Base.Functor f => GHC.Base.Functor (Control.Applicative.Step.Step f)
instance GHC.Classes.Ord (f a) => GHC.Classes.Ord (Control.Applicative.Step.Step f a)
instance GHC.Classes.Eq (f a) => GHC.Classes.Eq (Control.Applicative.Step.Step f a)
instance GHC.Show.Show (f a) => GHC.Show.Show (Control.Applicative.Step.Step f a)
instance GHC.Base.Applicative f => Control.Applicative.Step.AccumNat (Control.Applicative.Step.Step f)
instance GHC.Base.Monad m => Control.Applicative.Step.AccumNat (Control.Monad.Trans.Writer.Lazy.WriterT (Data.Semigroup.Internal.Sum GHC.Natural.Natural) m)
instance GHC.Base.Applicative f => GHC.Base.Applicative (Control.Applicative.Step.Step f)

module Control.Monad.Freer.Church

-- | Church-encoded Freer monad
newtype Free f a
Free :: (forall r. (a -> r) -> (forall s. f s -> (s -> r) -> r) -> r) -> Free f a
[runFree] :: Free f a -> forall r. (a -> r) -> (forall s. f s -> (s -> r) -> r) -> r
instance GHC.Base.Functor (Control.Monad.Freer.Church.Free f)
instance GHC.Base.Applicative (Control.Monad.Freer.Church.Free f)
instance GHC.Base.Monad (Control.Monad.Freer.Church.Free f)
instance Control.Monad.Free.Class.MonadFree f (Control.Monad.Freer.Church.Free f)

module Data.Functor.Combinator
type f ~> g = forall x. f x -> g x
infixr 0 ~>
class HFunctor t
hmap :: HFunctor t => (f ~> g) -> t f ~> t g

-- | Laws:
--   
--   <pre>
--   retract . inject == id
--   </pre>
class HFunctor t => Interpret t where {
    type family C t :: (Type -> Type) -> Constraint;
}
inject :: Interpret t => f ~> t f
retract :: (Interpret t, C t f) => t f ~> f
interpret :: (Interpret t, C t g) => (f ~> g) -> t f ~> g
class HBifunctor t
hleft :: HBifunctor t => (f ~> j) -> t f g ~> t j g
hright :: HBifunctor t => (g ~> k) -> t f g ~> t f k
hbimap :: HBifunctor t => (f ~> j) -> (g ~> k) -> t f g ~> t j k
class HBifunctor t => Tensor t where {
    type family I t :: Type -> Type;
}
intro1 :: Tensor t => f ~> t f (I t)
intro2 :: (Tensor t, Functor g) => g ~> t (I t) g
elim1 :: (Tensor t, Functor f) => t f (I t) ~> f
elim2 :: (Tensor t, Functor g) => t (I t) g ~> g
assoc :: (Tensor t, Functor f, Functor g, Functor h) => t f (t g h) ~> t (t f g) h
disassoc :: (Tensor t, Functor f, Functor g, Functor h) => t (t f g) h ~> t f (t g h)
data F t i f a
Done :: i a -> F t i f a
More :: t f (F t i f) a -> F t i f a
class (Tensor t, Interpret (TM t)) => Monoidal t where {
    type family TM t :: (Type -> Type) -> Type -> Type;
}
nilTM :: Monoidal t => I t ~> TM t f
consTM :: Monoidal t => t f (TM t f) ~> TM t f
unconsTM :: Monoidal t => TM t f ~> (I t :+: t f (TM t f))
appendTM :: Monoidal t => t (TM t f) (TM t f) ~> TM t f
fromF :: Monoidal t => F t (I t) f ~> TM t f
toF :: Monoidal t => TM t f ~> F t (I t) f
appendF :: Monoidal t => t (F t (I t) f) (F t (I t) f) ~> F t (I t) f
retractT :: (Monoidal t, C (TM t) f) => t f f ~> f
injectT :: (Monoidal t, C (TM t) f) => I t ~> f
toTM :: Monoidal t => t f f ~> TM t f
injectF :: forall t f. Tensor t => f ~> F t (I t) f
retractF :: forall t f. (Monoidal t, C (TM t) f) => F t (I t) f ~> f
interpretF :: forall t f g. (Monoidal t, C (TM t) g) => (f ~> g) -> F t (I t) f ~> g
newtype WrappedHBifunctor t (f :: Type -> Type) (g :: Type -> Type) a
WrappedHBifunctor :: t f g a -> WrappedHBifunctor t a
[unwrapHBifunctor] :: WrappedHBifunctor t a -> t f g a
data Cons :: ((Type -> Type) -> Type -> Type -> Type) -> (Type -> Type) -> (Type -> Type) -> Type -> Type
[:=>] :: f x -> p g x a -> Cons p f g a
type Comp = Cons Star
pattern Comp :: Functor f => f (g a) -> Comp f g a
unComp :: () => Comp f g a -> Functor f -> f (g a)
comp :: f (g a) -> Comp f g a
type DayCons = Cons Static
pattern DayCons :: Functor g => Day f g a -> DayCons f g a
unDayCons :: Cons Static b c d -> Day b c d

-- | Church-encoded Freer monad
newtype Free f a
Free :: (forall r. (a -> r) -> (forall s. f s -> (s -> r) -> r) -> r) -> Free f a
[runFree] :: Free f a -> forall r. (a -> r) -> (forall s. f s -> (s -> r) -> r) -> r
data Step f a
Step :: Natural -> f a -> Step f a
[stepPos] :: Step f a -> Natural
[stepVal] :: Step f a -> f a
data VoidT a
instance GHC.Base.Functor (t f g) => GHC.Base.Functor (Data.Functor.Combinator.WrappedHBifunctor t f g)
instance GHC.Base.Functor f => GHC.Base.Functor (Data.Functor.Combinator.Step f)
instance forall k (f :: k -> *) (a :: k). GHC.Classes.Ord (f a) => GHC.Classes.Ord (Data.Functor.Combinator.Step f a)
instance forall k (f :: k -> *) (a :: k). GHC.Classes.Eq (f a) => GHC.Classes.Eq (Data.Functor.Combinator.Step f a)
instance forall k (f :: k -> *) (a :: k). GHC.Show.Show (f a) => GHC.Show.Show (Data.Functor.Combinator.Step f a)
instance GHC.Base.Functor Data.Functor.Combinator.VoidT
instance forall k (a :: k). GHC.Classes.Ord (Data.Functor.Combinator.VoidT a)
instance forall k (a :: k). GHC.Classes.Eq (Data.Functor.Combinator.VoidT a)
instance forall k (a :: k). GHC.Show.Show (Data.Functor.Combinator.VoidT a)
instance GHC.Base.Functor f => GHC.Base.Functor (Data.Functor.Combinator.ListF f)
instance forall k (f :: k -> *) (a :: k). GHC.Classes.Ord (f a) => GHC.Classes.Ord (Data.Functor.Combinator.ListF f a)
instance forall k (f :: k -> *) (a :: k). GHC.Classes.Eq (f a) => GHC.Classes.Eq (Data.Functor.Combinator.ListF f a)
instance forall k (f :: k -> *) (a :: k). GHC.Show.Show (f a) => GHC.Show.Show (Data.Functor.Combinator.ListF f a)
instance Data.Functor.Combinator.HFunctor (Data.Functor.Day.Day f)
instance Data.Functor.Combinator.HFunctor ((GHC.Generics.:*:) f)
instance Data.Functor.Combinator.HFunctor ((GHC.Generics.:+:) f)
instance Data.Functor.Combinator.HFunctor (Data.Functor.Combinator.Cons Data.Profunctor.Types.Star f)
instance Data.Functor.Combinator.HFunctor (Data.Functor.Combinator.Cons Data.Semigroupoid.Static.Static f)
instance GHC.Base.Functor (Data.Functor.Combinator.Final GHC.Base.Functor f)
instance forall k (c :: (k -> *) -> GHC.Types.Constraint). Data.Functor.Combinator.HFunctor (Data.Functor.Combinator.Final c)
instance Data.Functor.Combinator.Interpret (Data.Functor.Combinator.Final c)
instance Data.Functor.Combinator.HBifunctor Data.Functor.Combinator.DayCons
instance Data.Functor.Combinator.Tensor Data.Functor.Combinator.DayCons
instance Data.Functor.Combinator.Monoidal Data.Functor.Combinator.DayCons
instance Data.Functor.Combinator.HBifunctor Data.Functor.Combinator.Comp
instance Data.Functor.Combinator.Tensor Data.Functor.Combinator.Comp
instance Data.Functor.Combinator.Monoidal Data.Functor.Combinator.Comp
instance GHC.Base.Functor (Data.Functor.Combinator.Free f)
instance GHC.Base.Applicative (Data.Functor.Combinator.Free f)
instance GHC.Base.Monad (Data.Functor.Combinator.Free f)
instance Control.Monad.Free.Class.MonadFree f (Data.Functor.Combinator.Free f)
instance Data.Functor.Combinator.HFunctor Data.Functor.Combinator.Free
instance Data.Functor.Combinator.Interpret Data.Functor.Combinator.Free
instance (forall x. GHC.Base.Functor (p g x)) => GHC.Base.Functor (Data.Functor.Combinator.Cons p f g)
instance forall k (t :: (* -> *) -> (* -> *) -> k -> *) (f :: * -> *). Data.Functor.Combinator.HBifunctor t => Data.Functor.Combinator.HFunctor (Data.Functor.Combinator.WrappedHBifunctor t f)
instance Data.Functor.Combinator.HFunctor Data.Functor.Combinator.Step
instance Data.Functor.Combinator.Interpret Data.Functor.Combinator.Step
instance Data.Functor.Combinator.Monoidal (GHC.Generics.:+:)
instance Data.Functor.Combinator.Tensor (GHC.Generics.:+:)
instance GHC.Base.Applicative f => GHC.Base.Applicative (Data.Functor.Combinator.ListF f)
instance Data.Functor.Combinator.Monoidal (GHC.Generics.:*:)
instance Data.Functor.Combinator.HFunctor Data.Functor.Combinator.ListF
instance Data.Functor.Combinator.Interpret Data.Functor.Combinator.ListF
instance Data.Functor.Combinator.Monoidal Data.Functor.Day.Day
instance forall k (i :: * -> *) (t :: k -> (* -> *) -> * -> *) (f :: k). (GHC.Base.Functor i, forall (g :: * -> *). GHC.Base.Functor g => GHC.Base.Functor (t f g)) => GHC.Base.Functor (Data.Functor.Combinator.F t i f)
instance forall k1 k2 (t :: (k1 -> *) -> (k2 -> *) -> k2 -> *) (i :: k2 -> *). Data.Functor.Combinator.HBifunctor t => Data.Functor.Combinator.HFunctor (Data.Functor.Combinator.F t i)
instance Data.Functor.Combinator.Tensor (GHC.Generics.:*:)
instance Data.Functor.Combinator.Tensor Data.Functor.Day.Day
instance Data.Functor.Combinator.HBifunctor (GHC.Generics.:*:)
instance Data.Functor.Combinator.HBifunctor Data.Functor.Day.Day
instance Data.Functor.Combinator.HBifunctor (GHC.Generics.:+:)
instance Data.Functor.Combinator.Interpret Data.Functor.Coyoneda.Coyoneda
instance Data.Functor.Combinator.Interpret Control.Applicative.Free.Ap
instance Data.Functor.Combinator.Interpret Control.Alternative.Free.Alt
instance Data.Functor.Combinator.HFunctor Data.Functor.Coyoneda.Coyoneda
instance Data.Functor.Combinator.HFunctor Control.Applicative.Free.Ap
instance Data.Functor.Combinator.HFunctor Control.Alternative.Free.Alt
instance Data.Functor.Combinator.HFunctor Control.Monad.Free.Church.F

module Data.Functor.Combinator.Class

-- | The type of a natural transformation between <tt>f</tt> and
--   <tt>g</tt>. Essentially translates one functor into another, leaving
--   its parameter unchanged.
type f ~> g = forall x. f x -> g x
infixr 0 ~>

-- | An <a>HFunctor</a> can be thought of a unary "functor transformer" ---
--   a basic functor combinator. It takes a functor as input and returns a
--   functor as output.
--   
--   It "enhances" a functor with extra structure (sort of like how a monad
--   transformer enhances a <a>Monad</a> with extra structure).
--   
--   As a uniform inteface, we can "swap the underlying functor" (also
--   sometimes called "hoisting"). This is what <a>hmap</a> does: it lets
--   us swap out the <tt>f</tt> in a <tt>t f</tt> for a <tt>t g</tt>.
--   
--   For example, the free monad <a>Free</a> takes a <a>Functor</a> and
--   returns a new <a>Functor</a>. In the process, it provides a monadic
--   structure over <tt>f</tt>. <a>hmap</a> lets us turn a <tt><a>Free</a>
--   f</tt> into a <tt><a>Free</a> g</tt>: a monad built over <tt>f</tt>
--   can be turned into a monad built over <tt>g</tt>.
--   
--   For the ability to move in and out of the enhanced functor, see
--   <a>Interpret</a>.
class HFunctor t

-- | If we can turn an <tt>f</tt> into a <tt>g</tt>, then we can turn a
--   <tt>t f</tt> into a <tt>t g</tt>.
--   
--   It must be the case that
--   
--   <pre>
--   <a>hmap</a> <a>id</a> == id
--   </pre>
--   
--   Essentially, <tt><tt>t</tt> f</tt> adds some "extra structure" to
--   <tt>f</tt>. <a>hmap</a> must swap out the functor, <i>without
--   affecting the added structure</i>.
--   
--   For example, <tt><a>ListF</a> f a</tt> is essentially a list of <tt>f
--   a</tt>s. If we <a>hmap</a> to swap out the <tt>f a</tt>s for <tt>g
--   a</tt>s, then we must ensure that the "added structure" (here, the
--   number of items in the list) remains the same. So, <a>hmap</a> must
--   preserve the number of items in the list.
--   
--   The law <tt><a>hmap</a> <a>id</a> == id</tt> is a way of formalizing
--   this informal property.
hmap :: HFunctor t => (f ~> g) -> t f ~> t g

-- | An <a>Interpret</a> lets us move in and out of the "enhanced"
--   <a>Functor</a>.
--   
--   For example, <tt><a>Free</a> f</tt> is <tt>f</tt> enhanced with
--   monadic structure. We get:
--   
--   <pre>
--   <a>inject</a>    :: f a -&gt; <a>Free</a> f a
--   <a>interpret</a> :: <a>Monad</a> m =&gt; (forall x. f x -&gt; m x) -&gt; <a>Free</a> f a -&gt; m a
--   </pre>
--   
--   <a>inject</a> will let us use our <tt>f</tt> inside the enhanced
--   <tt><a>Free</a> f</tt>. <a>interpret</a> will let us "extract" the
--   <tt>f</tt> from a <tt><a>Free</a> f</tt> if we can give an
--   <i>interpreting function</i> that interprets <tt>f</tt> into some
--   target <a>Monad</a>.
--   
--   The type family <a>C</a> tells us the typeclass constraint of the
--   "target" functor. For <a>Free</a>, it is <a>Monad</a>, but for other
--   <a>Interpret</a> instances, we might have other constraints.
--   
--   We enforce that:
--   
--   <pre>
--   <a>interpret</a> id . <a>inject</a> == id
--   </pre>
--   
--   That is, if we lift a value into our structure, then immediately
--   interpret it out as itself, it should lave the value unchanged.
class HFunctor t => Interpret t where {
    
    -- | The constraint on the target context of <a>interpret</a>.
    type family C t :: (Type -> Type) -> Constraint;
}

-- | Lift an <tt>f</tt> into the enhanced <tt>t f</tt> structure. Analogous
--   to <tt>lift</tt> from <tt>MonadTrans</tt>.
inject :: Interpret t => f ~> t f

-- | Remove the <tt>f</tt> out of the enhanced <tt>t f</tt> structure,
--   provided that <tt>f</tt> satisfies the necessary constraints. If it
--   doesn't, it needs to be properly <a>interpret</a>ed out.
retract :: (Interpret t, C t f) => t f ~> f

-- | Given an "interpeting function" from <tt>f</tt> to <tt>g</tt>,
--   interpret the <tt>f</tt> out of the <tt>t f</tt> into a final context
--   <tt>g</tt>.
interpret :: (Interpret t, C t g) => (f ~> g) -> t f ~> g

-- | A <a>HBifunctor</a> is like an <a>HFunctor</a>, but it enhances
--   <i>two</i> different functors instead of just one.
--   
--   Usually, it enhaces them "together" in some sort of combining way.
--   
--   This typeclass provides a uniform instance for "swapping out" or
--   "hoisting" the enhanced functors. We can hoist the first one with
--   <a>hleft</a>, the second one with <a>hright</a>, or both at the same
--   time with <a>hbimap</a>.
--   
--   For example, the <tt>f :*: g</tt> type gives us "both <tt>f</tt> and
--   <tt>g</tt>":
--   
--   <pre>
--   data (f <a>:*:</a> g) a = f a :*: g a
--   </pre>
--   
--   It combines both <tt>f</tt> and <tt>g</tt> into a unified structure
--   --- here, it does it by providing both <tt>f</tt> and <tt>g</tt>.
--   
--   The single law is:
--   
--   <pre>
--   <a>hbimap</a> <a>id</a> id == id
--   </pre>
--   
--   This ensures that <a>hleft</a>, <a>hright</a>, and <a>hbimap</a> do
--   not affect the structure that <tt>t</tt> adds on top of the underlying
--   functors.
class HBifunctor t

-- | Swap out the first transformed functor.
hleft :: HBifunctor t => (f ~> j) -> t f g ~> t j g

-- | Swap out the second transformed functor.
hright :: HBifunctor t => (g ~> k) -> t f g ~> t f k

-- | Swap out both transformed functors at the same time.
hbimap :: HBifunctor t => (f ~> j) -> (g ~> k) -> t f g ~> t j k

-- | A <a>HBifunctor</a> can be a <a>Tensor</a> if:
--   
--   <ol>
--   <li>There is some identity <tt>i</tt> where <tt>t i f</tt> is
--   equivalent to just <tt>f</tt>. That is, "enhancing" <tt>f</tt> with
--   <tt>t i</tt> does nothing.</li>
--   <li><tt>t</tt> is associative: <tt>f <tt>t</tt> (g <tt>t</tt> h)</tt>
--   is equivalent to @(f <tt>t</tt> g) <tt>t</tt> h).</li>
--   </ol>
--   
--   The methods in this class provide us useful ways of navigating a
--   <tt><a>Tensor</a> t</tt> with respect to this property.
class HBifunctor t => Tensor t where {
    
    -- | The identity of <tt><a>Tensor</a> t</tt>. If you "combine" <tt>f</tt>
    --   with the identity, it leaves <tt>f</tt> unchanged.
    --   
    --   For example, the identity of <a>:*:</a> is <a>Proxy</a>. This is
    --   because
    --   
    --   <pre>
    --   (<a>Proxy</a> :*: f) a
    --   </pre>
    --   
    --   is equivalent to just
    --   
    --   <pre>
    --   f a
    --   </pre>
    --   
    --   <a>:*:</a>-ing <tt>f</tt> with <a>Proxy</a> gives you no additional
    --   structure.
    type family I t :: Type -> Type;
}
intro1 :: Tensor t => f ~> t f (I t)
intro2 :: (Tensor t, Functor g) => g ~> t (I t) g
elim1 :: (Tensor t, Functor f) => t f (I t) ~> f
elim2 :: (Tensor t, Functor g) => t (I t) g ~> g
assoc :: (Tensor t, Functor f, Functor g, Functor h) => t f (t g h) ~> t (t f g) h
disassoc :: (Tensor t, Functor f, Functor g, Functor h) => t (t f g) h ~> t f (t g h)

-- | For some tensors <tt>t</tt>, you can represt the act of repeatedly
--   combining the same functor an arbitrary amount of times:
--   
--   <pre>
--   t f f                    -- 2 times
--   t f (t f f)              -- 3 times
--   t f (t f (t f f))        -- 4 times
--   t f (t f (t f (t f f)))  -- 5 times
--   </pre>
--   
--   Sometimes, we have a type that can <i>describe</i> this repeated
--   combination. For example, <tt><a>ListF</a> f</tt> is the type that
--   contains <tt>f</tt> <a>:*:</a>d with itself many number of times, and
--   <tt><a>Ap</a></tt> is the type that contains <tt>f</tt> <a>Day</a>d
--   with itself many number of times.
--   
--   <pre>
--   <a>ListF</a> [x, y]       == x <a>:*:</a> y
--   <a>ListF</a> [x, y, z]    == x <a>:*:</a> y <a>:*:</a> z
--   <a>ListF</a> [x, y, z, q] == x <a>:*:</a> y <a>:*:</a> z <a>:*:</a> q
--   </pre>
--   
--   This is convenient because it allows you to represent repeated
--   applications of <tt>t</tt> as a single data type.
--   
--   For example, <tt><a>Day</a> f f</tt> can be interpreted as "two
--   sequenced <tt>f</tt>s", allowing you to specify "I want exactly two
--   sequenced <tt>f</tt>s". If you want to specify "I want 0, 1, or many
--   <tt>f</tt>s sequenced after each other", then you can use
--   <tt><a>Ap</a> f</tt>.
--   
--   And, <tt>f <a>:*:</a> f</tt> can be interpreted as "a free selection
--   of two <tt>f</tt>s", allowing you to specify "I have to <tt>f</tt>s
--   that I can use". If you want to specify "I want 0, 1, or many
--   different <tt>f</tt>s that I can use", you can use <tt><a>ListF</a>
--   f</tt>.
--   
--   The <a>Monoidal</a> class unifies different such patterns. The
--   associated type <a>TM</a> is the "repeated aplications of <tt>t</tt>"
--   type.
--   
--   There are two ways to write an instance:
--   
--   <ol>
--   <li>Define <a>nilTM</a>, <a>consTM</a>, <a>unconsTM</a>, and
--   <a>appendTM</a>. These allow you to manipulate <tt><a>TM</a> t</tt> as
--   if it were a "list" of <tt>f</tt>s appended together with
--   <tt>t</tt>.</li>
--   <li>Define <a>fromF</a>, <a>toF</a>, and <a>appendF</a>. <a>F</a> is a
--   special data type that literally represents a linked list of
--   <tt>f</tt>s appended together with <tt>t</tt>. The default definitions
--   of <a>nilTM</a>, <a>consTM</a>, etc. then work on this
--   representation.The advantage of this family of functions is that they
--   allow you to work with many different <tt><a>TM</a> t</tt> types under
--   a uniform interface. For example, <tt><a>F</a> <a>Day</a>
--   <a>Identity</a></tt> gives you <a>Ap</a>, <tt><a>F</a> <tt>Comp</tt>
--   <a>Identity</a></tt> gives you <a>Free</a>, and <tt><a>F</a>
--   (<a>:*:</a>) <a>Proxy</a></tt> gives you <a>ListF</a>. However, most
--   people usually don't need to deal with this representation --- it's
--   mostly useful if you are defining new instances.</li>
--   </ol>
--   
--   Additionally, this class contains <a>retractT</a>, <a>interpretT</a>,
--   <a>pureT</a>, and <a>toTM</a>. These are useful functions of using
--   <tt>t</tt> as an interpreter combinator. They can all be derived from
--   other methods, but they are provided as a part of the typeclass to
--   allow implementors to provide more efficient versions.
class (Tensor t, Interpret (TM t)) => Monoidal t where {
    type family TM t :: (Type -> Type) -> Type -> Type;
}

-- | If <tt><a>TM</a> t f</tt> represents multiple applications of <tt>t
--   f</tt> with itself, then <tt>nilTM</tt> gives us "zero applications of
--   <tt>f</tt>".
nilTM :: Monoidal t => I t ~> TM t f

-- | Prepend an application of <tt>t f</tt> to the front of a <tt><a>TM</a>
--   t f</tt>.
consTM :: Monoidal t => t f (TM t f) ~> TM t f

-- | If a <tt><a>TM</a> t f</tt> represents multiple applications of <tt>t
--   f</tt> to itself, <a>unconsTM</a> lets us break it up into two
--   possibilities:
--   
--   <ol>
--   <li>The <tt><a>TM</a> t f</tt> had no applications of <tt>f</tt></li>
--   <li>The <tt><a>TM</a> t f</tt> had at least one application of
--   <tt>f</tt>; we return the "first" <tt>f</tt> applied to the rest of
--   the <tt>f</tt>s.</li>
--   </ol>
unconsTM :: Monoidal t => TM t f ~> (I t :+: t f (TM t f))

-- | If a <tt><a>TM</a> t f</tt> represents multiple applications of <tt>t
--   f</tt> to itself, then we can also "append" two <tt><a>TM</a> t
--   f</tt>s applied to themselves into one giant <tt><a>TM</a> t f</tt>
--   containing all of the <tt>t f</tt>s.
appendTM :: Monoidal t => t (TM t f) (TM t f) ~> TM t f

-- | Convert a linked list of <tt>t f</tt>s applied to themselves (stored
--   in the <a>F</a> type) into <tt><a>TM</a> t f</tt>, the data type
--   representing multiple applications of <tt>t f</tt> to itself.
--   
--   <tt><a>F</a> i (<a>I</a> t)</tt> can be thought of as a "universal"
--   representation of multiple-applications-to-self, and <tt><a>TM</a>
--   t</tt> can be thought of as a tailor-made represenation for your
--   specific <tt><a>Tensor</a> t</tt>.
fromF :: Monoidal t => F t (I t) f ~> TM t f

-- | The inverse of <a>fromF</a>: convert a <tt><a>TM</a> t f</tt> into a
--   linked list of <tt>t f</tt>s applied to themselves. See <a>fromF</a>
--   for more information.
toF :: Monoidal t => TM t f ~> F t (I t) f

-- | Append two linked lists of <tt>t f</tt> applied to itself together.
appendF :: Monoidal t => t (F t (I t) f) (F t (I t) f) ~> F t (I t) f

-- | A version of <a>retract</a> that works for a <a>Tensor</a>. It
--   retracts <i>both</i> <tt>f</tt>s into a single <tt>f</tt>.
retractT :: (Monoidal t, C (TM t) f) => t f f ~> f

-- | A version of <a>interpret</a> that works for a <a>Tensor</a>. It takes
--   two interpreting functions, and interprets both joined functors one
--   after the other into <tt>h</tt>.
interpretT :: (Monoidal t, C (TM t) h) => (f ~> h) -> (g ~> h) -> t f g ~> h

-- | If we have an instance of <tt>t</tt>, we can generate an <tt>f</tt>
--   based on how it interacts with <tt>t</tt>.
--   
--   Specialized (and simplified), this type is:
--   
--   <pre>
--   <a>pureT</a> <tt><a>Day</a>   :: <a>Applicative</a> f =&gt; a -&gt; f a  -- <a>pure</a>
--   <a>pureT</a> </tt><tt>Comp</tt>  :: <a>Monad</a> f =&gt; a -&gt; f a    -- <a>return</a>
--   <a>pureT</a> @(<a>:*:</a>) :: <a>Plus</a> f =&gt; f a          -- <a>zero</a>
--   </pre>
pureT :: (Monoidal t, C (TM t) f) => I t ~> f

-- | Embed a direct application of <tt>f</tt> to itself into a
--   <tt><a>TM</a> t f</tt>.
--   
--   Conceptually:
--   
--   <pre>
--   <a>toTM</a> (x, y) = [x, y]
--               = x : y : []
--   </pre>
--   
--   If you <a>unconsTM</a> the result, you'll get the first original
--   <tt>f</tt> consed with the second original <tt>f</tt> consed with a
--   <a>nilTM</a>.
toTM :: Monoidal t => t f f ~> TM t f

-- | A useful construction that works like a "linked list" of <tt>t f</tt>
--   applied to itself multiple times. That is, it contains <tt>t f f</tt>,
--   <tt>t f (t f f)</tt>, <tt>t f (t f (t f f))</tt>, etc.
--   
--   If <tt>t</tt> is <a>Monoidal</a>, then it means we can "collapse" this
--   linked list into some final type <tt><a>TM</a> t</tt> (<a>fromF</a>),
--   and also extract it back into a linked list (<a>toF</a>).
data F t i f a
Done :: i a -> F t i f a
More :: t f (F t i f) a -> F t i f a

-- | If we have <tt><a>Tensor</a> t</tt>, we can make a singleton <a>F</a>.
injectF :: forall t f. Tensor t => f ~> F t (I t) f

-- | If we have <tt><a>Monoidal</a> t</tt>, we can collapse all <tt>t
--   f</tt>s in the <a>F</a> into a single <tt>f</tt>.
retractF :: forall t f. (Monoidal t, C (TM t) f) => F t (I t) f ~> f

-- | If we have <tt><a>Monoidal</a> t</tt>, we can interpret all of the
--   <tt>f</tt>s in the <a>F</a> into a final target context <tt>g</tt>,
--   given an <tt>f</tt>-to-<tt>g</tt> interpreting function.
interpretF :: forall t f g. (Monoidal t, C (TM t) g) => (f ~> g) -> F t (I t) f ~> g

-- | Useful newtype to allow us to derive an <a>HFunctor</a> instance from
--   any instance of <a>HBifunctor</a>, using -XDerivingVia.
--   
--   For example, because we have <tt>instance <a>HBifunctor</a>
--   <a>Day</a></tt>, we can write:
--   
--   <pre>
--   deriving via (<a>WrappedHBifunctor</a> <a>Day</a> f) instance <a>HFunctor</a> (<a>Day</a> f)
--   </pre>
--   
--   to give us an automatic <a>HFunctor</a> instance and save us some
--   work.
newtype WrappedHBifunctor t (f :: Type -> Type) (g :: Type -> Type) a
WrappedHBifunctor :: t f g a -> WrappedHBifunctor t a
[unwrapHBifunctor] :: WrappedHBifunctor t a -> t f g a

-- | Church-encoded Freer monad
newtype Free f a
Free :: (forall r. (a -> r) -> (forall s. f s -> (s -> r) -> r) -> r) -> Free f a
[runFree] :: Free f a -> forall r. (a -> r) -> (forall s. f s -> (s -> r) -> r) -> r

-- | The identity functor of <a>:+:</a>.
data VoidT a
instance GHC.Base.Functor (t f g) => GHC.Base.Functor (Data.Functor.Combinator.Class.WrappedHBifunctor t f g)
instance GHC.Base.Functor Data.Functor.Combinator.Class.VoidT
instance forall k (a :: k). GHC.Classes.Ord (Data.Functor.Combinator.Class.VoidT a)
instance forall k (a :: k). GHC.Classes.Eq (Data.Functor.Combinator.Class.VoidT a)
instance forall k (a :: k). GHC.Show.Show (Data.Functor.Combinator.Class.VoidT a)
instance Data.Functor.Combinator.Class.HFunctor (Data.Functor.Day.Day f)
instance Data.Functor.Combinator.Class.HFunctor ((GHC.Generics.:*:) f)
instance Data.Functor.Combinator.Class.HFunctor ((GHC.Generics.:+:) f)
instance forall k (t :: (* -> *) -> (* -> *) -> k -> *) (f :: * -> *). Data.Functor.Combinator.Class.HBifunctor t => Data.Functor.Combinator.Class.HFunctor (Data.Functor.Combinator.Class.WrappedHBifunctor t f)
instance Data.Functor.Combinator.Class.Tensor (GHC.Generics.:+:)
instance Data.Functor.Combinator.Class.Monoidal (GHC.Generics.:*:)
instance Data.Functor.Combinator.Class.Monoidal Data.Functor.Day.Day
instance Data.Functor.Combinator.Class.Monoidal (GHC.Generics.:+:)
instance forall k (i :: * -> *) (t :: k -> (* -> *) -> * -> *) (f :: k). (GHC.Base.Functor i, forall (g :: * -> *). GHC.Base.Functor g => GHC.Base.Functor (t f g)) => GHC.Base.Functor (Data.Functor.Combinator.Class.F t i f)
instance forall k1 k2 (t :: (k1 -> *) -> (k2 -> *) -> k2 -> *) (i :: k2 -> *). Data.Functor.Combinator.Class.HBifunctor t => Data.Functor.Combinator.Class.HFunctor (Data.Functor.Combinator.Class.F t i)
instance Data.Functor.Combinator.Class.Tensor (GHC.Generics.:*:)
instance Data.Functor.Combinator.Class.Tensor Data.Functor.Day.Day
instance Data.Functor.Combinator.Class.HBifunctor (GHC.Generics.:*:)
instance Data.Functor.Combinator.Class.HBifunctor Data.Functor.Day.Day
instance Data.Functor.Combinator.Class.HBifunctor (GHC.Generics.:+:)
instance Data.Functor.Combinator.Class.Interpret Data.Functor.Coyoneda.Coyoneda
instance Data.Functor.Combinator.Class.Interpret Control.Applicative.Free.Ap
instance Data.Functor.Combinator.Class.Interpret Control.Applicative.ListF.ListF
instance Data.Functor.Combinator.Class.Interpret Control.Alternative.Free.Alt
instance Data.Functor.Combinator.Class.Interpret Control.Applicative.Step.Step
instance Data.Functor.Combinator.Class.Interpret Control.Monad.Freer.Church.Free
instance Data.Functor.Combinator.Class.HFunctor Data.Functor.Coyoneda.Coyoneda
instance Data.Functor.Combinator.Class.HFunctor Control.Applicative.Free.Ap
instance Data.Functor.Combinator.Class.HFunctor Control.Applicative.ListF.ListF
instance Data.Functor.Combinator.Class.HFunctor Control.Alternative.Free.Alt
instance Data.Functor.Combinator.Class.HFunctor Control.Applicative.Step.Step
instance Data.Functor.Combinator.Class.HFunctor Control.Monad.Free.Church.F
instance Data.Functor.Combinator.Class.HFunctor Control.Monad.Freer.Church.Free

module Data.Functor.Combinator.Cons

-- | A lot of tensors can be factored out into a <a>Cons</a> on some
--   parameterized profunctor. For example, we have:
--   
--   <pre>
--   <a>:.:</a> = <a>Cons</a> <a>Star</a>
--   <a>Day</a> = <a>Cons</a> <a>Static</a>
--   <a>:*:</a> = <a>Cons</a> <a>ProdK</a>
--   </pre>
--   
--   In the case of <a>:.:</a>, this actually allows us to have
--   <a>HFunctor</a> and <a>Interpret</a> instances for functor
--   composition, because the representation of <a>:.:</a> normally does
--   not allow this. This gives us a proper tensor to form <a>Free</a>,
--   which makes the free monad work nicely within our system.
--   
--   In the normal case, you can just use <a>Day</a> and <a>:*:</a> instead
--   of <tt><a>DayCons</a> = <a>Cons</a> <a>Static</a></tt> and
--   <tt><a>ProdCons</a> = <a>Cons</a> <a>ProdK</a></tt>. The only one that
--   gives us extra power is <tt><a>Comp</a> = <a>Cons</a>
--   <a>Star</a></tt>.
--   
--   You can use <a>DayCons</a> and <a>ProdCons</a> as <a>Day</a> and
--   <a>:*:</a> using the provided pattern synonyms.
data Cons :: ((Type -> Type) -> Type -> Type -> Type) -> (Type -> Type) -> (Type -> Type) -> Type -> Type
pattern Comp :: Functor f => f (g a) -> Comp f g a
pattern DayCons :: Functor g => Day f g a -> DayCons f g a
pattern ProdCons :: Functor f => (f :*: g) a -> ProdCons f g a

-- | Associates each <tt><a>Tensor</a> t</tt> with its <a>Cons</a>
--   equivalent, <tt><a>Cons</a> p</tt>.
--   
--   <tt>t</tt> need not always be a legal <a>Tensor</a>.
class Monoidal (Cons p) => Uncons p t | t -> p
uncons :: (Uncons p t, Functor g) => t f g ~> Cons p f g
cons :: (Uncons p t, Functor f) => Cons p f g ~> t f g

-- | A version of <a>:.:</a> that permits <a>HBifunctor</a>, <a>Tensor</a>,
--   and <a>Monoidal</a> instances.
type Comp = Cons Star
unComp :: () => Comp f g a -> Functor f -> f (g a)
comp :: f (g a) -> Comp f g a
type DayCons = Cons Static
unDayCons :: DayCons b c ~> Day b c
data ProdK g a b
ProdK :: (a -> b) -> g b -> ProdK g a b
type ProdCons = Cons ProdK
unProdCons :: () => ProdCons f g a -> Functor f -> (f :*: g) a
prodCons :: (f :*: g) ~> ProdCons f g
instance Data.Functor.Plus.Plus (Data.Functor.Combinator.Cons.ListFCo f)
instance GHC.Base.Applicative f => GHC.Base.Applicative (Data.Functor.Combinator.Cons.ListFCo f)
instance GHC.Base.Functor (Data.Functor.Combinator.Cons.ListFCo f)
instance GHC.Base.Functor g => GHC.Base.Functor (Data.Functor.Combinator.Cons.ProdK g a)
instance Data.Functor.Combinator.Class.HFunctor (Data.Functor.Combinator.Cons.Cons Data.Profunctor.Types.Star f)
instance Data.Functor.Combinator.Class.HFunctor (Data.Functor.Combinator.Cons.Cons Data.Semigroupoid.Static.Static f)
instance Data.Functor.Combinator.Class.HFunctor (Data.Functor.Combinator.Cons.Cons Data.Functor.Combinator.Cons.ProdK f)
instance Data.Functor.Combinator.Cons.Uncons Data.Profunctor.Types.Star (GHC.Generics.:.:)
instance Data.Functor.Combinator.Cons.Uncons Data.Semigroupoid.Static.Static Data.Functor.Day.Day
instance Data.Functor.Combinator.Cons.Uncons Data.Functor.Combinator.Cons.ProdK (GHC.Generics.:*:)
instance Data.Functor.Alt.Alt (Data.Functor.Combinator.Cons.ListFCo f)
instance Data.Functor.Combinator.Class.HFunctor Data.Functor.Combinator.Cons.ListFCo
instance Data.Functor.Combinator.Class.Interpret Data.Functor.Combinator.Cons.ListFCo
instance Data.Functor.Combinator.Class.Monoidal Data.Functor.Combinator.Cons.ProdCons
instance Data.Functor.Combinator.Class.HBifunctor Data.Functor.Combinator.Cons.ProdCons
instance Data.Functor.Combinator.Class.Tensor Data.Functor.Combinator.Cons.ProdCons
instance GHC.Base.Functor g => Data.Profunctor.Unsafe.Profunctor (Data.Functor.Combinator.Cons.ProdK g)
instance GHC.Base.Applicative g => GHC.Base.Applicative (Data.Functor.Combinator.Cons.ProdK g a)
instance Data.Functor.Combinator.Class.HBifunctor Data.Functor.Combinator.Cons.DayCons
instance Data.Functor.Combinator.Class.Tensor Data.Functor.Combinator.Cons.DayCons
instance Data.Functor.Combinator.Class.Monoidal Data.Functor.Combinator.Cons.DayCons
instance Data.Functor.Combinator.Class.HBifunctor Data.Functor.Combinator.Cons.Comp
instance Data.Functor.Combinator.Class.Tensor Data.Functor.Combinator.Cons.Comp
instance Data.Functor.Combinator.Class.Monoidal Data.Functor.Combinator.Cons.Comp
instance (forall x. GHC.Base.Functor (p g x)) => GHC.Base.Functor (Data.Functor.Combinator.Cons.Cons p f g)

module Data.Functor.Combinator.Final

-- | A simple way to inject/reject into any eventual typeclass.
--   Essentially, <tt><a>Final</a> c</tt> is the "free c". <tt><a>Final</a>
--   <a>Monad</a></tt> is the free <a>Monad</a>, etc.
--   
--   Useful for lifting a functor <tt>f</tt> into arbitrary structure given
--   by a typeclass.
--   
--   Note that this doesn't have instances for all the typeclasses; you
--   probably have to define your own if you want to use <tt><a>Final</a>
--   c</tt> as an <i>instance</i> of <tt>c</tt> (using <a>liftFinal0</a>,
--   <a>liftFinal1</a>, <a>liftFinal2</a> for help). This is mostly meant
--   to be usable as a final <a>Interpret</a>, with
--   
--   <pre>
--   <a>inject</a>    :: f a -&gt; <a>Final</a> c f a
--   <a>interpret</a> :: (f <a>~&gt;</a> g) -&gt; <a>Final</a> c f a -&gt; g a
--   </pre>
newtype Final c f a
Final :: (forall g. c g => (forall x. f x -> g x) -> g a) -> Final c f a
[runFinal] :: Final c f a -> forall g. c g => (forall x. f x -> g x) -> g a

-- | <a>Concretize</a> a <a>Final</a>.
fromFinal :: (Interpret t, c (t f)) => Final c f ~> t f

-- | <a>Finalize</a> an <a>Interpret</a> instance.
--   
--   <pre>
--   toFinal :: <tt>Coyoneda</tt> f <a>~&gt;</a> <a>Final</a> <a>Functor</a> f
--   toFinal :: <tt>Ap</tt> f <a>~&gt;</a> <a>Final</a> <a>Applicative</a> f
--   toFinal :: <tt>Alt</tt> f <a>~&gt;</a> <a>Final</a> <a>Alternative</a> f
--   toFinal :: <a>Free</a> f <a>~&gt;</a> <a>Final</a> <a>Monad</a> f
--   </pre>
--   
--   Note that the instance of <tt>c</tt> for <tt><a>Final</a> c</tt> must
--   be defined.
--   
--   Should form an isomorphism with <a>fromFinal</a>
toFinal :: (Interpret t, C t (Final c f)) => t f ~> Final c f
hoistFinalC :: (forall g x. (c g => g x) -> d g => g x) -> Final c f a -> Final d f a
liftFinal0 :: (forall g. c g => g a) -> Final c f a
liftFinal1 :: (forall g. c g => g a -> g b) -> Final c f a -> Final c f b
liftFinal2 :: (forall g. c g => g a -> g b -> g d) -> Final c f a -> Final c f b -> Final c f d
instance GHC.Base.Functor (Data.Functor.Combinator.Final.Final GHC.Base.Functor f)
instance GHC.Base.Functor (Data.Functor.Combinator.Final.Final GHC.Base.Applicative f)
instance GHC.Base.Applicative (Data.Functor.Combinator.Final.Final GHC.Base.Applicative f)
instance GHC.Base.Functor (Data.Functor.Combinator.Final.Final GHC.Base.Alternative f)
instance GHC.Base.Applicative (Data.Functor.Combinator.Final.Final GHC.Base.Alternative f)
instance GHC.Base.Alternative (Data.Functor.Combinator.Final.Final GHC.Base.Alternative f)
instance GHC.Base.Functor (Data.Functor.Combinator.Final.Final GHC.Base.Monad f)
instance GHC.Base.Applicative (Data.Functor.Combinator.Final.Final GHC.Base.Monad f)
instance GHC.Base.Monad (Data.Functor.Combinator.Final.Final GHC.Base.Monad f)
instance GHC.Base.Functor (Data.Functor.Combinator.Final.Final GHC.Base.MonadPlus f)
instance GHC.Base.Applicative (Data.Functor.Combinator.Final.Final GHC.Base.MonadPlus f)
instance GHC.Base.Monad (Data.Functor.Combinator.Final.Final GHC.Base.MonadPlus f)
instance GHC.Base.Alternative (Data.Functor.Combinator.Final.Final GHC.Base.MonadPlus f)
instance GHC.Base.MonadPlus (Data.Functor.Combinator.Final.Final GHC.Base.MonadPlus f)
instance GHC.Base.Functor (Data.Functor.Combinator.Final.Final Control.Applicative.Step.AccumNat f)
instance GHC.Base.Applicative (Data.Functor.Combinator.Final.Final Control.Applicative.Step.AccumNat f)
instance Control.Applicative.Step.AccumNat (Data.Functor.Combinator.Final.Final Control.Applicative.Step.AccumNat f)
instance Data.Functor.Combinator.Class.HFunctor (Data.Functor.Combinator.Final.Final c)
instance Data.Functor.Combinator.Class.Interpret (Data.Functor.Combinator.Final.Final c)
