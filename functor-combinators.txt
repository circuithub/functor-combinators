-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/mstksg/functor-combinators#readme</a>
@package functor-combinators
@version 0.1.0.0

module Data.Functor.Combinator
type f ~> g = forall x. f x -> g x
infixr 0 ~>
class HFunctor t
map1 :: HFunctor t => (f ~> g) -> t f ~> t g
class HFunctor t => Interpret t where {
    type family C t :: (Type -> Type) -> Constraint;
}
inject :: Interpret t => f ~> t f
retract :: (Interpret t, C t f) => t f ~> f
interpret :: (Interpret t, C t g) => (f ~> g) -> t f ~> g
class HBifunctor t where {
    type family I t :: Type -> Type;
}
hleft :: HBifunctor t => (f ~> j) -> t f g ~> t j g
hright :: HBifunctor t => (g ~> k) -> t f g ~> t f k
hbimap :: HBifunctor t => (f ~> j) -> (g ~> k) -> t f g ~> t j k
type HIso f g = forall p x. Profunctor p => p (f x) (f x) -> p (g x) (g x)
class (HBifunctor t, Functor (I t)) => Tensor t
intro1 :: Tensor t => f ~> t f (I t)
intro2 :: Tensor t => g ~> t (I t) g
elim1 :: (Tensor t, Functor f) => t f (I t) ~> f
elim2 :: (Tensor t, Functor g) => t (I t) g ~> g
assoc :: (Tensor t, Functor f, Functor g, Functor h) => t f (t g h) ~> t (t f g) h
disassoc :: (Tensor t, Functor f, Functor g, Functor h) => t (t f g) h ~> t f (t g h)
data Free t i f a
Done :: i a -> Free t i f a
More :: t f (Free t i f) a -> Free t i f a
class Tensor t => Monoidal t where {
    type family TM t :: (Type -> Type) -> Type -> Type;
}
toTM :: Monoidal t => t f f ~> TM t f
fromFree :: Monoidal t => Free t (I t) f ~> TM t f
retractT :: (Monoidal t, Interpret (TM t), C (TM t) f) => t f f ~> f
toFree :: (Monoidal t, Interpret (TM t), C (TM t) (Free t (I t) f)) => TM t f ~> Free t (I t) f

-- | We can embed <a>ListF</a> in <a>Alt</a>. However, we can't go
--   backwards, because <a>Alt</a> allows multiplication as well as
--   addition.
listFAlt :: ListF f ~> Alt f

-- | Extract an <a>Alt</a> back into a <a>ListF</a>, but fail if any
--   <a>&lt;*&gt;</a> was used. Should be a (partial) inverse with
--   <a>listFAlt</a>.
altListF :: forall f. Functor f => Alt f ~> (Maybe :.: ListF f)
instance GHC.Base.Functor f => GHC.Base.Functor (Data.Functor.Combinator.Step f)
instance forall k (f :: k -> *) (a :: k). GHC.Classes.Ord (f a) => GHC.Classes.Ord (Data.Functor.Combinator.Step f a)
instance forall k (f :: k -> *) (a :: k). GHC.Classes.Eq (f a) => GHC.Classes.Eq (Data.Functor.Combinator.Step f a)
instance forall k (f :: k -> *) (a :: k). GHC.Show.Show (f a) => GHC.Show.Show (Data.Functor.Combinator.Step f a)
instance GHC.Base.Functor Data.Functor.Combinator.VoidT
instance forall k (a :: k). GHC.Classes.Ord (Data.Functor.Combinator.VoidT a)
instance forall k (a :: k). GHC.Classes.Eq (Data.Functor.Combinator.VoidT a)
instance forall k (a :: k). GHC.Show.Show (Data.Functor.Combinator.VoidT a)
instance GHC.Base.Functor f => GHC.Base.Functor (Data.Functor.Combinator.ListF f)
instance forall k (f :: k -> *) (a :: k). GHC.Classes.Ord (f a) => GHC.Classes.Ord (Data.Functor.Combinator.ListF f a)
instance forall k (f :: k -> *) (a :: k). GHC.Classes.Eq (f a) => GHC.Classes.Eq (Data.Functor.Combinator.ListF f a)
instance forall k (f :: k -> *) (a :: k). GHC.Show.Show (f a) => GHC.Show.Show (Data.Functor.Combinator.ListF f a)
instance Data.Functor.Combinator.HFunctor Data.Functor.Combinator.Step
instance Data.Functor.Combinator.Interpret Data.Functor.Combinator.Step
instance Data.Functor.Combinator.Monoidal (GHC.Generics.:+:)
instance Data.Functor.Combinator.HBifunctor (GHC.Generics.:+:)
instance GHC.Base.Applicative f => GHC.Base.Applicative (Data.Functor.Combinator.ListF f)
instance Data.Functor.Combinator.Monoidal (GHC.Generics.:*:)
instance Data.Functor.Combinator.HFunctor Data.Functor.Combinator.ListF
instance Data.Functor.Combinator.Interpret Data.Functor.Combinator.ListF
instance Data.Functor.Combinator.Monoidal Data.Functor.Day.Day
instance Data.Functor.Combinator.Tensor (GHC.Generics.:*:)
instance Data.Functor.Combinator.Tensor Data.Functor.Day.Day
instance Data.Functor.Combinator.Tensor (GHC.Generics.:+:)
instance Data.Functor.Combinator.HBifunctor (GHC.Generics.:*:)
instance Data.Functor.Combinator.HBifunctor Data.Functor.Day.Day
instance Data.Functor.Combinator.Interpret Data.Functor.Coyoneda.Coyoneda
instance Data.Functor.Combinator.Interpret Control.Applicative.Free.Ap
instance Data.Functor.Combinator.Interpret Control.Alternative.Free.Alt
instance Data.Functor.Combinator.HFunctor Data.Functor.Coyoneda.Coyoneda
instance Data.Functor.Combinator.HFunctor Control.Applicative.Free.Ap
instance Data.Functor.Combinator.HFunctor Control.Alternative.Free.Alt
instance GHC.Base.Functor f => Data.Functor.Combinator.HFunctor ((GHC.Generics.:.:) f)
instance Data.Functor.Combinator.HFunctor Control.Monad.Free.Church.F

module Lib
someFunc :: IO ()
